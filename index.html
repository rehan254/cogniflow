<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CogniFlow - The LLM-Powered Idea Synthesizer</title>
    <link rel="icon" href="data:,">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/svg-to-pdfkit@0.1.8/source.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --ui-bg-dark: #0d0d0d;
            --ui-input-bg-dark: #2c2c2c;
            --ui-border-dark: #444444;
            --ui-text-dark: #e0e0e0;
            --ui-focus-dark: #e58d47;
            --ui-focus-glow: rgba(229, 141, 71, 0.7);
        }

        body {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            transition: background-color 1.5s ease-in-out;
        }

        #mindmap-container { flex-grow: 1; position: relative; background: transparent; }
        svg { display: block; width: 100%; height: 100%; }
        
        .link {
            fill: none;
            stroke-opacity: 0.6;
            stroke-width: 2.5px;
            stroke-linecap: round;
        }

        .node { cursor: pointer; }
        .node circle {
            stroke-width: 0;
            stroke: transparent;
            transition: stroke 0.6s, stroke-width 0.6s, filter 0.6s ease;
        }
        .node.selected circle {
            filter: drop-shadow(0 0 12px rgba(255, 255, 255, 0.4)) !important;
        }
        .node.drop-target circle {
            stroke-width: 4px;
            stroke: #66ff77; /* A bright green to indicate a valid drop target */
            stroke-dasharray: 4;
            animation: drop-target-dash 1s linear infinite;
        }
        .node.flashing circle {
            animation: flash 1s ease-out;
        }

        .node text {
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: central;
            font-weight: 500;
            transition: fill 1.5s ease-in-out;
            fill: #FFFFFF;
        }
        
        #bottom-panel {
            height: auto;
            max-height: 35vh;
            min-height: 80px;
            resize: vertical;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            background-color: var(--ui-bg-dark);
            color: var(--ui-text-dark);
        }

        #assistant-messages {
            flex: 1 1 auto;
            padding: 0.75rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-height: 200px;
        }

        .assistant-message {
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
            padding: 0.5rem;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.03);
        }

        .assistant-avatar {
            display: none;
        }

        .assistant-content {
            flex-grow: 1;
        }

        .assistant-name {
            font-weight: 600;
            color: var(--ui-focus-dark);
            font-size: 0.8rem;
            margin-bottom: 0.2rem;
        }

        .assistant-text {
            color: var(--ui-text-dark);
            line-height: 1.3;
            font-size: 0.8rem;
        }

        .assistant-suggestions {
            margin-top: 0.3rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.3rem;
        }

        .suggestion-chip {
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            background-color: var(--ui-input-bg-dark);
            border: none;
            color: var(--ui-text-dark);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .suggestion-chip:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }



        #user-controls {
            flex-shrink: 0;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Flow Assistant Insights Styling */
        .flow-insights {
            margin-top: 0.75rem;
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
        }

        .flow-insight {
            background-color: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 4px;
            padding: 0.6rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .flow-insight:hover {
            background-color: rgba(255, 255, 255, 0.06);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .flow-insight.expanded {
            background-color: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.2);
        }

        /* Enhanced styling for different insight types */
        .flow-insight.keyword-suggestion {
            border-left: 3px solid #e58d47;
            background-color: rgba(229, 141, 71, 0.05);
        }

        .flow-insight.keyword-suggestion:hover {
            background-color: rgba(229, 141, 71, 0.1);
            cursor: pointer;
        }

        .flow-insight.probing-question {
            border-left: 3px solid #6a9fdf;
            background-color: rgba(106, 159, 223, 0.05);
        }

        .flow-insight.overview-card {
            border-left: 3px solid #8abfff;
            background-color: rgba(138, 191, 255, 0.05);
        }

        .flow-insight.connection-insight {
            border-left: 3px solid #7aa36a;
            background-color: rgba(122, 163, 106, 0.05);
        }

        .flow-insight.gap-insight {
            border-left: 3px solid #ffaf7a;
            background-color: rgba(255, 175, 122, 0.05);
        }

        .flow-insight.structural-suggestion {
            border-left: 3px solid #aa9acd;
            background-color: rgba(170, 154, 205, 0.05);
        }

        .insight-title {
            font-weight: 500;
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.8rem;
            margin-bottom: 0.3rem;
            line-height: 1.2;
        }

        .insight-preview {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.75rem;
            line-height: 1.3;
            font-style: italic;
        }

        .insight-full {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.75rem;
            line-height: 1.4;
        }

        #user-instructions {
            padding: 0.5rem 1rem;
        }

        .instruction-text {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.85rem;
            opacity: 0.8;
            text-align: center;
            font-weight: 400;
            font-style: italic;
        }

        #input-container {
            padding: 1rem;
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        #node-input {
            flex-grow: 1;
            padding: 0.75rem;
            border-radius: 8px;
            border: none;
            outline: none;
            background-color: var(--ui-input-bg-dark);
            color: var(--ui-text-dark);
        }

        .ai-button {
            padding: 0.75rem 1rem;
            border-radius: 8px;
            border: none;
            background-color: var(--ui-input-bg-dark);
            color: var(--ui-text-dark);
            cursor: pointer;
            white-space: nowrap;
            transition: background-color 0.2s;
            display: none;
        }
        .ai-button:hover {
            background-color: var(--ui-focus-dark);
        }
        
        .suggestion-container {
            align-self: flex-start;
            width: 100%;
            padding: 0.5rem;
            border-radius: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .suggestion-node {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            border-radius: 20px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .suggestion-node:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        .suggestion-node .plus-icon {
            font-weight: bold;
        }
        
         .ai-response-bubble {
            align-self: flex-start;
            max-width: 80%;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            background-color: var(--ui-input-bg-dark);
        }
        .ai-response-bubble h3 {
            font-weight: bold;
            margin-bottom: 0.25rem;
            color: var(--ui-focus-dark);
        }

        .loading-indicator {
            position: absolute;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            display: none;
            z-index: 1000;
        }

        .theme-selector {
            position: absolute;
            top: 1rem;
            right: 1rem;
            z-index: 1000;
        }

        #theme-dropdown {
            background-color: var(--ui-input-bg-dark);
            color: var(--ui-text-dark);
            border: none;
            border-radius: 8px;
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            cursor: pointer;
            outline: none;
            transition: background-color 0.2s;
            backdrop-filter: blur(10px);
            background: rgba(44, 44, 44, 0.85);
        }

        #theme-dropdown:hover {
            background-color: var(--ui-focus-dark);
        }

        #theme-dropdown option {
            background-color: var(--ui-input-bg-dark);
            color: var(--ui-text-dark);
        }

        .expanded-node-container {
            border-radius: 16px;
            padding: 1rem;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            backdrop-filter: blur(5px);
        }

        .expanded-node-container h2 {
            font-size: 1.2rem;
            font-weight: bold;
            margin: 0;
            padding: 0;
            text-align: center;
            cursor: text;
        }
        
        .expanded-node-container textarea {
            flex-grow: 1;
            border: 1px solid transparent;
            border-radius: 8px;
            padding: 0.5rem;
            resize: none;
            outline: none;
            transition: border-color 0.6s ease;
        }

        .notes-editor {
            flex-grow: 1;
            overflow-y: auto;
            outline: none;
            padding: 0.5rem;
            border-radius: 8px;
            transition: border-color 0.2s, box-shadow 0.2s;
            border: 1px solid transparent;
        }

        .notes-editor:focus {
            border-color: rgba(255, 255, 255, 0.6);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.4);
        }

        .ai-actions-container {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            align-items: center;
            flex-grow: 1;
            width: 100%;
        }

        .ai-action-btn {
            padding: 4px 8px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            width: 80%;
            text-align: center;
            font-size: 9pt;
            font-weight: 500;
            transition: opacity 0.2s ease;
        }

        .ai-action-btn:hover {
            opacity: 0.8;
        }

        @keyframes flash {
            0% { filter: drop-shadow(0 0 0px #ffffff); }
            50% { filter: drop-shadow(0 0 12px #ffffff); }
            100% { filter: drop-shadow(0 0 0px #ffffff); }
        }

        @keyframes drop-target-dash {
            to {
                stroke-dashoffset: -8;
            }
        }

        @keyframes breathe {
            0%, 100% {
                transform: scale(1);
                opacity: 0.85;
            }
            50% {
                transform: scale(1.05);
                opacity: 0.95;
            }
        }

        /* Remove default browser outline on contenteditable elements */
        [contenteditable="true"]:focus {
            outline: none;
        }
    </style>
</head>
<body>

    <div id="mindmap-container">
        <svg id="mindmap-svg"></svg>
        <div id="loading-indicator" class="loading-indicator">CogniFlow is thinking...</div>
        
        <!-- Theme Selector -->
        <div id="theme-selector" class="theme-selector">
            <select id="theme-dropdown">
                <option value="Crimson Dusk">Crimson Dusk</option>
                <option value="Midnight Scholar">Midnight Scholar</option>
                <option value="Autumn Whisper">Autumn Whisper</option>
                <option value="Ocean Depths">Ocean Depths</option>
                <option value="Forest Sage">Forest Sage</option>
                <option value="Arctic Twilight">Arctic Twilight</option>
                <option value="Neon Pulse">Neon Pulse</option>
                <option value="Electric Storm">Electric Storm</option>
            </select>
        </div>
    </div>
    
    <div id="bottom-panel">
        <!-- LLM Assistant Messages Area (Top) -->
        <div id="assistant-messages">
            <div id="assistant-welcome" class="assistant-message">
                <div class="assistant-content">
                    <div class="assistant-name">üåä Flow Assistant</div>
                    <div class="assistant-text">Keeping you in the flow of ideas. I'll provide contextual insights and Google overview results to help expand your thinking without interruption.</div>
            </div>
        </div>
        </div>
        
        <!-- User Instructions & Controls Area (Bottom) -->
        <div id="user-controls">
            <div id="user-instructions">
                <div id="current-instruction" class="instruction-text">Click to create your central idea</div>
            </div>
        <div id="input-container">
                <input type="text" id="node-input" placeholder="">
            <button id="summarize-btn" class="ai-button">‚ú® Summarize</button>
            <button id="elaborate-btn" class="ai-button">‚ú® Elaborate</button>
            </div>
        </div>
    </div>

    <script type="module">
        // --- Setup ---
        const svg = d3.select("#mindmap-svg");
        const assistantMessages = document.getElementById('assistant-messages');
        const currentInstruction = document.getElementById('current-instruction');
        const nodeInput = document.getElementById('node-input');
        const summarizeBtn = document.getElementById('summarize-btn');
        const elaborateBtn = document.getElementById('elaborate-btn');
        const loadingIndicator = document.getElementById('loading-indicator');
        const container = document.getElementById('mindmap-container');
        
        let nodes = [];
        let links = [];
        let nextId = 0;
        let selectedNode = null;
        let isPrimedForChild = false;
        let activeExpandedNode = null;
        let historyStack = [];
        let isDragging = false;
        let isListEntryMode = false;
        let activeListNode = null;
        let dropTargetNode = null;

        // --- API Configuration ---
        const DEEPSEEK_API_KEY = 'sk-351b31abac2b48a7a18a087991970a81';
        const DEEPSEEK_API_URL = 'https://api.deepseek.com/chat/completions';
        
        // Rate limiting configuration
        let lastApiCall = 0;
        const MIN_API_INTERVAL = 2000; // Minimum 2 seconds between API calls
        let apiCallQueue = [];
        let isProcessingQueue = false;

        // Rate-limited API call with queue system
        async function callDeepSeekAPIWithRateLimit(prompt, maxChars = 260, priority = 'low') {
            return new Promise((resolve, reject) => {
                apiCallQueue.push({
                    prompt,
                    maxChars,
                    priority,
                    resolve,
                    reject,
                    timestamp: Date.now()
                });
                
                // Sort queue by priority (high priority first)
                apiCallQueue.sort((a, b) => {
                    if (a.priority === 'high' && b.priority !== 'high') return -1;
                    if (b.priority === 'high' && a.priority !== 'high') return 1;
                    return a.timestamp - b.timestamp;
                });
                
                processApiQueue();
            });
        }

        // Process the API call queue with rate limiting
        async function processApiQueue() {
            if (isProcessingQueue || apiCallQueue.length === 0) return;
            
            isProcessingQueue = true;
            updateQueueStatus();
            
            while (apiCallQueue.length > 0) {
                const now = Date.now();
                const timeSinceLastCall = now - lastApiCall;
                
                // Wait if we need to respect rate limit
                if (timeSinceLastCall < MIN_API_INTERVAL) {
                    await new Promise(resolve => setTimeout(resolve, MIN_API_INTERVAL - timeSinceLastCall));
                }
                
                const request = apiCallQueue.shift();
                lastApiCall = Date.now();
                
                try {
                    const result = await makeActualAPICall(request.prompt, request.maxChars);
                    request.resolve(result);
                } catch (error) {
                    // For 429 errors, put the request back in queue with exponential backoff
                    if (error.message.includes('429')) {
                        console.log('Rate limit hit, retrying after delay...');
                        setTimeout(() => {
                            apiCallQueue.unshift(request); // Put back at front of queue
                            processApiQueue();
                        }, 5000); // Wait 5 seconds before retry
                        continue;
                    }
                    request.reject(error);
                }
                
                // Small delay between requests
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            isProcessingQueue = false;
            updateQueueStatus();
        }

        // Update queue status indicator
        function updateQueueStatus() {
            const queueLength = apiCallQueue.length;
            if (queueLength > 0 || isProcessingQueue) {
                if (queueLength > 0) {
                    console.log(`ü§ñ Flow Assistant: ${queueLength} request(s) queued...`);
                }
                // Show loading indicator when processing queue
                if (isProcessingQueue) {
                    loadingIndicator.style.display = 'block';
                    loadingIndicator.textContent = queueLength > 0 ? 
                        `Processing ${queueLength + 1} AI requests...` : 
                        'Processing AI request...';
                }
            } else {
                // Hide loading indicator when queue is empty
                loadingIndicator.style.display = 'none';
                loadingIndicator.textContent = 'CogniFlow is thinking...';
            }
        }

        // Helper function for DeepSeek API calls - non-blocking
        async function callDeepSeekAPI(prompt, maxChars = 260) {
            // Use the rate-limited version for better performance
            return callDeepSeekAPIWithRateLimit(prompt, maxChars, 'low');
        }

        // Actual API call implementation
        async function makeActualAPICall(prompt, maxChars = 260) {
            // Add character limit instruction to prompt
            const limitedPrompt = `${prompt}\n\nIMPORTANT: Keep your response under ${maxChars} characters.`;
            
            try {
                // Don't block UI - show loading only for explicit user actions
                const isUserAction = prompt.includes('Summarize') || prompt.includes('Elaborate') || prompt.includes('Define') || prompt.includes('Solutions');
                if (isUserAction) {
                    loadingIndicator.style.display = 'block';
                }
                
                const response = await fetch(DEEPSEEK_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${DEEPSEEK_API_KEY}`
                    },
                    body: JSON.stringify({
                        model: 'deepseek-chat',
                        messages: [
                            {
                                role: 'user',
                                content: limitedPrompt
                            }
                        ],
                        temperature: 0.7,
                        max_tokens: maxChars > 500 ? 800 : 200,
                        top_p: 0.95
                    })
                });
                
                if (isUserAction) {
                    loadingIndicator.style.display = 'none';
                }
                
                if (!response.ok) {
                    throw new Error(`API request failed: ${response.status}`);
                }
                
                const data = await response.json();
                if (data.choices && data.choices[0] && data.choices[0].message) {
                    let text = data.choices[0].message.content;
                    // Enforce character limit
                    if (text.length > maxChars) {
                        text = text.substring(0, maxChars - 3) + '...';
                    }
                    return text;
                }
                return null;
            } catch (error) {
                loadingIndicator.style.display = 'none';
                console.error('DeepSeek API error:', error);
                throw error; // Re-throw to be handled by queue processor
            }
        }

        // Advanced Flow Assistant API call with structured JSON response
        async function callFlowAssistantAPI(contextData, priority = 'medium') {
            const systemPrompt = `You are "Flow Assistant," an expert thinking partner integrated within a mind-mapping application called CogniFlow. You are designed to operate as a dynamic, always-on resource, continually processing and updating insights relevant to the user's evolving mind map.

Your primary goal is to deepen the user's understanding of their own ideas, provoke new lines of inquiry with insightful questions, clarify ambiguities, and provide relevant, well-curated external context. Crucially, you aim to help the user build clear, well-structured, and insightful mind maps that reflect their thinking process, adapting your insights as their map evolves.

You are NOT a content generator who suggests new nodes out of the blue. You are a catalyst for the user's own thinking, encouraging structural improvement, deeper connections, and conceptual refinement. Your tone is insightful, concise, and helpful, like a brilliant research assistant. Your responses should be fresh, reflecting the latest available information and the current state of the mind map.`;

            const userPrompt = `You will receive a JSON object containing the current context of the user's mind map. This represents the latest state of the map, and your response should reflect updated information and insights.

CONTEXT INPUT:
${JSON.stringify(contextData, null, 2)}

Based on the provided context, perform the following three tasks sequentially and format your entire response as a single JSON object.

TASK 1: ANALYZE, CLARIFY, AND PROBE
- Analyze the fullMapStructure to understand the user's overarching topic and the specific angle of the currentNodeText
- Scan the currentNodeText for non-trivial technical terms or potentially ambiguous concepts and provide concise definitions
- If the currentNodeText is longer than ideal for a mind map (more than 5-7 words), suggest a more concise keyword or short phrase
- Formulate a single, powerful, open-ended Socratic question that challenges assumptions or explores implications

TASK 2: INTELLIGENT SEARCH & SUMMARIZATION
- Create an optimal search query based on the user's intent from the full context
- Generate 3-4 distinct, highly relevant summary "cards" representing key facts, perspectives, or concepts
- Each card should be exceptionally concise and directly useful for mind mapping

TASK 3: MIND MAP STRUCTURAL & CONNECTIVE INSIGHTS
- Identify potential connections between the current node and other nodes in the map
- Spot underdeveloped areas or gaps in the map structure
- Suggest one high-level structural refinement or organizational improvement

Your entire output must be a single, valid JSON object following this structure:

{
  "analysis": {
    "definitions": [
      {
        "term": "...",
        "definition": "..."
      }
    ],
    "keywordSuggestion": {
      "originalText": "...",
      "suggestedKeyword": "..."
    },
    "probingQuestion": "..."
  },
  "overviews": {
    "searchQueryUsed": "...",
    "results": [
      {
        "title": "...",
        "summary": "..."
      }
    ]
  },
  "mapInsights": {
    "potentialConnections": [
      {
        "type": "semantic_link",
        "description": "...",
        "fromNodeId": "...",
        "toNodeId": "...",
        "suggestedRelationshipPhrase": "..."
      }
    ],
    "underdevelopedAreas": [
      {
        "type": "potential_subtopic",
        "description": "...",
        "forNodeId": "..."
      }
    ],
    "structuralSuggestion": {
      "type": "clarity_refinement_question",
      "description": "..."
    }
  }
}`;

            try {
                // Use rate-limited API call for Flow Assistant
                const response = await fetch(DEEPSEEK_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${DEEPSEEK_API_KEY}`
                    },
                    body: JSON.stringify({
                        model: 'deepseek-chat',
                        messages: [
                            {
                                role: 'system',
                                content: systemPrompt
                            },
                            {
                                role: 'user',
                                content: userPrompt
                            }
                        ],
                        temperature: 0.7,
                        max_tokens: 2000,
                        top_p: 0.95
                    })
                });

                if (!response.ok) {
                    throw new Error(`API request failed: ${response.status}`);
                }

                const data = await response.json();
                if (data.choices && data.choices[0] && data.choices[0].message) {
                    const responseText = data.choices[0].message.content;
                    if (responseText) {
                        // Extract JSON from response
                        const jsonMatch = responseText.match(/\{[\s\S]*\}/);
                        if (jsonMatch) {
                            return JSON.parse(jsonMatch[0]);
                        }
                    }
                }
                return null;
            } catch (error) {
                loadingIndicator.style.display = 'none';
                console.error('Flow Assistant API error:', error);
                
                // Return a helpful error structure for display
                return {
                    error: true,
                    message: "Flow Assistant is temporarily unavailable. Please check your connection and try again.",
                    analysis: {
                        definitions: [],
                        keywordSuggestion: null,
                        probingQuestion: "What aspects of this topic would you like to explore further?"
                    },
                    overviews: {
                        searchQueryUsed: contextData.currentNodeText,
                        results: [
                            {
                                title: "Service Unavailable",
                                summary: "The Flow Assistant service is currently unavailable. Your mind map will continue to work normally."
                            }
                        ]
                    },
                    mapInsights: {
                        potentialConnections: [],
                        underdevelopedAreas: [],
                        structuralSuggestion: {
                            type: "general_tip",
                            description: "Consider organizing related concepts closer together in your mind map for better visual flow."
                        }
                    }
                };
            }
        }

        // Build context data for Flow Assistant
        function buildFlowAssistantContext(selectedNode) {
            if (!selectedNode) return null;

            // Find parent node
            const parentLink = links.find(l => l.target.id === selectedNode.id);
            const parentNode = parentLink ? parentLink.source : null;

            // Find sibling nodes
            const siblingNodes = parentNode ? 
                nodes.filter(n => {
                    const siblingLink = links.find(l => l.target.id === n.id);
                    return siblingLink && siblingLink.source.id === parentNode.id && n.id !== selectedNode.id;
                }) : [];

            // Build full map structure
            function buildMapStructure(node, visited = new Set()) {
                if (visited.has(node.id)) return null; // Prevent infinite loops
                visited.add(node.id);
                
                const children = links
                    .filter(l => l.source.id === node.id)
                    .map(l => buildMapStructure(l.target, visited))
                    .filter(child => child !== null);

                return {
                    text: node.name,
                    id: `node_${node.id}`,
                    children: children.length > 0 ? children : undefined
                };
            }

            const centralNode = nodes.find(n => n.depth === 0);
            const fullMapStructure = centralNode ? [buildMapStructure(centralNode)] : [];

            // Determine map goal from central node and first generation
            let mapGoal = "Exploring ideas and concepts";
            if (centralNode) {
                const firstGenNodes = nodes.filter(n => n.depth === 1);
                if (firstGenNodes.length > 0) {
                    mapGoal = `Exploring "${centralNode.name}" through: ${firstGenNodes.slice(0, 3).map(n => n.name).join(', ')}`;
                }
            }

            return {
                currentNodeText: selectedNode.name,
                currentNodeId: `node_${selectedNode.id}`,
                parentNodeText: parentNode ? parentNode.name : null,
                parentNodeId: parentNode ? `node_${parentNode.id}` : null,
                siblingNodeTexts: siblingNodes.map(n => n.name),
                siblingNodeIds: siblingNodes.map(n => `node_${n.id}`),
                fullMapStructure: fullMapStructure,
                mapGoal: mapGoal
            };
        }

        // --- Flow Assistant: Contextual Insights Provider ---
        // Provides contextual insights and Google overview results 
        // to help users stay in flow while exploring ideas

        // Show Flow Assistant welcome message
        function showFlowAssistantWelcome() {
            const assistantMessages = document.getElementById('assistant-messages');
            assistantMessages.innerHTML = `
                <div id="assistant-welcome" class="assistant-message">
                    <div class="assistant-content">
                        <div class="assistant-name">üåä Flow Assistant</div>
                        <div class="assistant-text">Keeping you in the flow of ideas. I'll provide contextual insights and Google overview results to help expand your thinking without interruption.</div>
                    </div>
                </div>
            `;
        }

        // Flow Assistant function for when a node is selected
        async function activateFlowAssistant(selectedNode) {
            const assistantMessages = document.getElementById('assistant-messages');
            
            // Show loading state
            assistantMessages.innerHTML = `
                <div class="assistant-message">
                    <div class="assistant-content">
                        <div class="assistant-name">üåä Flow Assistant</div>
                        <div class="assistant-text">Analyzing "${selectedNode.name}" and gathering comprehensive insights...</div>
                    </div>
                </div>
            `;

            // Build context for the Flow Assistant
            const contextData = buildFlowAssistantContext(selectedNode);
            if (!contextData) {
                showFlowAssistantWelcome();
                return;
            }

            // Get structured insights from the Flow Assistant
            const insights = await callFlowAssistantAPI(contextData);
            
            // Display insights in assistant area
            if (insights) {
                displayStructuredFlowInsights(selectedNode, insights);
            } else {
                // Fallback to simple insights if API fails
                const fallbackContext = buildMindMapContext();
                const fallbackInsights = await generateFlowInsights(selectedNode, fallbackContext);
                displayFlowInsights(selectedNode, fallbackInsights);
            }
        }

        // Generate flow insights using Gemini AI based on node context
        async function generateFlowInsights(node, context) {
            const prompt = `You are the Flow Assistant, helping users explore ideas about "${context}".

The user is thinking about: "${node.name}"

Generate 4-6 informational insights that would provide valuable context and expand understanding of "${node.name}" in relation to "${context}".

For each insight, provide:
- A descriptive title (max 50 characters)
- Informative content (max 120 characters)

Format as JSON array: [{"title": "...", "content": "..."}]

Focus on background information, context, examples, or interesting facts that would enrich understanding.`;

            try {
                const response = await callDeepSeekAPI(prompt, 700);
                if (response) {
                    const jsonMatch = response.match(/\[[\s\S]*\]/);
                    if (jsonMatch) {
                        const insights = JSON.parse(jsonMatch[0]);
                        return insights.slice(0, 6);
                    }
                }
            } catch (error) {
                console.error('Error generating flow insights:', error);
            }

            // Fallback insights based on context
            return generateFallbackInsights(node, context);
        }

        // Generate fallback insights if AI fails
        function generateFallbackInsights(node, context) {
            const nodeName = node.name.toLowerCase();
            
            // Smart insights based on common patterns
            if (nodeName.includes('tool') || nodeName.includes('equipment')) {
                return [
                    { title: "Essential Tool Categories", content: "Hand tools, power tools, and specialty equipment form the foundation of any toolkit" },
                    { title: "Tool Evolution", content: "Modern tools have evolved from ancient designs, combining traditional principles with new materials" },
                    { title: "Quality vs Cost", content: "Professional-grade tools offer durability and precision but may not be necessary for casual use" },
                    { title: "Maintenance Principles", content: "Proper cleaning, storage, and regular maintenance extend tool life significantly" }
                ];
            } else if (context.toLowerCase().includes('garden')) {
                return [
                    { title: "Seasonal Rhythms", content: "Gardens follow natural cycles that vary by climate zone and local weather patterns" },
                    { title: "Soil Ecosystem", content: "Healthy soil contains billions of microorganisms that support plant growth and nutrient cycling" },
                    { title: "Plant Relationships", content: "Companion planting utilizes beneficial relationships between different plant species" },
                    { title: "Water Wisdom", content: "Efficient watering considers soil type, plant needs, and environmental conditions" }
                ];
            } else {
                return [
                    { title: `Understanding ${node.name}`, content: `Core principles and foundational concepts that define ${node.name}` },
                    { title: `Context & Background`, content: `Historical development and current relevance of ${node.name}` },
                    { title: `Key Considerations`, content: `Important factors to keep in mind when working with ${node.name}` },
                    { title: `Related Concepts`, content: `Connected ideas and complementary topics related to ${node.name}` }
                ];
            }
        }

        // Display Flow Assistant insights in the assistant area
        function displayFlowInsights(node, insights) {
            const assistantMessages = document.getElementById('assistant-messages');
            
            let insightsHTML = insights.map((insight, index) => `
                <div class="flow-insight" onclick="expandInsight(this)">
                    <div class="insight-title">${insight.title}</div>
                    <div class="insight-preview">${insight.content || insight.description || ''}</div>
                    <div class="insight-full" style="display: none;">${insight.content || insight.description || ''}</div>
                </div>
            `).join('');

            assistantMessages.innerHTML = `
                <div class="assistant-message">
                    <div class="assistant-content">
                        <div class="assistant-name">üåä Flow Assistant</div>
                        <div class="assistant-text">Contextual insights for "${node.name}":</div>
                        <div class="flow-insights">
                            ${insightsHTML}
                        </div>
                    </div>
                </div>
            `;
        }

        // Display structured Flow Assistant insights from the new JSON format
        function displayStructuredFlowInsights(node, insights) {
            const assistantMessages = document.getElementById('assistant-messages');
            
            // Handle error cases
            if (insights.error) {
                assistantMessages.innerHTML = `
                    <div class="assistant-message">
                        <div class="assistant-content">
                            <div class="assistant-name">‚ö†Ô∏è Flow Assistant</div>
                            <div class="assistant-text">${insights.message}</div>
                            <div class="flow-insights">
                                <div class="flow-insight" onclick="expandInsight(this)">
                                    <div class="insight-title">üîÑ Try Again</div>
                                    <div class="insight-preview">Click to retry Flow Assistant analysis...</div>
                                    <div class="insight-full" style="display: none;">
                                        The Flow Assistant encountered an issue. Click here to retry the analysis for "${node.name}".
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                // Add retry functionality
                const retryButton = assistantMessages.querySelector('.flow-insight');
                retryButton.addEventListener('click', () => {
                    activateFlowAssistant(node);
                });
                return;
            }
            
            // Build the analysis section
            let analysisHTML = '';
            if (insights.analysis) {
                                 // Definitions
                if (insights.analysis.definitions && insights.analysis.definitions.length > 0) {
                    const definitionsHTML = insights.analysis.definitions.map(def => `
                        <div class="flow-insight" onclick="expandInsight(this)">
                            <div class="insight-title">üìö ${def.term}</div>
                            <div class="insight-preview">${def.definition.substring(0, 120)}</div>
                            <div class="insight-full" style="display: none;">${def.definition}</div>
                        </div>
                    `).join('');
                    analysisHTML += definitionsHTML;
                }

                // Keyword suggestion
                if (insights.analysis.keywordSuggestion && insights.analysis.keywordSuggestion.suggestedKeyword !== insights.analysis.keywordSuggestion.originalText) {
                    analysisHTML += `
                        <div class="flow-insight keyword-suggestion" onclick="expandInsight(this)">
                            <div class="insight-title">‚úèÔ∏è Suggested Refinement</div>
                            <div class="insight-preview">Consider: "${insights.analysis.keywordSuggestion.suggestedKeyword}"</div>
                            <div class="insight-full" style="display: none;">
                                <strong>Original:</strong> "${insights.analysis.keywordSuggestion.originalText}"<br/>
                                <strong>Suggested:</strong> "${insights.analysis.keywordSuggestion.suggestedKeyword}"<br/>
                                <em>Click to apply this suggestion to your node.</em>
                            </div>
                        </div>
                    `;
                }

                // Probing question
                if (insights.analysis.probingQuestion) {
                    analysisHTML += `
                        <div class="flow-insight probing-question" onclick="expandInsight(this)">
                            <div class="insight-title">ü§î Think Deeper</div>
                            <div class="insight-preview">${insights.analysis.probingQuestion}</div>
                            <div class="insight-full" style="display: none;">${insights.analysis.probingQuestion}</div>
                        </div>
                    `;
                }
            }

            // Build the overviews section
            let overviewsHTML = '';
            if (insights.overviews && insights.overviews.results) {
                overviewsHTML = insights.overviews.results.map(result => `
                    <div class="flow-insight overview-card" onclick="expandInsight(this)">
                        <div class="insight-title">üîç ${result.title}</div>
                        <div class="insight-preview">${result.summary}</div>
                        <div class="insight-full" style="display: none;">${result.summary}</div>
                    </div>
                `).join('');
            }

            // Build the map insights section
            let mapInsightsHTML = '';
            if (insights.mapInsights) {
                // Potential connections
                if (insights.mapInsights.potentialConnections && insights.mapInsights.potentialConnections.length > 0) {
                    mapInsightsHTML += insights.mapInsights.potentialConnections.map(connection => `
                        <div class="flow-insight connection-insight" onclick="expandInsight(this)">
                            <div class="insight-title">üîó Connection Found</div>
                            <div class="insight-preview">${connection.description}</div>
                            <div class="insight-full" style="display: none;">
                                ${connection.description}<br/>
                                <em>Relationship: ${connection.suggestedRelationshipPhrase}</em>
                            </div>
                        </div>
                    `).join('');
                }

                // Underdeveloped areas
                if (insights.mapInsights.underdevelopedAreas && insights.mapInsights.underdevelopedAreas.length > 0) {
                    mapInsightsHTML += insights.mapInsights.underdevelopedAreas.map(area => `
                        <div class="flow-insight gap-insight" onclick="expandInsight(this)">
                            <div class="insight-title">üí° Potential Gap</div>
                            <div class="insight-preview">${area.description}</div>
                            <div class="insight-full" style="display: none;">${area.description}</div>
                        </div>
                    `).join('');
                }

                // Structural suggestion
                if (insights.mapInsights.structuralSuggestion) {
                    mapInsightsHTML += `
                        <div class="flow-insight structural-suggestion" onclick="expandInsight(this)">
                            <div class="insight-title">üèóÔ∏è Structure Tip</div>
                            <div class="insight-preview">${insights.mapInsights.structuralSuggestion.description}</div>
                            <div class="insight-full" style="display: none;">${insights.mapInsights.structuralSuggestion.description}</div>
                        </div>
                    `;
                }
            }

            // Combine all sections
            const allInsights = analysisHTML + overviewsHTML + mapInsightsHTML;

            assistantMessages.innerHTML = `
                <div class="assistant-message">
                    <div class="assistant-content">
                        <div class="assistant-name">üåä Flow Assistant</div>
                        <div class="assistant-text">Comprehensive analysis for "${node.name}":</div>
                        <div class="flow-insights">
                            ${allInsights}
                        </div>
                    </div>
                </div>
            `;

            // Add click handler for keyword suggestions
            const keywordSuggestions = assistantMessages.querySelectorAll('.keyword-suggestion');
            keywordSuggestions.forEach(suggestion => {
                suggestion.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (insights.analysis.keywordSuggestion && confirm(`Apply suggested refinement: "${insights.analysis.keywordSuggestion.suggestedKeyword}"?`)) {
                        node.name = insights.analysis.keywordSuggestion.suggestedKeyword;
                        updateGraph();
                        // Re-run Flow Assistant with the updated node
                        setTimeout(() => activateFlowAssistant(node), 500);
                    }
                });
            });
        }

        // Expand/collapse insight card
        function expandInsight(element) {
            const preview = element.querySelector('.insight-preview');
            const full = element.querySelector('.insight-full');
            
            if (full.style.display === 'none') {
                preview.style.display = 'none';
                full.style.display = 'block';
                element.classList.add('expanded');
            } else {
                preview.style.display = 'block';
                full.style.display = 'none';
                element.classList.remove('expanded');
            }
        }

        // Helper function to escape strings for JavaScript
        function escapeForJs(text) {
            return text.replace(/'/g, "\\'").replace(/"/g, '\\"');
        }

        // --- Advanced Theme Engine ---
        const themeDefinitions = {
            "Midnight Scholar": {
                dynastyPalettes: [
                    ["#2a5a82", "#4a7db9", "#6a9fdf", "#8abfff", "#aadaff"],
                    ["#8a4c4c", "#bc6c6c", "#d48c8c", "#ecacac", "#ffcccc"],
                    ["#6a5a7d", "#8a7aad", "#aa9acd", "#cabbed", "#eadbff"],
                    ["#5a5a5a", "#7a7a7a", "#9a9a9a", "#bababa", "#dadada"],
                    ["#4d6582", "#6d85b2", "#8da5d2", "#adc5f2", "#cde5ff"]
                ],
                backgroundBase: "#4a7aa2"
            },
            "Autumn Whisper": {
                dynastyPalettes: [
                    ["#8d4f2a", "#cd6f3a", "#ed8f5a", "#ffaf7a", "#ffcf9a"],
                    ["#9b5439", "#db7459", "#fb9479", "#ffb499", "#ffd4b9"],
                    ["#5a6539", "#7a8559", "#9aa579", "#bac599", "#dae5b9"],
                    ["#8d2020", "#cd4040", "#ed6060", "#ff8080", "#ffa0a0"],
                    ["#3f5353", "#5f7373", "#7f9393", "#9fb3b3", "#bfd3d3"]
                ],
                backgroundBase: "#ad6f4a"
            },
            "Ocean Depths": {
                dynastyPalettes: [
                    ["#2a4a73", "#4a6aa3", "#6a8ad3", "#8aaaff", "#aacaff"],
                    ["#2a5353", "#4a7373", "#6a9393", "#8ab3b3", "#aad3d3"],
                    ["#2f2f87", "#4f4fb7", "#6f6fd7", "#8f8ff7", "#afafff"],
                    ["#3f5353", "#5f7373", "#7f9393", "#9fb3b3", "#bfd3d3"],
                    ["#7d2a96", "#bd4ad6", "#dd6af6", "#fd8aff", "#ffaaff"]
                ],
                backgroundBase: "#4a6a93"
            },
            "Forest Sage": {
                dynastyPalettes: [
                    ["#3a632a", "#5a834a", "#7aa36a", "#9ac38a", "#bae3aa"],
                    ["#8d4f2a", "#cd6f3a", "#ed8f5a", "#ffaf7a", "#ffcf9a"],
                    ["#536339", "#738359", "#93a379", "#b3c399", "#d3e3b9"],
                    ["#7d9b7d", "#9dbb9d", "#bddbbd", "#ddfbdd", "#fdfffd"],
                    ["#3f5353", "#5f7373", "#7f9393", "#9fb3b3", "#bfd3d3"]
                ],
                backgroundBase: "#5a834a"
            },
            "Crimson Dusk": {
                dynastyPalettes: [
                    ["#8d2020", "#cd4040", "#ed6060", "#ff8080", "#ffa0a0"],
                    ["#8d2060", "#cd40a0", "#ed60c0", "#ff80e0", "#ffa0ff"],
                    ["#5e2082", "#8e40c2", "#ae60e2", "#ce80ff", "#eea0ff"],
                    ["#3f5353", "#5f7373", "#7f9393", "#9fb3b3", "#bfd3d3"],
                    ["#8d4f2a", "#cd6f3a", "#ed8f5a", "#ffaf7a", "#ffcf9a"]
                ],
                backgroundBase: "#ad4040"
            },
            "Arctic Twilight": {
                dynastyPalettes: [
                    ["#4e7d9b", "#6e9dbb", "#8ebddb", "#aeddfb", "#cefdff"],
                    ["#4e4e9c", "#6e6ecc", "#8e8eec", "#aeaeff", "#ceceef"],
                    ["#3f5353", "#5f7373", "#7f9393", "#9fb3b3", "#bfd3d3"],
                    ["#606060", "#808080", "#a0a0a0", "#c0c0c0", "#e0e0e0"],
                    ["#7d2a96", "#bd4ad6", "#dd6af6", "#fd8aff", "#ffaaff"]
                ],
                backgroundBase: "#6e9dbb"
            },
            "Neon Pulse": {
                dynastyPalettes: [
                    ["#e3208a", "#ff40aa", "#ff60ca", "#ff80ea", "#ffaaff"],
                    ["#20e380", "#40ffa0", "#60ffc0", "#80ffe0", "#aaffff"],
                    ["#8020e3", "#a040ff", "#c060ff", "#e080ff", "#ffaaff"],
                    ["#e38020", "#ffa040", "#ffc060", "#ffe080", "#ffffaa"],
                    ["#2080e3", "#40a0ff", "#60c0ff", "#80e0ff", "#aaffff"]
                ],
                backgroundBase: "#5a4073"
            },
            "Electric Storm": {
                dynastyPalettes: [
                    ["#ffff20", "#ffff40", "#ffff60", "#ffff80", "#ffffaa"],
                    ["#ff5520", "#ff7540", "#ff9560", "#ffb580", "#ffd5aa"],
                    ["#20ffff", "#40ffff", "#60ffff", "#80ffff", "#aaffff"],
                    ["#ff2093", "#ff40b3", "#ff60d3", "#ff80f3", "#ffaaff"],
                    ["#46d346", "#66f366", "#86ff86", "#a6ffa6", "#c6ffc6"]
                ],
                backgroundBase: "#404073"
            }
        };

        let currentTheme = "Midnight Scholar"; // Default theme
        let dynastyPalettes = themeDefinitions[currentTheme].dynastyPalettes;
        
        // Darken Midnight Scholar background
        themeDefinitions["Midnight Scholar"].backgroundBase = "#2a3a4a"; // darker than before
        
        // Track which palette each first-gen node gets
        let firstGenPaletteAssignment = new Map();
        
        const defs = svg.append("defs");

        // Create radial gradient for edge fadeout effect
        const fadeoutGradient = defs.append("radialGradient")
            .attr("id", "edge-fadeout")
            .attr("cx", "50%")
            .attr("cy", "50%")
            .attr("r", "50%");

        fadeoutGradient.append("stop")
            .attr("offset", "0%")
            .attr("stop-opacity", "1");

        fadeoutGradient.append("stop")
            .attr("offset", "85%")
            .attr("stop-opacity", "1");

        fadeoutGradient.append("stop")
            .attr("offset", "100%")
            .attr("stop-opacity", "0");

        // Add Roboto Slab to the page (if not already present)
        if (!document.getElementById('roboto-slab-font')) {
            const link = document.createElement('link');
            link.id = 'roboto-slab-font';
            link.rel = 'stylesheet';
            link.href = 'https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@400;500;700&display=swap';
            document.head.appendChild(link);
        }

        function applyTheme() {
            const theme = themeDefinitions[currentTheme];
            // Set the focus color for UI elements using the first dynasty's primary color
            const focusColorHex = theme.dynastyPalettes[0][0];
            document.querySelector(':root').style.setProperty('--ui-focus-dark', focusColorHex);
            const focusColor = d3.color(focusColorHex);
            if (focusColor) {
                 document.querySelector(':root').style.setProperty('--ui-focus-glow', `rgba(${focusColor.r}, ${focusColor.g}, ${focusColor.b}, 0.7)`);
            }
            // Create a sophisticated background gradient based on theme
            const baseColor = d3.hsl(theme.backgroundBase);
            baseColor.s *= 0.4; // Reduced saturation by 20% (was 0.5, now 0.4)
            const centerColor = d3.color(baseColor).darker(2.875).toString(); // 15% darker (2.5 * 1.15 = 2.875)
            const edgeColor = d3.color(baseColor).darker(4.6).toString(); // 15% darker (4 * 1.15 = 4.6)
            document.body.style.background = `radial-gradient(ellipse at center, ${centerColor} 0%, ${edgeColor} 100%)`;
            // --- Font switching by theme ---
            if (currentTheme === 'Forest Sage') {
                document.body.style.fontFamily = "'Roboto Slab', serif";
            } else {
                document.body.style.fontFamily = "'Helvetica Neue', Helvetica, Arial, sans-serif";
            }
        }

        function switchTheme(themeName) {
            currentTheme = themeName;
            dynastyPalettes = themeDefinitions[currentTheme].dynastyPalettes;
            applyTheme();
            
            // Update existing nodes with new colors while preserving dynasty assignments
            updateAllNodeColors();
            updateGraph();
        }

        function updateAllNodeColors() {
            nodes.forEach(node => {
                if (node.depth === 0) {
                    // Central node remains white
                    node.color = "#FFFFFF";
                } else if (node.depth === 1) {
                    // First generation nodes keep their dynasty assignment but get new colors
                    const paletteIdx = firstGenPaletteAssignment.get(node.id);
                    if (paletteIdx !== undefined && dynastyPalettes[paletteIdx]) {
                        node.color = ensureTextVisible(dynastyPalettes[paletteIdx][0]);
                    }
                } else {
                    // Deeper generations: recalculate based on new dynasty colors with gradient evolution
                    let firstGenAncestor = node;
                    let currentNode = node;
                    
                    // Find the first generation ancestor
                    while (firstGenAncestor.depth > 1) {
                        const parentLink = links.find(l => l.target.id === firstGenAncestor.id);
                        firstGenAncestor = parentLink ? parentLink.source : null;
                        if (!firstGenAncestor) break;
                    }
                    
                    if (firstGenAncestor) {
                        const dynastyPaletteIdx = firstGenPaletteAssignment.get(firstGenAncestor.id);
                        if (dynastyPaletteIdx !== undefined && dynastyPalettes[dynastyPaletteIdx]) {
                            const palette = dynastyPalettes[dynastyPaletteIdx];
                            
                            // Enhanced color evolution: transition through multiple colors as depth increases
                            const colorIndex = Math.min(currentNode.depth - 2, palette.length - 1);
                            const nextColorIndex = Math.min(currentNode.depth - 1, palette.length - 1);
                            
                            // For 3rd+ generation, create gradient blending between colors
                            if (currentNode.depth >= 3 && nextColorIndex < palette.length - 1) {
                                const baseColor = d3.color(palette[colorIndex]);
                                const nextColor = d3.color(palette[nextColorIndex]);
                                const blendFactor = (currentNode.depth - 3) * 0.25; // Gradual transition
                                
                                if (baseColor && nextColor) {
                                    const blendedColor = d3.interpolate(baseColor, nextColor)(Math.min(blendFactor, 1));
                                    currentNode.color = ensureTextVisible(blendedColor.toString());
                                } else {
                                    currentNode.color = ensureTextVisible(palette[colorIndex]);
                                }
                            } else {
                                currentNode.color = ensureTextVisible(palette[colorIndex]);
                            }
                        }
                    }
                }
            });
        }
        
        // Helper function to check if a color is too bright for white text
        function isColorTooBright(color) {
            const d3Color = d3.color(color);
            if (!d3Color) return false;
            // Standard luminance calculation
            const luminance = (0.299 * d3Color.r + 0.587 * d3Color.g + 0.114 * d3Color.b) / 255;
            return luminance > 0.5; // Lowered threshold for better contrast
        }

        function ensureTextVisible(color) {
            const d3Color = d3.color(color);
            if (!d3Color) return color;
            
            // Calculate contrast ratio with white text
            const luminance = (0.299 * d3Color.r + 0.587 * d3Color.g + 0.114 * d3Color.b) / 255;
            
            // If color is too bright (luminance > 0.5), darken it significantly
            if (luminance > 0.5) {
                // Darken until we get good contrast
                let darkened = d3Color.darker(2);
                let newLuminance = (0.299 * darkened.r + 0.587 * darkened.g + 0.114 * darkened.b) / 255;
                
                // Keep darkening if still too bright, but stop before getting too dark
                while (newLuminance > 0.4 && darkened.l > 0.2) { // Increased minimum lightness from 0.1 to 0.2
                    darkened = darkened.darker(0.5);
                    newLuminance = (0.299 * darkened.r + 0.587 * darkened.g + 0.114 * darkened.b) / 255;
                }
                
                return darkened.toString();
            }
            
            // If color is too dark (luminance < 0.15), brighten it slightly to prevent pure black
            if (luminance < 0.15) {
                let brightened = d3Color.brighter(0.5);
                let newLuminance = (0.299 * brightened.r + 0.587 * brightened.g + 0.114 * brightened.b) / 255;
                
                // Keep brightening until we reach minimum acceptable darkness
                while (newLuminance < 0.15 && brightened.l < 0.8) {
                    brightened = brightened.brighter(0.3);
                    newLuminance = (0.299 * brightened.r + 0.587 * brightened.g + 0.114 * brightened.b) / 255;
                }
                
                return brightened.toString();
            }
            
            // If color is already in acceptable range, return as is
            return color;
        }

        // --- User Instructions & LLM Assistant System ---
        function updateUserInstruction(text) {
            currentInstruction.textContent = text;
        }

        function addAssistantMessage(text, suggestions = []) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'assistant-message';
            
            messageDiv.innerHTML = `
                <div class="assistant-content">
                    <div class="assistant-name">CogniFlow Assistant</div>
                    <div class="assistant-text">${text}</div>
                    ${suggestions.length > 0 ? `
                        <div class="assistant-suggestions">
                            ${suggestions.map(suggestion => 
                                `<div class="suggestion-chip" onclick="handleSuggestionClick('${suggestion}')">${suggestion}</div>`
                            ).join('')}
                        </div>
                    ` : ''}
                </div>
            `;
            
            assistantMessages.appendChild(messageDiv);
            assistantMessages.scrollTop = assistantMessages.scrollHeight;
        }

        // Make handleSuggestionClick available globally for onclick handlers
        window.handleSuggestionClick = function(suggestion) {
            // Don't interrupt if user is typing
            if (document.activeElement === nodeInput && nodeInput.value.trim() !== '') return;
            
            if (selectedNode) {
                const newNode = addNode(suggestion, selectedNode);
                if (newNode) {
                    handleNodeClick(null, newNode);
                    // Don't immediately trigger more suggestions
                }
            } else if (nodes.length === 0) {
                const newNode = addNode(suggestion, null);
                if (newNode) {
                    handleNodeClick(null, newNode);
                }
            }
        };

        async function generateContextualSuggestions() {
            if (nodes.length === 0) return;
            
            // Don't interrupt if user is typing
            if (document.activeElement === nodeInput && nodeInput.value.trim() !== '') return;
            
            // Create context from the current mind map structure
            const context = buildMindMapContext();
            
            const prompt = `Based on mind map: ${context}
Suggest 3-5 concise nodes (2-3 words each) as JSON array.`;
            
            // Run async without blocking
            callDeepSeekAPI(prompt, 200).then(response => {
                if (response) {
                    try {
                        const suggestions = JSON.parse(response);
                        if (Array.isArray(suggestions)) {
                            addAssistantMessage("Suggested ideas:", suggestions.slice(0, 5));
                        }
                    } catch (e) {
                        // Silent fail - don't interrupt user
                    }
                }
            }).catch(e => {
                // Silent fail
            });
        }

        function buildMindMapContext() {
            if (nodes.length === 0) return "Empty mind map";
            
            const centralNode = nodes.find(n => n.depth === 0);
            if (!centralNode) return "No central node";
            
            let context = `Central idea: "${centralNode.name}"`;
            
            // Add first generation nodes
            const firstGenNodes = nodes.filter(n => n.depth === 1);
            if (firstGenNodes.length > 0) {
                context += `\nMain branches: ${firstGenNodes.map(n => `"${n.name}"`).join(', ')}`;
            }
            
            // Add deeper nodes with their hierarchy
            const deeperNodes = nodes.filter(n => n.depth > 1);
            if (deeperNodes.length > 0) {
                context += `\nSub-topics: ${deeperNodes.map(n => `"${n.name}"`).join(', ')}`;
            }
            
            return context;
        }

        // Keep the original function but add async AI version
        function generateGhostSuggestions(node) {
            // Generate contextual suggestions based on the node's content and context
            const suggestions = [];
            
            // Get existing children to avoid duplicates
            const existingChildren = nodes.filter(n => {
                const parentLink = links.find(l => l.target.id === n.id);
                return parentLink && parentLink.source.id === node.id;
            }).map(n => n.name.toLowerCase());
            
            // Base suggestions based on node name and common patterns
            const nodeName = node.name.toLowerCase();
            
            // Context-aware suggestions
            if (nodeName.includes('business') || nodeName.includes('company')) {
                suggestions.push('Strategy', 'Marketing', 'Finance', 'Operations', 'Team');
            } else if (nodeName.includes('project') || nodeName.includes('plan')) {
                suggestions.push('Timeline', 'Resources', 'Goals', 'Risks', 'Tasks');
            } else if (nodeName.includes('research') || nodeName.includes('study')) {
                suggestions.push('Methods', 'Data', 'Analysis', 'Results', 'Sources');
            } else if (nodeName.includes('design') || nodeName.includes('create')) {
                suggestions.push('Concept', 'Prototype', 'Testing', 'Feedback', 'Iteration');
            } else if (nodeName.includes('problem') || nodeName.includes('issue')) {
                suggestions.push('Causes', 'Solutions', 'Impact', 'Prevention', 'Action');
            } else if (nodeName.includes('learning') || nodeName.includes('education')) {
                suggestions.push('Concepts', 'Practice', 'Examples', 'Resources', 'Assessment');
            } else {
                // Generic suggestions that work for most contexts
                const genericSuggestions = [
                    'Details', 'Examples', 'Benefits', 'Challenges', 'Steps',
                    'Features', 'Components', 'Process', 'Requirements', 'Options',
                    'Analysis', 'Comparison', 'Timeline', 'Resources', 'Impact',
                    'Methods', 'Tools', 'Goals', 'Outcomes', 'Next Steps'
                ];
                
                // Randomly select from generic suggestions
                const shuffled = genericSuggestions.sort(() => 0.5 - Math.random());
                suggestions.push(...shuffled.slice(0, 5));
            }
            
            // Filter out existing children and limit to 3-4 suggestions
            const filteredSuggestions = suggestions
                .filter(s => !existingChildren.includes(s.toLowerCase()))
                .slice(0, Math.min(4, Math.max(3, suggestions.length)));
            
            // If we don't have enough unique suggestions, add some generic ones
            if (filteredSuggestions.length < 3) {
                const fallbackSuggestions = ['Ideas', 'Notes', 'Related', 'More'];
                fallbackSuggestions.forEach(s => {
                    if (filteredSuggestions.length < 3 && !existingChildren.includes(s.toLowerCase())) {
                        filteredSuggestions.push(s);
                    }
                });
            }
            
            return filteredSuggestions;
        }

        // AI-powered ghost suggestions for expanded nodes
        async function generateAIGhostSuggestions(node) {
            // Get parent context for better suggestions
            const parentLink = links.find(l => l.target.id === node.id);
            const parent = parentLink ? parentLink.source : null;
            
            const context = {
                node: node.name,
                parent: parent ? parent.name : null,
                siblings: parent ? nodes.filter(n => {
                    const pLink = links.find(l => l.target.id === n.id);
                    return pLink && pLink.source.id === parent.id && n.id !== node.id;
                }).map(n => n.name) : [],
                existing: nodes.filter(n => {
                    const pLink = links.find(l => l.target.id === n.id);
                    return pLink && pLink.source.id === node.id;
                }).map(n => n.name)
            };

            const prompt = `Suggest 4 child nodes for "${node.name}" (2-3 words max). Return JSON array only.`;

            const response = await callDeepSeekAPIWithRateLimit(prompt, 100, 'low'); // Shorter limit for JSON array
            if (response) {
                try {
                    const suggestions = JSON.parse(response);
                    if (Array.isArray(suggestions)) {
                        return suggestions.slice(0, 4).map(s => s.substring(0, 20)); // Ensure short suggestions
                    }
                } catch (e) {
                    // Fallback to static suggestions
                    return generateGhostSuggestions(node);
                }
            }
            
            return generateGhostSuggestions(node);
        }

        // Advanced text wrapping function with dynamic width control (no truncation)
        function wrapTextPreview(textElement, textContent, maxWidth, lineHeight, startingDy = 0, fillColor = '#FFFFFF', fontWeight = '500', fontSize = null, opacity = 1, maxLines = 6) {
            if (!textContent || textContent.trim() === '') return;
            
            const words = textContent.split(/\s+/);
            let line = '';
            let lineCount = 0;
            let tspan = textElement.append('tspan')
                .attr('x', 0)
                .attr('dy', startingDy)
                .style('fill', fillColor)
                .style('font-weight', fontWeight)
                .style('opacity', opacity);
            
            if (fontSize) tspan.style('font-size', fontSize);
            
            for (let i = 0; i < words.length; i++) {
                const testLine = line + (line ? ' ' : '') + words[i];
                tspan.text(testLine);
                
                try {
                    if (tspan.node().getComputedTextLength() > maxWidth) {
                        if (line) {
                            // Current line is full, start a new line
                            lineCount++;
                            if (lineCount >= maxLines) {
                                // We've reached max lines, just continue on next line
                                tspan = textElement.append('tspan')
                                    .attr('x', 0)
                                    .attr('dy', lineHeight)
                                    .style('fill', fillColor)
                                    .style('font-weight', fontWeight)
                                    .style('opacity', opacity);
                                
                                if (fontSize) tspan.style('font-size', fontSize);
                                line = words[i];
                                tspan.text(line);
                            } else {
                                // Start new line
                                tspan = textElement.append('tspan')
                                    .attr('x', 0)
                                    .attr('dy', lineHeight)
                                    .style('fill', fillColor)
                                    .style('font-weight', fontWeight)
                                    .style('opacity', opacity);
                                
                                if (fontSize) tspan.style('font-size', fontSize);
                                line = words[i];
                                tspan.text(line);
                            }
                        } else {
                            // Single word is too long, just display it
                            tspan.text(words[i]);
                            // Continue to next word on new line
                            if (i < words.length - 1) {
                                tspan = textElement.append('tspan')
                                    .attr('x', 0)
                                    .attr('dy', lineHeight)
                                    .style('fill', fillColor)
                                    .style('font-weight', fontWeight)
                                    .style('opacity', opacity);
                                if (fontSize) tspan.style('font-size', fontSize);
                                line = '';
                            }
                        }
                    } else {
                        line = testLine;
                    }
                } catch (e) {
                    // Fallback if getComputedTextLength fails
                    if (line.length > 25) { // Increased threshold
                        lineCount++;
                        tspan = textElement.append('tspan')
                            .attr('x', 0)
                            .attr('dy', lineHeight)
                            .style('fill', fillColor)
                            .style('font-weight', fontWeight)
                            .style('opacity', opacity);
                        if (fontSize) tspan.style('font-size', fontSize);
                        line = words[i];
                        tspan.text(line);
                    } else {
                        line = testLine;
                    }
                }
            }
        }

        function wrapText(textElement, textContent, maxWidth, lineHeight, startingDy = 0, fillColor = '#FFFFFF', fontWeight = '500', fontSize = null, opacity = 1) {
            if (!textContent || textContent.trim() === '') return;
            
            const words = textContent.split(/\s+/);
            let line = [];
            let lineNumber = 0;
            const maxLines = 4; // Increased max lines to prevent truncation
            
            // Create first tspan
            let tspan = textElement.append('tspan')
                .attr('x', 0)
                .attr('dy', startingDy)
                .style('fill', fillColor)
                .style('font-weight', fontWeight)
                .style('opacity', opacity);
            
            if (fontSize) {
                tspan.style('font-size', fontSize);
            }
            
            // Process each word
            words.forEach((word, i) => {
                line.push(word);
                const testText = line.join(' ');
                tspan.text(testText);
                
                try {
                    // Check if line exceeds maximum width
                    if (tspan.node().getComputedTextLength() > maxWidth && line.length > 1) {
                        // Remove the last word that caused overflow
                        line.pop();
                        tspan.text(line.join(' '));
                        
                        // Start new line with the overflow word (removed max line check)
                        line = [word];
                        lineNumber++;
                        tspan = textElement.append('tspan')
                            .attr('x', 0)
                            .attr('dy', lineHeight)
                            .style('fill', fillColor)
                            .style('font-weight', fontWeight)
                            .style('opacity', opacity)
                            .text(word);
                        
                        if (fontSize) {
                            tspan.style('font-size', fontSize);
                        }
                    }
                } catch (e) {
                    // Fallback if getComputedTextLength fails
                    if (line.join(' ').length > 25) { // Increased threshold
                        lineNumber++;
                        tspan = textElement.append('tspan')
                            .attr('x', 0)
                            .attr('dy', lineHeight)
                            .style('fill', fillColor)
                            .style('font-weight', fontWeight)
                            .style('opacity', opacity);
                        if (fontSize) tspan.style('font-size', fontSize);
                        line = [word];
                        tspan.text(line.join(' '));
                    }
                }
            });
        }

        // Optimized font sizing based on zoom level and hierarchy for content viewing
        function updateDynamicFontSizes(specificNode = null) {
            const currentScale = d3.zoomTransform(svg.node()).k;

            nodeGroup.selectAll('.node').each(function(d) {
                if (specificNode && d.id !== specificNode.id) return;

                const text = d3.select(this).select('text');
                if (d.isExpanded || d.isListNode || d.isMediaNode) {
                    text.style('font-size', '0pt');
                    return;
                }

                // Optimized font sizing for better readability
                let baseSize;
                if (d.depth === 0) {
                    baseSize = 16; // Central node
                } else if (d.depth === 1) {
                    baseSize = 14; // First generation
                } else if (d.depth === 2) {
                    baseSize = 12; // Second generation
                } else {
                    baseSize = 10; // Third generation and beyond
                }

                // Zoom-responsive scaling - more conservative for better readability
                const zoomMultiplier = Math.max(0.6, Math.min(2.0, 1 / Math.sqrt(currentScale * 0.8)));
                const finalSize = Math.max(8, baseSize * zoomMultiplier);
                
                text.style('font-size', `${finalSize}pt`);

                // Improved opacity handling for better content visibility
                const opacity = currentScale < 0.15 && d.depth > 4 ? Math.max(0.3, (currentScale - 0.05) * 10) : 1;
                text.style('opacity', opacity);
            });
        }
        
        function forceLinkRepel() {
            const repulsionStrength = 1.2; // Increased strength for better separation
            const repulsionDistance = 45;  // Increased radius for wider clearance
            const textRepulsionStrength = 0.8; // Special strength for text elements
            const linkRepulsionStrength = 0.6; // Strength for link-to-link repulsion

            return function(alpha) {
                // Node-to-link repulsion
                for (const node of nodes) {
                    // Skip first generation nodes - they're far enough from center that link repulsion isn't needed
                    // and can cause unwanted snapping behavior
                    if (node.depth === 1) continue;
                    
                    for (const link of links) {
                        // Skip if the node is one of the link's endpoints
                        if (link.source === node || link.target === node) continue;

                        const x1 = link.source.x;
                        const y1 = link.source.y;
                        const x2 = link.target.x;
                        const y2 = link.target.y;
                        const x0 = node.x;
                        const y0 = node.y;

                        // Find the closest point on the link segment to the node
                        const l2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
                        if (l2 === 0) continue; // Skip if link has zero length

                        let t = ((x0 - x1) * (x2 - x1) + (y0 - y1) * (y2 - y1)) / l2;
                        t = Math.max(0, Math.min(1, t)); // Clamp t to the [0, 1] range

                        const closestX = x1 + t * (x2 - x1);
                        const closestY = y1 + t * (y2 - y1);

                        const dx = x0 - closestX;
                        const dy = y0 - closestY;
                        const d = Math.sqrt(dx * dx + dy * dy);

                        // If the node is within the repulsion distance, apply a force
                        if (d < repulsionDistance && d > 0) {
                            const force = repulsionStrength * (1 - d / repulsionDistance) * alpha;
                            const forceX = (dx / d) * force;
                            const forceY = (dy / d) * force;

                            // Apply repulsion force to the node
                            node.vx += forceX;
                            node.vy += forceY;
                            
                            // Apply a counter-force to the link's endpoints to maintain stability
                            const tInv = 1 - t;
                            link.source.vx -= forceX * tInv * 0.3;
                            link.source.vy -= forceY * tInv * 0.3;
                            link.target.vx -= forceX * t * 0.3;
                            link.target.vy -= forceY * t * 0.3;
                        }
                    }
                }

                // Link-to-link repulsion (prevent links from crossing too closely)
                for (let i = 0; i < links.length; i++) {
                    for (let j = i + 1; j < links.length; j++) {
                        const link1 = links[i];
                        const link2 = links[j];
                        
                        // Skip if links share a common node
                        if (link1.source === link2.source || link1.source === link2.target || 
                            link1.target === link2.source || link1.target === link2.target) continue;

                        // Calculate midpoints of both links
                        const mid1X = (link1.source.x + link1.target.x) / 2;
                        const mid1Y = (link1.source.y + link1.target.y) / 2;
                        const mid2X = (link2.source.x + link2.target.x) / 2;
                        const mid2Y = (link2.source.y + link2.target.y) / 2;

                        const dx = mid1X - mid2X;
                        const dy = mid1Y - mid2Y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        // Apply repulsion if links are too close
                        if (distance < 30 && distance > 0) {
                            const force = linkRepulsionStrength * (1 - distance / 30) * alpha;
                            const forceX = (dx / distance) * force;
                            const forceY = (dy / distance) * force;

                            // Push link endpoints away from each other
                            link1.source.vx += forceX * 0.25;
                            link1.source.vy += forceY * 0.25;
                            link1.target.vx += forceX * 0.25;
                            link1.target.vy += forceY * 0.25;
                            
                            link2.source.vx -= forceX * 0.25;
                            link2.source.vy -= forceY * 0.25;
                            link2.target.vx -= forceX * 0.25;
                            link2.target.vy -= forceY * 0.25;
                        }
                    }
                }

                // Text-to-link repulsion (push text away from crossing links)
                nodes.forEach(node => {
                    // Only apply to nodes that have visible text (not expanded/media/list nodes)
                    if (node.isExpanded || node.isListNode || node.isMediaNode) return;
                    
                    // Skip first generation nodes - they're positioned far from center and don't need text repulsion
                    if (node.depth === 1) return;

                    // Calculate text position based on node type
                    const textX = node.x;
                    let textY, textRadius;
                    
                    if (node.depth === 0) {
                        // Central node: text is below the circle
                        textY = node.y + 60;
                        textRadius = 45; // Larger radius for central node text
                    } else if (node.depth === 1) {
                        // First generation: text is centered inside the circle
                        textY = node.y;
                        textRadius = 60; // Much larger radius since text is inside and wider
                    } else {
                        // Other generations: text is below the circle
                        textY = node.y + node.radius + 12;
                        textRadius = 25; // Standard radius for text below
                    }

                    links.forEach(link => {
                        // Skip links connected to this node
                        if (link.source === node || link.target === node) return;

                        const x1 = link.source.x;
                        const y1 = link.source.y;
                        const x2 = link.target.x;
                        const y2 = link.target.y;

                        // Find closest point on link to text position
                        const l2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
                        if (l2 === 0) return;

                        let t = ((textX - x1) * (x2 - x1) + (textY - y1) * (y2 - y1)) / l2;
                        t = Math.max(0, Math.min(1, t));

                        const closestX = x1 + t * (x2 - x1);
                        const closestY = y1 + t * (y2 - y1);

                        const dx = textX - closestX;
                        const dy = textY - closestY;
                        const d = Math.sqrt(dx * dx + dy * dy);

                        // Apply repulsion if link is too close to text
                        if (d < textRadius && d > 0) {
                            const force = textRepulsionStrength * (1 - d / textRadius) * alpha;
                            const forceX = (dx / d) * force;
                            const forceY = (dy / d) * force;

                            // Push the node (and thus its text) away from the link
                            node.vx += forceX;
                            node.vy += forceY;

                            // Small counter-force on link endpoints
                            const tInv = 1 - t;
                            link.source.vx -= forceX * tInv * 0.1;
                            link.source.vy -= forceY * tInv * 0.1;
                            link.target.vx -= forceX * t * 0.1;
                            link.target.vy -= forceY * t * 0.1;
                        }
                    });
                });
            };
        }

        // Viewport boundary force to keep nodes within visible area
        function forceViewportBounds() {
            return function(alpha) {
                const transform = d3.zoomTransform(svg.node());
                const margin = 50; // Margin from viewport edges
                
                nodes.forEach(node => {
                    // Skip first generation nodes that are pinned - let user position them freely
                    if (node.depth === 1 && (node.fx !== null || node.fy !== null)) return;
                    // Convert node position to screen coordinates
                    const screenX = (node.x * transform.k) + transform.x;
                    const screenY = (node.y * transform.k) + transform.y;
                    
                    // Get node radius in screen space
                    const nodeRadius = (node.radius || 20) * transform.k;
                    
                    // Check boundaries and apply corrective forces
                    if (screenX - nodeRadius < margin) {
                        node.vx += (margin - (screenX - nodeRadius)) * alpha * 0.1;
                    }
                    if (screenX + nodeRadius > container.clientWidth - margin) {
                        node.vx -= ((screenX + nodeRadius) - (container.clientWidth - margin)) * alpha * 0.1;
                    }
                    if (screenY - nodeRadius < margin) {
                        node.vy += (margin - (screenY - nodeRadius)) * alpha * 0.1;
                    }
                    if (screenY + nodeRadius > container.clientHeight - margin) {
                        node.vy -= ((screenY + nodeRadius) - (container.clientHeight - margin)) * alpha * 0.1;
                    }
                });
            };
        }

        // Custom force to prevent text overlap with other text and connectors
        function forceTextRepel() {
            let strength = 0.3;
            let textNodes = [];
            
            function force(alpha) {
                const textRepelDistance = 25; // Minimum distance between text elements
                const linkRepelDistance = 15; // Minimum distance from links
                
                // Get current text positions
                textNodes = [];
                nodeGroup.selectAll('.node').each(function(d) {
                    if (!d.isExpanded && !d.isListNode && !d.isMediaNode) {
                        const textElement = d3.select(this).select('text');
                        const transform = textElement.attr('transform');
                        
                        // Parse transform to get actual position
                        let textX = d.x;
                        let textY = d.y;
                        
                        if (transform) {
                            const translateMatch = transform.match(/translate\(([^,]+),([^)]+)\)/);
                            if (translateMatch) {
                                textX = d.x + parseFloat(translateMatch[1]);
                                textY = d.y + parseFloat(translateMatch[2]);
                            }
                        }
                        
                        textNodes.push({
                            node: d,
                            x: textX,
                            y: textY,
                            textElement: textElement
                        });
                    }
                });
                
                // Apply repelling forces between text elements
                for (let i = 0; i < textNodes.length; i++) {
                    for (let j = i + 1; j < textNodes.length; j++) {
                        const a = textNodes[i];
                        const b = textNodes[j];
                        
                        const dx = b.x - a.x;
                        const dy = b.y - a.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < textRepelDistance && distance > 0) {
                            const force = (textRepelDistance - distance) / distance * strength * alpha;
                            const fx = dx * force;
                            const fy = dy * force;
                            
                            // Apply force to the nodes (which will move the text)
                            a.node.vx -= fx;
                            a.node.vy -= fy;
                            b.node.vx += fx;
                            b.node.vy += fy;
                        }
                    }
                    
                    // Apply repelling forces from link paths
                    const textNode = textNodes[i];
                    links.forEach(link => {
                        // Skip if this text belongs to nodes connected by this link
                        if (link.source.id === textNode.node.id || link.target.id === textNode.node.id) return;
                        
                        // Calculate closest point on link to text
                        const linkStart = { x: link.source.x, y: link.source.y };
                        const linkEnd = { x: link.target.x, y: link.target.y };
                        
                        // Simple distance check to link line segment
                        const closestPoint = getClosestPointOnLine(
                            linkStart, linkEnd, 
                            { x: textNode.x, y: textNode.y }
                        );
                        
                        const dx = textNode.x - closestPoint.x;
                        const dy = textNode.y - closestPoint.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < linkRepelDistance && distance > 0) {
                            const force = (linkRepelDistance - distance) / distance * strength * alpha * 0.5;
                            const fx = dx * force;
                            const fy = dy * force;
                            
                            textNode.node.vx += fx;
                            textNode.node.vy += fy;
                        }
                    });
                }
            }
            
            force.strength = function(_) {
                return arguments.length ? (strength = _, force) : strength;
            };
            
            return force;
        }
        
        // Helper function to find closest point on a line segment
        function getClosestPointOnLine(lineStart, lineEnd, point) {
            const A = point.x - lineStart.x;
            const B = point.y - lineStart.y;
            const C = lineEnd.x - lineStart.x;
            const D = lineEnd.y - lineStart.y;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            
            if (lenSq === 0) return lineStart; // Line is a point
            
            let param = dot / lenSq;
            
            // Clamp to line segment
            if (param < 0) param = 0;
            if (param > 1) param = 1;
            
            return {
                x: lineStart.x + param * C,
                y: lineStart.y + param * D
            };
        }

        const simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).id(d => d.id).distance(d => d.targetDistance).strength(0.08)) // Reduced from 0.1
            .force("charge", d3.forceManyBody().strength(d => {
                if (d.depth === 0) return -800; // Strong repulsion for central node
                if (d.depth === 1) return -500; // Stronger repulsion for first generation to prevent overlap
                return -300; // Normal repulsion for other nodes
            }))
            .force("y", d3.forceY(container.clientHeight / 2).strength(0.03)) // Reduced from 0.04
            .force("collide", d3.forceCollide().radius(d => {
                // First generation nodes need much larger collision radius due to text inside
                if (d.depth === 1) {
                    return 65; // Large radius to account for text inside the node
                } else if (d.depth === 0) {
                    return d.radius + 45; // Central node with text below
                } else {
                    return d.radius + 20; // Other nodes with text below
                }
            }).strength(0.8)) // Increased strength for better separation
            .force("linkRepel", forceLinkRepel()) // The new custom force
            .force("textRepel", forceTextRepel()) // Text repelling force to prevent overlap
            .force("bounds", forceViewportBounds()) // Keep nodes within viewport
            .velocityDecay(0.7) // Increased from 0.6 for gentler movement
            .alphaDecay(0.04) // Reduced from 0.05 for slower cooldown
            .alphaMin(0.001); // Lower minimum for better responsiveness

        const masterGroup = svg.append("g");
        let linkGroup = masterGroup.append("g").attr("class", "link-layer");
        let nodeGroup = masterGroup.append("g");
        
        const zoom = d3.zoom().scaleExtent([0.1, 4]).on("zoom", (event) => {
            masterGroup.attr("transform", event.transform);
            updateDynamicFontSizes(); // Update font sizes on zoom
        });
        svg.call(zoom);

        d3.select(container).on('click', handleBackgroundClick);

        // --- Core Functions ---
        function updateGraph() {
            // --- LINKS ---
            linkGroup.selectAll(".link")
                .data(links, d => `${d.source.id}-${d.target.id}`)
                .join("path")
                .attr("class", "link")
                .attr("stroke", d => d.source.color)
                .style("stroke-opacity", 0.5);

            // --- NODES (The General Update Pattern) ---
            const node = nodeGroup.selectAll(".node")
                .data(nodes, d => d.id);

            // Exit
            node.exit().transition().duration(800).attr("transform", "scale(0)").remove();

            // Enter
            const nodeEnter = node.enter().append("g")
                .attr("class", "node")
                .attr("transform", d => `translate(${d.x},${d.y})`)
                .on("dblclick", handleNodeDoubleClick)
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            nodeEnter.append("circle");
            
            nodeEnter.append("text");

            nodeEnter.append('foreignObject')
                .style('opacity', 0)
                .style('pointer-events', 'none');

            // Update
            const nodeUpdate = nodeEnter.merge(node)
                .classed('selected', d => d.id === selectedNode?.id);

            nodeUpdate.each(function(d) {
                const el = d3.select(this);
                const circle = el.select('circle');
                const text = el.select('text');
                const fo = el.select('foreignObject');

                // Remove the hamburger icon indicator completely

                // Calculate dimensions based on state - larger to accommodate ghost nodes
                const foWidth = Math.min(320, container.clientWidth * 0.32); // Larger width for ghost nodes
                // Height calculation with more space for ghost nodes
                const baseHeight = 40; // Header height
                const notesHeight = 120; // Fixed notes area height
                const ghostNodeHeight = 90; // Space for ghost nodes
                const padding = 24; // Top and bottom padding
                const foHeight = Math.min(230, baseHeight + notesHeight + ghostNodeHeight + padding); // Larger height
                
                // Logic for Expanded View
                if (d.isExpanded) {
                    el.raise();
                    
                    // Smoothly morph the circle to a rounded rectangle
                    circle.transition()
                        .duration(600)
                        .ease(d3.easeCubicInOut)
                        .attr('r', 0);
                    
                    // Scale out text
                    text.transition()
                        .duration(300)
                        .attr('transform', 'scale(0)');
                    
                    // Expanded node sizing: auto height, max 70vh, min 180px, width matches list node
                    const foWidth = Math.max(260, Math.min(420, container.clientWidth * 0.35));
                    const minHeight = 180;
                    const maxHeight = Math.max(320, window.innerHeight * 0.7);
                    // We'll let the content determine the height, but cap it at maxHeight
                    fo.transition()
                        .duration(600)
                        .ease(d3.easeCubicInOut)
                        .attr('x', -foWidth / 2)
                        .attr('y', 0)
                        .attr('width', foWidth)
                        .attr('height', maxHeight)
                        .style('opacity', 1)
                        .on('end', () => {
                            fo.style('pointer-events', 'all')
                              .on('click', event => event.stopPropagation());
                        });
                    if (fo.select('.expanded-node-container').empty()) {
                        fo.html(''); // Clear previous content before rebuilding
                        const baseColor = d.color === '#FFFFFF' ? '#EAEAEA' : d.color;
                        const bgColor = d3.color(baseColor);
                        bgColor.opacity = 0.93;
                        const textColor = isColorTooBright(baseColor) ? '#000000' : '#FFFFFF';
                        const h2Color = isColorTooBright(baseColor) ? d3.color(baseColor).darker(1.5) : d3.color(baseColor).brighter(1.5);
                        // Match list node design
                        const borderRadius = '10px';
                        const padding = '12px 10px';
                        const fontSize = '11pt';
                        const notesFontSize = '10pt';
                        const notesLineHeight = '1.3';
                        const notesMinHeight = '60px';
                        const notesMaxHeight = 'none';
                        const notesPadding = '8px';
                        const notesBorderRadius = '8px';
                        const notesBg = 'rgba(255,255,255,0.10)';
                        const div = fo.append('xhtml:div')
                            .attr('class', 'expanded-node-container')
                            .style('width', '100%')
                            .style('min-height', minHeight + 'px')
                            .style('max-height', maxHeight + 'px')
                            .style('background-color', bgColor.toString())
                            .style('color', textColor)
                            .style('opacity', 0)
                            .style('border-radius', borderRadius)
                            .style('padding', padding)
                            .style('box-sizing', 'border-box')
                            .style('display', 'flex')
                            .style('flex-direction', 'column')
                            .style('gap', '8px')
                            .style('backdrop-filter', 'blur(4px)')
                            .style('font-size', fontSize)
                            .style('overflow', 'visible');
                        // Fade in the content after a delay
                        div.transition()
                            .delay(300)
                            .duration(300)
                            .style('opacity', 1);
                        // Header (title)
                        div.append('xhtml:h3')
                            .style('font-weight', '600')
                            .style('color', h2Color.toString())
                            .style('font-size', fontSize)
                            .style('margin', '0')
                            .style('padding', '0')
                            .style('text-align', 'center')
                            .style('flex-shrink', '0')
                            .attr('contenteditable', true)
                            .text(d.name)
                            .on('mousedown', event => event.stopPropagation())
                            .on('click', event => event.stopPropagation())
                            .on('keydown', function(event) { 
                                if (event.key === 'Enter') { 
                                    event.preventDefault(); 
                                    this.blur(); 
                                } 
                                event.stopPropagation(); 
                            })
                            .on('blur', function() { 
                                d.name = this.innerText; 
                                updateGraph(); 
                            });
                        // Notes text area - placed at the top, no scroll, let modal grow
                        const notesArea = div.append('xhtml:div')
                            .attr('class', 'notes-editor')
                            .style('min-height', notesMinHeight)
                            .style('max-height', notesMaxHeight)
                            .style('background-color', notesBg)
                            .style('border-radius', notesBorderRadius)
                            .style('padding', notesPadding)
                            .style('color', textColor)
                            .style('font-size', notesFontSize)
                            .style('line-height', notesLineHeight)
                            .style('overflow', 'visible')
                            .style('resize', 'none')
                            .style('margin-bottom', '8px')
                            .attr('contenteditable', true)
                            .text(d.notes || '')
                            .on('mousedown', event => event.stopPropagation())
                            .on('click', event => event.stopPropagation())
                            .on('keydown', event => event.stopPropagation())
                            .on('blur', function() { 
                                d.notes = this.innerText.trim(); 
                                updateGraph(); 
                            });
                        // Add placeholder text when empty
                        if (!d.notes) {
                            notesArea.style('color', 'rgba(255,255,255,0.5)')
                                .text('Click to add notes...')
                                .on('focus', function() {
                                    if (this.innerText === 'Click to add notes...') {
                                        this.innerText = '';
                                        d3.select(this).style('color', textColor);
                                    }
                                })
                                .on('click', event => event.stopPropagation());
                        }
                        // Bottom content area - horizontal layout for buttons and ghost nodes
                        const bottomArea = div.append('xhtml:div')
                            .style('display', 'flex')
                            .style('flex-direction', 'row')
                            .style('gap', '8px')
                            .style('flex-grow', '1')
                            .style('min-height', '80px')
                            .style('align-items', 'flex-start');
                        // Left side - Action buttons
                        const actionsContainer = bottomArea.append('xhtml:div')
                            .attr('class', 'ai-actions-container')
                            .style('display', 'flex')
                            .style('flex-direction', 'column')
                            .style('gap', '3px')
                            .style('flex-shrink', '0')
                            .style('width', '80px')
                            .style('align-items', 'stretch');
                        // Calculate lighter button color based on node color
                        const buttonColor = d3.color(baseColor).brighter(0.5).toString();
                        const buttonTextColor = isColorTooBright(buttonColor) ? '#000000' : '#FFFFFF';
                        const actions = ['Define', 'Expand On', 'Solutions'];
                        actions.forEach(action => {
                            actionsContainer.append('xhtml:button')
                                .attr('class', 'ai-action-btn')
                                .style('background-color', buttonColor)
                                .style('color', buttonTextColor)
                                .style('padding', '5px 8px')
                                .style('border-radius', '4px')
                                .style('border', 'none')
                                .style('cursor', 'pointer')
                                .style('font-size', '8pt')
                                .style('font-weight', '500')
                                .style('transition', 'opacity 0.2s ease')
                                .text(action)
                                .on('mouseover', function() {
                                    d3.select(this).style('opacity', '0.8');
                                })
                                .on('mouseout', function() {
                                    d3.select(this).style('opacity', '1');
                                })
                                .on('click', async function(event) {
                                    event.stopPropagation();
                                    event.preventDefault();
                                    let prompt = '';
                                    if (action === 'Define') {
                                        prompt = `Define "${d.name}" clearly and concisely.`;
                                    } else if (action === 'Expand On') {
                                        prompt = `Elaborate on "${d.name}" with key details or examples.`;
                                    } else if (action === 'Solutions') {
                                        prompt = `Suggest practical solutions or approaches for "${d.name}".`;
                                    }
                                    const aiResponse = await callDeepSeekAPIWithRateLimit(prompt, 260, 'high');
                                    if (aiResponse) {
                                        const currentNotes = d.notes || '';
                                        const newContent = aiResponse;
                                        d.notes = currentNotes ? `${currentNotes}\n\n${newContent}` : newContent;
                                        if (notesArea && notesArea.node()) {
                                            notesArea.node().innerText = d.notes;
                                            notesArea.style('color', textColor);
                                        }
                                        if (d.notes && notesArea.text() !== 'Click to add notes...') {
                                            notesArea.style('color', textColor);
                                        }
                                    } else {
                                        const currentNotes = d.notes || '';
                                        const newContent = `${action}: Content generation unavailable. Please check your API key.`;
                                        d.notes = currentNotes ? `${currentNotes}\n\n${newContent}` : newContent;
                                        if (notesArea && notesArea.node()) {
                                            notesArea.node().innerText = d.notes;
                                            notesArea.style('color', textColor);
                                        }
                                    }
                                });
                        });
                        // Right side - Ghost node suggestions with breathing animation
                        const ghostContainer = bottomArea.append('xhtml:div')
                            .attr('class', 'ghost-suggestions-container')
                            .style('display', 'flex')
                            .style('flex-direction', 'row')
                            .style('gap', '6px')
                            .style('flex-grow', '1')
                            .style('justify-content', 'flex-start')
                            .style('align-items', 'center')
                            .style('flex-wrap', 'wrap')
                            .style('overflow', 'hidden')
                            .style('padding', '2px');
                        generateAIGhostSuggestions(d).then(ghostSuggestions => {
                            ghostContainer.selectAll('*').remove();
                            ghostSuggestions.forEach((suggestion, index) => {
                                const textLength = suggestion.length;
                                const minSize = 45;
                                const maxSize = 70;
                                const size = Math.min(maxSize, Math.max(minSize, textLength * 3 + 35));
                                const ghostWrapper = ghostContainer.append('xhtml:div')
                                    .style('position', 'relative')
                                    .style('width', `${size}px`)
                                    .style('height', `${size}px`)
                                    .style('flex-shrink', '0');
                                const ghostNode = ghostWrapper.append('xhtml:div')
                                    .attr('class', 'ghost-node')
                                    .style('width', '100%')
                                    .style('height', '100%')
                                    .style('border-radius', '50%')
                                    .style('background-color', 'rgba(255,255,255,0.85)')
                                    .style('border', '2px solid rgba(255,255,255,0.3)')
                                    .style('display', 'flex')
                                    .style('align-items', 'center')
                                    .style('justify-content', 'center')
                                    .style('cursor', 'pointer')
                                    .style('transition', 'all 0.3s ease')
                                    .style('font-size', textLength > 12 ? '6pt' : '7pt')
                                    .style('font-weight', '500')
                                    .style('color', '#333')
                                    .style('text-align', 'center')
                                    .style('padding', '4px')
                                    .style('box-sizing', 'border-box')
                                    .style('word-break', 'break-word')
                                    .style('overflow', 'hidden')
                                    .style('line-height', '1.1')
                                    .style('white-space', 'normal')
                                    .style('hyphens', 'auto')
                                    .style('animation', `breathe ${3 + index * 0.3}s ease-in-out infinite`)
                                    .style('animation-delay', `${index * 0.2}s`)
                                    .text(suggestion)
                                .on('mouseover', function() {
                                    d3.select(this)
                                        .style('background-color', 'rgba(255,255,255,1)')
                                        .style('border-color', 'rgba(255,255,255,0.8)')
                                        .style('transform', 'scale(1.1)')
                                        .style('animation-play-state', 'paused');
                                })
                                .on('mouseout', function() {
                                    d3.select(this)
                                        .style('background-color', 'rgba(255,255,255,0.85)')
                                        .style('border-color', 'rgba(255,255,255,0.3)')
                                        .style('transform', 'scale(1)')
                                        .style('animation-play-state', 'running');
                                })
                                .on('click', function(event) {
                                    event.stopPropagation();
                                    // Add the suggested node as a child
                                    const newNode = addNode(suggestion, d);
                                    if (newNode) {
                                        // Close the expanded view
                                        closeExpandedView(d);
                                        // Select the new node
                                        handleNodeClick(null, newNode);
                                    }
                                });
                            });
                        });
                    }
                } else if (d.isListNode) { // Logic for List Node View
                    // Compact sizing for list node
                    const itemHeight = 22;
                    const headerHeight = 28;
                    const topBottomPadding = 12; // Consistent top and bottom padding
                    const sidePadding = 10;
                    const minListItems = Math.max(3, d.listItems.length);
                    const listHeight = headerHeight + (minListItems * itemHeight) + (topBottomPadding * 2);
                    const maxItemTextLength = Math.max(d.name.length, ...d.listItems.map(item => item.text.length));
                    const listWidth = Math.max(220, Math.min(400, maxItemTextLength * 8 + 60));
                    d.radius = Math.hypot(listWidth, listHeight) / 2;
                    circle.attr('r', 0);
                    text.attr('transform', 'scale(0)');
                    
                    // Check if this is the first time rendering or if content has changed
                    const existingContainer = fo.select('.list-node-container');
                    const needsRebuild = existingContainer.empty() || d._lastListName !== d.name;
                    const needsItemUpdate = d._lastListItemCount !== d.listItems.length;
                    
                    if (needsRebuild) {
                        // Store current state for comparison
                        d._lastListItemCount = d.listItems.length;
                        d._lastListName = d.name;
                        
                    fo.transition()
                      .duration(400)
                      .ease(d3.easeCubicInOut)
                      .attr('x', -listWidth / 2)
                      .attr('y', -listHeight / 2)
                      .attr('width', listWidth)
                      .attr('height', listHeight)
                      .style('opacity', 1)
                      .on('end', () => {
                          fo.style('pointer-events', 'all')
                            .on('click', event => event.stopPropagation());
                          // Only render the list items after the expand animation completes
                              if (fo.select('.list-items-container').empty()) {
                          renderListNodeContent();
                              }
                      });
                    // Render only the container and header immediately
                    fo.html('');
                    const baseColor = d.color === '#FFFFFF' ? '#EAEAEA' : d.color;
                    const bgColor = d3.color(baseColor); bgColor.opacity = 0.9;
                    const textColor = isColorTooBright(baseColor) ? '#000000' : '#FFFFFF';
                    const headerColor = isColorTooBright(baseColor) ? d3.color(baseColor).darker(1.5) : d3.color(baseColor).brighter(1.5);
                    const div = fo.append('xhtml:div')
                        .attr('class', 'list-node-container')
                        .style('width', '100%')
                        .style('height', '100%')
                        .style('background-color', bgColor.toString())
                        .style('color', textColor)
                        .style('border-radius', '10px')
                            .style('padding', `${topBottomPadding}px ${sidePadding}px`)
                        .style('box-sizing', 'border-box')
                        .style('backdrop-filter', 'blur(4px)')
                        .style('display', 'flex')
                        .style('flex-direction', 'column')
                        .style('transition', 'background-color 0.3s ease');
                    // Header
                    div.append('xhtml:h3')
                            .style('margin', '0')
                        .style('font-size', '11pt')
                        .style('font-weight', '600')
                        .style('color', headerColor.toString())
                        .style('text-align', 'center')
                        .style('flex-shrink', '0')
                        .attr('contenteditable', true)
                        .text(d.name)
                        .on('mousedown', event => event.stopPropagation())
                        .on('keydown', function(event) { if (event.key === 'Enter') { event.preventDefault(); this.blur(); } event.stopPropagation(); })
                        .on('blur', function() { d.name = this.innerText; updateGraph(); });
                    // Function to render list items after animation
                    function renderListNodeContent() {
                        const listContainer = div.append('xhtml:div')
                            .attr('class', 'list-items-container')
                            .style('flex-grow', '1')
                            .style('display', 'flex')
                            .style('flex-direction', 'column')
                            .style('gap', '4px')
                                .style('margin-top', `${topBottomPadding}px`)
                            .style('transition', 'all 0.3s ease');
                        d.listItems.forEach((item, index) => {
                                addListItemElement(listContainer, item, index, d, textColor);
                            });
                        }
                    } else if (needsItemUpdate) {
                        // Only add new items without rebuilding existing ones
                        d._lastListItemCount = d.listItems.length;
                        
                        // Update container size
                        fo.transition()
                          .duration(400)
                          .ease(d3.easeCubicInOut)
                          .attr('x', -listWidth / 2)
                          .attr('y', -listHeight / 2)
                          .attr('width', listWidth)
                          .attr('height', listHeight);
                        
                        // Add only the new items
                        const listContainer = fo.select('.list-items-container');
                        const existingItems = listContainer.selectAll('[data-list-index]').size();
                        
                        // Add new items starting from the existing count
                        for (let i = existingItems; i < d.listItems.length; i++) {
                            const item = d.listItems[i];
                            addListItemElement(listContainer, item, i, d, isColorTooBright(d.color === '#FFFFFF' ? '#EAEAEA' : d.color) ? '#000000' : '#FFFFFF');
                        }
                    } else {
                        // Just update the size if content hasn't changed
                        fo.transition()
                          .duration(400)
                          .ease(d3.easeCubicInOut)
                          .attr('x', -listWidth / 2)
                          .attr('y', -listHeight / 2)
                          .attr('width', listWidth)
                          .attr('height', listHeight)
                          .style('opacity', 1);
                    }
                } else if (d.isMediaNode) { // Logic for Media Node View
                    // Better proportioned sizing to prevent clipping
                    const mediaWidth = 140;
                    const mediaHeight = 90;
                    d.radius = Math.hypot(mediaWidth, mediaHeight) / 2;
                    circle.attr('r', 0);
                    text.attr('transform', 'scale(0)');

                    fo.transition()
                      .duration(400)
                      .ease(d3.easeCubicInOut)
                      .attr('x', -mediaWidth / 2)
                      .attr('y', -mediaHeight / 2)
                      .attr('width', mediaWidth)
                      .attr('height', mediaHeight)
                      .style('opacity', 1)
                      .on('end', () => {
                          fo.style('pointer-events', 'all')
                            .on('click', event => event.stopPropagation());
                      });

                    // Render the container only once
                    if (fo.select('.media-node-container').empty()) {
                        fo.html('');
                        const baseColor = d.color === '#FFFFFF' ? '#EAEAEA' : d.color;
                        const bgColor = d3.color(baseColor); bgColor.opacity = 0.9;
                        const textColor = isColorTooBright(baseColor) ? '#000000' : '#FFFFFF';
                        const headerColor = isColorTooBright(baseColor) ? d3.color(baseColor).darker(1.5) : d3.color(baseColor).brighter(1.5);

                        const div = fo.append('xhtml:div')
                            .attr('class', 'media-node-container')
                            .style('width', '100%')
                            .style('height', '100%')
                            .style('background-color', bgColor.toString())
                                    .style('color', textColor)
                            .style('border-radius', '6px')
                            .style('padding', '8px')
                            .style('box-sizing', 'border-box')
                            .style('backdrop-filter', 'blur(4px)')
                            .style('display', 'flex')
                            .style('flex-direction', 'column')
                            .style('justify-content', 'space-between')
                            .style('align-items', 'center')
                            .style('text-align', 'center')
                            .style('overflow', 'hidden');

                        // Header (editable name) - better sizing and spacing
                        div.append('xhtml:h3')
                            .style('margin', '0')
                            .style('font-size', '8pt')
                            .style('font-weight', '600')
                            .style('color', headerColor.toString())
                            .style('text-align', 'center')
                                    .style('flex-shrink', '0')
                            .style('padding', '2px 4px')
                            .style('cursor', 'text')
                            .style('white-space', 'nowrap')
                            .style('overflow', 'hidden')
                            .style('text-overflow', 'ellipsis')
                            .style('max-width', '100%')
                            .attr('contenteditable', true)
                            .text(d.name)
                            .on('mousedown', event => event.stopPropagation())
                            .on('keydown', function(event) { if (event.key === 'Enter') { event.preventDefault(); this.blur(); } event.stopPropagation(); })
                            .on('blur', function() { d.name = this.innerText; });

                        // Media Preview Container - better proportioned
                        const previewContainer = div.append('xhtml:div')
                            .style('flex-grow', '1')
                            .style('display', 'flex')
                            .style('flex-direction', 'column')
                            .style('justify-content', 'center')
                            .style('align-items', 'center')
                            .style('overflow', 'hidden')
                            .style('border-radius', '4px')
                            .style('background', 'rgba(0,0,0,0.05)')
                            .style('padding', '6px')
                            .style('min-height', '0');

                        // Render based on media type with cleaner design
                        if (d.mediaType === 'image') {
                            // Show icon only for deeper generations (not first gen)
                            if (d.depth > 1) {
                                previewContainer.append('xhtml:div')
                                    .style('font-size', '16px')
                                    .style('margin-bottom', '3px')
                                    .text('üñºÔ∏è');
                            }
                            // Link
                            previewContainer.append('xhtml:a')
                                .attr('href', d.mediaSrc)
                                .attr('target', '_blank')
                                .style('font-size', '8pt')
                                    .style('color', textColor)
                                .style('text-decoration', 'underline')
                                .style('cursor', 'pointer')
                                .style('text-align', 'center')
                                .style('line-height', '1.2')
                                .style('word-wrap', 'break-word')
                                .style('hyphens', 'auto')
                                .text('View Image');
                        } else if (d.mediaType === 'youtube') {
                            // Always try to get videoId from metadata or src
                            let videoId = d.mediaMetadata && d.mediaMetadata.videoId;
                            if (!videoId && d.mediaSrc) {
                                const match = d.mediaSrc.match(/[?&]v=([\w-]{11})/) || d.mediaSrc.match(/youtu\.be\/([\w-]{11})/);
                                if (match) videoId = match[1];
                            }
                            // Fallback: try to extract from originalUrl if present
                            if (!videoId && d.mediaMetadata && d.mediaMetadata.originalUrl) {
                                const match = d.mediaMetadata.originalUrl.match(/[?&]v=([\w-]{11})/) || d.mediaMetadata.originalUrl.match(/youtu\.be\/([\w-]{11})/);
                                if (match) videoId = match[1];
                            }
                            if (videoId) {
                                // Embed the YouTube video
                                previewContainer.append('xhtml:div')
                                    .style('width', '100%')
                                    .style('display', 'flex')
                                    .style('flex-direction', 'column')
                                    .style('align-items', 'center')
                                    .html(`
                                        <iframe width='100' height='56' style='border-radius:6px; margin-bottom:4px; border:none; background:#000;' src='https://www.youtube.com/embed/${videoId}' allowfullscreen></iframe>
                                        <div style='color:${textColor}; font-size:8pt; font-weight:600; text-align:center; max-width:90px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;'>${d.mediaMetadata && d.mediaMetadata.title ? d.mediaMetadata.title : 'YouTube'}</div>
                                    `);
                            } else if (d.mediaMetadata && d.mediaMetadata.thumbnail_url) {
                                previewContainer.append('xhtml:a')
                                    .attr('href', d.mediaMetadata?.originalUrl || d.mediaSrc)
                                    .attr('target', '_blank')
                                    .style('display', 'flex')
                                    .style('flex-direction', 'column')
                                    .style('align-items', 'center')
                                    .style('text-decoration', 'none')
                                    .html(`
                                        <img src='${d.mediaMetadata.thumbnail_url}' style='width:80px; border-radius:6px; margin-bottom:4px;'>
                                        <div style='color:${textColor}; font-size:8pt; font-weight:600; text-align:center; max-width:90px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;'>${d.mediaMetadata.title || 'YouTube'}</div>
                                    `);
                            } else {
                                // Fallback: generic icon and label
                            if (d.depth > 1) {
                                previewContainer.append('xhtml:div')
                                    .style('font-size', '16px')
                                    .style('margin-bottom', '3px')
                                    .text('‚ñ∂Ô∏è');
                            }
                            previewContainer.append('xhtml:a')
                                .attr('href', d.mediaMetadata?.originalUrl || d.mediaSrc)
                                .attr('target', '_blank')
                                .style('font-size', '8pt')
                                .style('color', textColor)
                                .style('text-decoration', 'underline')
                                .style('cursor', 'pointer')
                                .style('text-align', 'center')
                                .style('line-height', '1.2')
                                .text('YouTube');
                            }
                        } else if (d.mediaType === 'vimeo') {
                            // Show icon only for deeper generations
                            if (d.depth > 1) {
                                previewContainer.append('xhtml:div')
                                    .style('font-size', '16px')
                                    .style('margin-bottom', '3px')
                                    .text('üé¨');
                            }
                            // Link
                            previewContainer.append('xhtml:a')
                                .attr('href', d.mediaMetadata?.originalUrl || d.mediaSrc)
                                .attr('target', '_blank')
                                .style('font-size', '8pt')
                                .style('color', textColor)
                                .style('text-decoration', 'underline')
                                .style('cursor', 'pointer')
                                .style('text-align', 'center')
                                .style('line-height', '1.2')
                                .text('Vimeo');
                        } else if (d.mediaType === 'twitter') {
                            // Show icon only for deeper generations
                            if (d.depth > 1) {
                                previewContainer.append('xhtml:div')
                                    .style('font-size', '16px')
                                    .style('margin-bottom', '3px')
                                    .text('ùïè');
                            }
                            // Link
                            previewContainer.append('xhtml:a')
                                .attr('href', d.mediaSrc)
                                .attr('target', '_blank')
                                .style('font-size', '8pt')
                                .style('color', textColor)
                                .style('text-decoration', 'underline')
                                .style('cursor', 'pointer')
                                .style('text-align', 'center')
                                .style('line-height', '1.2')
                                .text('x.com');
                        } else if (d.mediaType === 'github') {
                            const metadata = d.mediaMetadata || {};
                            // Show icon only for deeper generations
                            if (d.depth > 1) {
                                previewContainer.append('xhtml:div')
                                    .style('font-size', '16px')
                                    .style('margin-bottom', '3px')
                                    .text('‚ö°');
                            }
                            // Link
                            previewContainer.append('xhtml:a')
                                .attr('href', d.mediaSrc)
                                .attr('target', '_blank')
                                .style('font-size', '8pt')
                                .style('color', textColor)
                                .style('text-decoration', 'underline')
                                .style('cursor', 'pointer')
                                .style('text-align', 'center')
                                .style('line-height', '1.2')
                                .style('word-wrap', 'break-word')
                                .text(`${metadata.owner}/${metadata.repo}` || 'GitHub');
                        } else if (d.mediaType === 'pdf') {
                            // Show icon only for deeper generations
                            if (d.depth > 1) {
                                previewContainer.append('xhtml:div')
                                    .style('font-size', '16px')
                                    .style('margin-bottom', '3px')
                                    .text('üìÑ');
                            }
                            // Link
                            previewContainer.append('xhtml:a')
                                .attr('href', d.mediaSrc)
                                .attr('target', '_blank')
                                .style('font-size', '8pt')
                                .style('color', textColor)
                                .style('text-decoration', 'underline')
                                .style('cursor', 'pointer')
                                .style('text-align', 'center')
                                .style('line-height', '1.2')
                                .text('PDF');
                        } else if (d.mediaType === 'link') {
                            const metadata = d.mediaMetadata || {};
                            // Show icon only for deeper generations
                            if (d.depth > 1) {
                                previewContainer.append('xhtml:div')
                                    .style('font-size', '16px')
                                    .style('margin-bottom', '3px')
                                    .text(metadata.isSecure ? 'üîó' : 'üåê');
                            }
                            // Domain link
                            previewContainer.append('xhtml:a')
                                .attr('href', d.mediaSrc)
                                .attr('target', '_blank')
                                .style('font-size', '8pt')
                                .style('color', textColor)
                                .style('text-decoration', 'underline')
                                .style('cursor', 'pointer')
                                .style('text-align', 'center')
                                .style('line-height', '1.2')
                                .style('word-wrap', 'break-word')
                                .text(metadata.domain || 'Link');
                        } else if (d.mediaType === 'file') {
                            // Show icon only for deeper generations
                            if (d.depth > 1) {
                                previewContainer.append('xhtml:div')
                                    .style('font-size', '16px')
                                    .style('margin-bottom', '3px')
                                    .text('üìÅ');
                            }
                            // Filename
                            previewContainer.append('xhtml:div')
                                .style('font-size', '8pt')
                                .style('color', textColor)
                                .style('text-align', 'center')
                                .style('word-wrap', 'break-word')
                                .style('line-height', '1.2')
                                .style('hyphens', 'auto')
                                .text(d.mediaSrc);
                        }
                    }
                } else { // Logic for Standard (Circle) View
                    // Set proper dimensions for the circle based on depth
                    if (d.depth === 0) {
                        // Make central node smaller by 5px
                        d.radius = 22; // Reduced from 27 by 5px
                        
                        // Text positioning for central node - below the circle, capitalized
                        const words = d.name.toUpperCase().split(/\s+/); // Convert to uppercase
                        const lineHeight = 22; // Line height for below-circle text
                        const maxWidth = 120; // Increased for better readability
                        const textOffsetY = d.radius + 16; // Set to 16 pixels spacing below circle
                        
                        // Clear existing text
                        text.text('');
                        
                        // Use the new text wrapping function
                        wrapText(text, words.join(' '), maxWidth, lineHeight, 0, '#E0E0E0', '500');
                        
                        // Add notes text if available - with proper wrapping
                        if (d.notes && d.notes.trim() !== '') {
                            const notesText = d.notes.trim();
                            const currentTspanCount = text.selectAll('tspan').size();
                            const startingDy = currentTspanCount > 0 ? lineHeight * 0.8 : 0;
                            
                            // Add wrapped notes with preview formatting (wider, smaller font, max 3 lines)
                            wrapTextPreview(text, notesText, maxWidth * 0.85, lineHeight * 0.5, startingDy, '#FFFFFF', '400', '6pt', 0.6, 3);
                        }
                        
                        // Position the text below the circle
                        const totalLines = text.selectAll('tspan').size();
                        text.attr('transform', `translate(0, ${textOffsetY})`)
                            .attr('dominant-baseline', 'hanging'); // Ensure text starts below circle
                        
                        // Style the text - smaller and less bold for a softer look
                        text.style('font-size', '13pt')
                            .style('letter-spacing', '0px')
                            .style('fill', '#E0E0E0')
                            .style('font-weight', '500');
                        
                        // Remove fisheye effect handlers
                        el.on('mouseenter', null).on('mouseleave', null);
                        // Add minimal breathing effect to the central node's circle
                        if (!circle.classed('breathing')) {
                            circle.classed('breathing', true);
                            circle.transition('breathe-in')
                                .duration(1800)
                                .ease(d3.easeSinInOut)
                                .attr('r', d.radius * 1.07)
                                .transition('breathe-out')
                                .duration(1800)
                                .ease(d3.easeSinInOut)
                                .attr('r', d.radius)
                                .on('end', function repeat() {
                                    d3.select(this)
                                      .transition('breathe-in')
                                      .duration(1800)
                                      .ease(d3.easeSinInOut)
                                      .attr('r', d.radius * 1.07)
                                      .transition('breathe-out')
                                      .duration(1800)
                                      .ease(d3.easeSinInOut)
                                      .attr('r', d.radius)
                                      .on('end', repeat);
                                });
                        }
                    } else {
                        // Optimized node size scaling for better content visibility
                        if (d.depth === 1) {
                            d.radius = 18; // Slightly smaller first generation for better balance
                        } else if (d.depth === 2) {
                            d.radius = 14; // Second generation
                        } else if (d.depth === 3) {
                            d.radius = 11; // Third generation  
                        } else if (d.depth === 4) {
                            d.radius = 9; // Fourth generation
                        } else {
                            d.radius = 8; // Fifth generation and beyond - larger minimum for readability
                        }
                        
                        // For non-central nodes, ensure single line text and proper color
                        let textColor;
                        if (d.depth === 1) {
                            // First generation: use a softer, lighter version of the background color, 10% whiter
                            const baseTextColor = d3.color(d.color).brighter(1.8);
                            // Make it 10% whiter by interpolating towards white
                            textColor = d3.interpolate(baseTextColor, '#FFFFFF')(0.1).toString();
                        } else {
                            // Other depths: use a soft light gray or black
                            textColor = isColorTooBright(d.color) ? '#000000' : '#E0E0E0';
                        }
                        
                        // Clear existing text and rebuild with notes
                        text.text('');
                        
                        // Optimized text positioning and sizing for content viewing
                        let textOffsetY;
                        let maxWidth;
                        // Reduce line height for 2nd generation and beyond
                        let lineHeight;
                        if (d.depth >= 2) {
                            lineHeight = 14; // Balanced compactness and readability
                        } else {
                            lineHeight = 16;
                        }

                        if (d.depth === 1) {
                            // First generation: text inside the node (centered)
                            textOffsetY = 0;
                            maxWidth = 120; // Increased for first generation to prevent truncation
                            text.attr('dominant-baseline', 'middle');
                        } else if (d.depth === 2) {
                            // Second generation: text below the node
                            textOffsetY = d.radius + 14;
                            maxWidth = 80; // Increased for better readability
                            text.attr('dominant-baseline', 'hanging');
                        } else if (d.depth === 3) {
                            // Third generation: balanced width
                            textOffsetY = d.radius + 12;
                            maxWidth = 70; // Increased for better readability
                            text.attr('dominant-baseline', 'hanging');
                        } else {
                            // Fourth generation and beyond: still readable
                            textOffsetY = d.radius + 10;
                            maxWidth = 60; // Increased for better readability
                            text.attr('dominant-baseline', 'hanging');
                        }
                        
                        // Use the new text wrapping function for the main heading
                        wrapText(text, d.name, maxWidth, lineHeight, 0, textColor, '500');
                        
                        // Add notes if available - with proper wrapping
                        if (d.notes && d.notes.trim() !== '') {
                            const notesText = d.notes.trim();
                            const currentTspanCount = text.selectAll('tspan').size();
                            const startingDy = currentTspanCount > 0 ? lineHeight * 0.8 : 0;
                            
                            // Add wrapped notes with preview formatting (wider, smaller font, max 3 lines)
                            wrapTextPreview(text, notesText, maxWidth * 0.75, lineHeight * 0.6, startingDy, '#FFFFFF', '400', '6pt', 0.6, 3);
                        }
                        
                        // Position the text properly
                        text.attr('transform', `translate(0, ${textOffsetY})`);
                    }
                    
                    // If we're transitioning back from expanded, animate it
                    if (d.wasExpanded) {
                        d.wasExpanded = false; // Consume the flag immediately

                        fo.style('pointer-events', 'none');
                        
                        // All animations happen simultaneously
                        // Fade out the content
                        fo.select('.expanded-node-container')
                            .transition()
                            .duration(300)
                            .style('opacity', 0);
                        
                        // Shrink the foreignObject
                        fo.transition()
                            .duration(600)
                            .ease(d3.easeCubicInOut)
                            .attr('x', 0)
                            .attr('y', 0)
                            .attr('width', 0)
                            .attr('height', 0)
                            .style('opacity', 0)
                            .on('end', function() {
                                d3.select(this).html(''); // Clean up content after transition
                            });
                        
                        // Simultaneously morph back to circle
                        circle.transition()
                            .duration(600)
                            .ease(d3.easeCubicInOut)
                            .attr('r', d.radius);
                        
                        // And scale text back in
                        text.transition()
                            .duration(600)
                            .ease(d3.easeCubicInOut)
                            .attr('transform', d.depth === 0 ? `translate(0, ${d.radius + 16}) scale(1)` : 'scale(1)');
                    } else {
                        // Normal rendering (no transition needed)
                        fo.style('opacity', 0).style('pointer-events', 'none');
                        circle.attr('r', d.radius);
                        text.attr('transform', d.depth === 0 ? `translate(0, ${d.radius + 16}) scale(1)` : 'scale(1)');
                    }
                    
                    // Handle fill and fadeout effect for selected nodes
                    const isSelected = selectedNode && selectedNode.id === d.id;
                    
                    if (isSelected) {
                        // Update gradient color and apply it to selected nodes
                        const fadeoutGradient = defs.select("#edge-fadeout");
                        fadeoutGradient.selectAll("stop")
                            .attr("stop-color", d.color);
                        circle.attr('fill', 'url(#edge-fadeout)');
                    } else {
                        circle.attr('fill', d.color);
                    }
                    
                    // Add subtle glow to central node when not selected
                    if (d.depth === 0 && !isSelected) {
                        circle.style('filter', 'drop-shadow(0 0 8px rgba(255, 255, 255, 0.05))');
                    } else if (!isSelected) {
                        circle.style('filter', null); // Remove any existing filter
                    }
                    // When selected (including central node), the CSS .node.selected circle filter takes over
                }
            });

            simulation.nodes(nodes);
            simulation.force("link").links(links);
            
            // Apply dynamic font sizing after node updates
            setTimeout(() => updateDynamicFontSizes(), 50);
        }

        function generateBranchPath(d) {
            const dx = d.target.x - d.source.x;
            const dy = d.target.y - d.source.y;
            const length = Math.sqrt(dx * dx + dy * dy);

            // If nodes are on top of each other, fallback to a straight line
            if (length === 0) {
                return `M${d.source.x},${d.source.y} L${d.target.x},${d.target.y}`;
            }

            // Normalized perpendicular vector to calculate control point offset
            let nx = -dy / length;
            let ny = dx / length;

            // Randomly reverse curve direction for some connectors
            // Use a combination of node IDs to create consistent but varied curve directions
            const curveHash = (d.source.id * 31 + d.target.id * 17) % 100;
            const shouldReverseCurve = curveHash < 50; // 50% chance to reverse
            
            if (shouldReverseCurve) {
                nx = -nx;
                ny = -ny;
            }

            // Base curvature is reactive to the child's depth, creating a fanning effect.
            const baseCurvature = d.target.depth * 8;

            // A continuous, subtle sine wave animation, applied only to children of the central node
            // and only for nodes up to generation 3 (depth <= 3).
            // We add node IDs to desynchronize the animations of different links.
            const animOffset = (d.source.depth === 0 && d.target.depth <= 3) 
                ? Math.sin(Date.now() / 700 + d.source.id + d.target.id) * 4
                : 0;

            const totalCurvature = baseCurvature + animOffset;

            // Calculate the quadratic Bezier curve control point.
            const cpx = (d.source.x + d.target.x) / 2 + nx * totalCurvature;
            const cpy = (d.source.y + d.target.y) / 2 + ny * totalCurvature;

            const path = d3.path();
            path.moveTo(d.source.x, d.source.y);
            path.quadraticCurveTo(cpx, cpy, d.target.x, d.target.y);
            return path.toString();
        }
        
        simulation.on("tick", () => {
            linkGroup.selectAll(".link").attr("d", generateBranchPath);
            nodeGroup.selectAll(".node").attr("transform", d => `translate(${d.x},${d.y})`);
            updateDynamicFontSizes(); // Update font sizes on every tick
        });
        
        function optimizeView(force = false) {
            if (nodes.length === 0) return;
            
            // Check if any nodes are outside the current viewport
            const transform = d3.zoomTransform(svg.node());
            const margin = 100;
            let needsReframing = force;
            
            if (!force) {
                nodes.forEach(node => {
                    const screenX = (node.x * transform.k) + transform.x;
                    const screenY = (node.y * transform.k) + transform.y;
                    const nodeRadius = (node.radius || 20) * transform.k;
                    
                    if (screenX - nodeRadius < margin || 
                        screenX + nodeRadius > container.clientWidth - margin ||
                        screenY - nodeRadius < margin || 
                        screenY + nodeRadius > container.clientHeight - margin) {
                        needsReframing = true;
                    }
                });
            }
            
            if (!needsReframing) return;
            
            const padding = 80; // Reduced padding for tighter zoom
            const xExtent = d3.extent(nodes, d => d.x);
            const yExtent = d3.extent(nodes, d => d.y);
            if (xExtent[0] === undefined) return;
            const [x0, x1] = xExtent;
            const [y0, y1] = yExtent;
            const fullWidth = x1 - x0;
            const fullHeight = y1 - y0;
            if (fullWidth === 0 || fullHeight === 0) return;
            const midX = x0 + fullWidth / 2;
            const midY = y0 + fullHeight / 2;
            const scale = Math.min(2.5, 1.8 / Math.max((fullWidth + padding) / container.clientWidth, (fullHeight + padding) / container.clientHeight)); // Much closer zoom by default
            const newTransform = d3.zoomIdentity.translate(container.clientWidth / 2 - scale * midX, container.clientHeight / 2 - scale * midY).scale(scale);
            svg.transition().duration(800).call(zoom.transform, newTransform) // Slightly longer for smoother transitions
                .on('end', updateDynamicFontSizes); // Update font sizes after zoom transition
        }

        // --- State Management ---
        // Removed setMode and selectNode functions, reverting to older, direct logic.

        // --- Interaction Logic ---
        function addNode(name, parent = null) {
            if (!name.trim()) return null;
            let newNode;

            // Check if this is a list type entry
            const listTypeMatch = name.match(/^(- |1\. |\[\] )(.*)/);
            const isListType = listTypeMatch !== null;
            let listType = null;
            let listContent = name;
            
            if (isListType) {
                if (listTypeMatch[1] === '- ') listType = 'bullet';
                else if (listTypeMatch[1] === '1. ') listType = 'numbered';
                else if (listTypeMatch[1] === '[] ') listType = 'task';
                listContent = listTypeMatch[2];
            }

            if (parent === null) {
                // This block should only ever create the VERY FIRST node.
                if (nodes.length > 0) {
                    console.error("Attempted to create a second central node. Action blocked.");
                    return null; // Prevent creating more than one root.
                }
                const color = "#FFFFFF"; // Central nodes are always white
                let x, y;
                x = container.clientWidth / 2;
                y = container.clientHeight / 2;
                newNode = { 
                    id: nextId++, 
                    name: isListType ? (listContent || 'New List') : name, 
                    depth: 0, 
                    children:[], 
                    x, y, fx: x, fy: y, 
                    color: color,
                    isListNode: false, // Central node cannot be a list
                    listType: undefined,
                listItems: undefined,
                isMediaNode: false,
                mediaType: null,
                mediaSrc: null,
                mediaMetadata: {},
                createdAt: Date.now() // Track creation time for consistency
                };
                nodes.push(newNode);
            } else {
                // If this is a list type entry, transform the parent into a list node
                if (isListType && parent && !parent.isListNode) {
                    // Save previous state for undo
                    const prevState = {
                        isListNode: parent.isListNode,
                        listType: parent.listType,
                        listItems: parent.listItems ? [...parent.listItems] : undefined
                    };
                    // Transform the parent into a list node
                    parent.isListNode = true;
                    parent.listType = listType;
                    parent.listItems = [];
                    
                    // Add the first item if there's content
                    if (listContent) {
                        parent.listItems.push({
                            text: listContent,
                            checked: listType === 'task' ? false : undefined,
                            id: Date.now()
                        });
                    }
                    // Push transformation to historyStack
                    historyStack.push({type: 'transform-list', nodeId: parent.id, prevState});
                    // Enter list entry mode for this node
                    isListEntryMode = true;
                    activeListNode = parent;
                    
                    updateGraph();
                    simulation.alpha(0.05).restart();
                    return parent; // Return the transformed parent
                }
                
                // Regular node creation
                const depth = parent.depth + 1;
                // Distance logic with reduced 1st generation connector length
                let targetDistance;
                if (depth === 1) {
                    // 1st generation: much larger minimum distance for better spacing
                    // Now: minimum 500px, maximum 650px
                    targetDistance = Math.max(500, 650 - parent.children.length * 8); // Varies from 650 down to 500
                } else {
                    // Other generations: keep original logic
                    targetDistance = Math.max(40, 150 - depth * 35); // e.g., 80, 45, 40...
                }

                if (!parent.children) parent.children = [];

                let finalColor;
                if (depth === 1) {
                    // First generation: each child gets a unique palette
                    const availablePalettes = dynastyPalettes.filter((_, idx) => !Array.from(firstGenPaletteAssignment.values()).includes(idx));
                    const paletteIdx = availablePalettes.length > 0 ? dynastyPalettes.indexOf(availablePalettes[0]) : parent.children.length % dynastyPalettes.length;
                    firstGenPaletteAssignment.set(nextId, paletteIdx);
                    finalColor = ensureTextVisible(dynastyPalettes[paletteIdx][0]);
                } else {
                    // Deeper generations: inherit from their dynasty's palette with gradient evolution
                    let firstGenAncestor = parent;
                    while (firstGenAncestor.depth > 1) {
                        const parentLink = links.find(l => l.target.id === firstGenAncestor.id);
                        firstGenAncestor = parentLink ? parentLink.source : null;
                    }
                    const dynastyPaletteIdx = firstGenPaletteAssignment.get(firstGenAncestor.id);
                    if (dynastyPaletteIdx !== undefined && dynastyPalettes[dynastyPaletteIdx]) {
                        const palette = dynastyPalettes[dynastyPaletteIdx];
                        
                        // Enhanced color evolution: transition through multiple colors as depth increases
                        const colorIndex = Math.min(depth - 2, palette.length - 1);
                        const nextColorIndex = Math.min(depth - 1, palette.length - 1);
                        
                        // For 3rd+ generation, create gradient blending between colors
                        if (depth >= 3 && nextColorIndex < palette.length - 1) {
                            const baseColor = d3.color(palette[colorIndex]);
                            const nextColor = d3.color(palette[nextColorIndex]);
                            const blendFactor = (depth - 3) * 0.25; // Gradual transition
                            
                            if (baseColor && nextColor) {
                                const blendedColor = d3.interpolate(baseColor, nextColor)(Math.min(blendFactor, 1));
                                finalColor = ensureTextVisible(blendedColor.toString());
                            } else {
                        finalColor = ensureTextVisible(palette[colorIndex]);
                            }
                        } else {
                            finalColor = ensureTextVisible(palette[colorIndex]);
                        }
                    } else {
                        finalColor = ensureTextVisible(d3.color(parent.color).brighter(0.3).toString());
                    }
                }

                // Restore cone-based placement logic
                const rootNode = nodes[0];
                if (!rootNode) return null; // Should not happen if we have a parent

                let bestAngle;
                if (parent.depth === 0) {
                    // For the central node, cycle through 7 positions with variations
                    const childIndex = parent.children.length;
                    const baseAngles = [
                        0,                      // Right (0¬∞)
                        Math.PI,               // Left (180¬∞)
                        -Math.PI / 2,          // Top (-90¬∞)
                        -3 * Math.PI / 4,      // Top-left (-135¬∞)
                        -Math.PI / 4,          // Top-right (-45¬∞)
                        3 * Math.PI / 4,       // Bottom-left (135¬∞)
                        Math.PI / 4            // Bottom-right (45¬∞)
                    ];
                    
                    // Cycle through the seven base positions
                    const baseAngleIndex = childIndex % 7;
                    let baseAngle = baseAngles[baseAngleIndex];
                    
                    // Add more random variation for visual variety
                    const variationGroup = Math.floor(childIndex / 7); // Which cycle we're in (0, 1, 2, ...)
                    const maxVariation = Math.PI / 7; // ¬±~25 degrees max variation
                    // Add a random offset within the allowed range
                    const randomOffset = (Math.random() - 0.5) * maxVariation;
                    const variation = (variationGroup * (maxVariation / 2)) * (baseAngleIndex % 2 === 0 ? 1 : -1) + randomOffset;
                    bestAngle = baseAngle + variation;
                } else {
                    // For other nodes, use a 160-degree cone based on their own angle from the center
                    const parentAngle = Math.atan2(parent.y - rootNode.y, parent.x - rootNode.x);
                    const coneWidth = (160 * Math.PI) / 180;
                const coneStart = parentAngle - coneWidth / 2;

                const siblingAngles = parent.children.map(child => Math.atan2(child.y - parent.y, child.x - parent.x));
                    bestAngle = parentAngle; // Default to center

                if (siblingAngles.length > 0) {
                    let normalizedSiblings = siblingAngles.map(a => {
                        let norm = a - coneStart;
                        while(norm < 0) norm += 2 * Math.PI;
                        return norm % (2 * Math.PI);
                    }).filter(a => a <= coneWidth + 0.001).sort((a,b)=>a-b);

                    if (normalizedSiblings.length > 0) {
                        let maxGap = 0;
                        let angleAtMaxGap = -1;

                        maxGap = normalizedSiblings[0];
                        angleAtMaxGap = coneStart + maxGap / 2;

                        for(let i = 0; i < normalizedSiblings.length - 1; i++){
                            let gap = normalizedSiblings[i+1] - normalizedSiblings[i];
                            if (gap > maxGap) {
                                maxGap = gap;
                                angleAtMaxGap = coneStart + normalizedSiblings[i] + gap / 2;
                            }
                        }

                        let lastGap = coneWidth - normalizedSiblings[normalizedSiblings.length - 1];
                        if (lastGap > maxGap){
                            angleAtMaxGap = coneStart + normalizedSiblings[normalizedSiblings.length - 1] + lastGap / 2;
                        }
                        bestAngle = angleAtMaxGap;
                        }
                    }
                }

                newNode = {
                    id: nextId++, 
                    name: isListType ? (listContent || 'New List') : name, 
                    depth, 
                    children: [], 
                    x: parent.x + 20 * Math.cos(bestAngle), 
                    y: parent.y + 20 * Math.sin(bestAngle), 
                    color: finalColor,
                    isListNode: false,
                    listType: undefined,
                    listItems: undefined,
                    isMediaNode: false,
                    mediaType: null,
                    mediaSrc: null,
                    mediaMetadata: {},
                    createdAt: Date.now() // Track creation time for position fixing
                };
                nodes.push(newNode);
                
                // Fix position after time delay to prevent excessive floating
                if (depth >= 1) {
                    const fixDelay = depth === 1 ? 2000 : 4000; // 2s for 1st gen (faster), 4s for deeper
                    setTimeout(() => {
                        // Find the node again in case it was moved in the array
                        const nodeToFix = nodes.find(n => n.id === newNode.id);
                        if (nodeToFix && !nodeToFix.fx && !nodeToFix.fy) {
                            // Fix the node's position to stop floating
                            nodeToFix.fx = nodeToFix.x;
                            nodeToFix.fy = nodeToFix.y;
                        }
                    }, fixDelay);
                }

                links.push({ 
                    source: parent, target: newNode, 
                    targetDistance: targetDistance,
                    cp_dx_factor: (Math.random() - 0.5) * 0.4, cp_dy_factor: (Math.random() - 0.5) * 0.4
                });
                parent.children.push(newNode);
            }

            if (newNode) {
                historyStack.push(newNode);
                
                // Trigger Flow Assistant updates for significant changes
                if (nodes.length > 1) { // Only after we have more than just the central node
                    // Trigger contextual suggestions occasionally
                    if (Math.random() < 0.4) { // 40% chance
                        setTimeout(() => generateContextualSuggestions(), 4000); // Longer delay
                    }
                    
                    // Auto-trigger Flow Assistant for new nodes (but only occasionally)
                    if (!document.activeElement || document.activeElement === document.body) {
                        // Only trigger occasionally to avoid rate limits
                        if (Math.random() < 0.3) { // 30% chance
                            setTimeout(() => {
                                if (selectedNode && selectedNode.id === newNode.id) {
                                    activateFlowAssistant(selectedNode);
                                }
                            }, 5000); // Increased delay to 5 seconds
                        }
                    }
                }
            }
            
            updateGraph();
            simulation.alpha(0.1).restart(); // Quick restart that settles fast
            
            // Intelligent camera panning - for central node, center immediately
            if (newNode && newNode.depth === 0) {
                setTimeout(() => optimizeView(true), 100); // Center central node quickly
            } else {
                // For other nodes, check if new node needs reframing
                setTimeout(() => optimizeView(), 500); // Delay to let node settle first
            }
            
            return newNode;
        }

        function removeNode(nodeToRemove) {
            if (!nodeToRemove) return;

            // Find parent before links are filtered, so we can update its children array
            const parentLink = links.find(l => l.target.id === nodeToRemove.id);
            const parentNode = parentLink ? parentLink.source : null;

            const nodesToDelete = new Set([nodeToRemove.id]);
            const findDescendants = (nodeId) => {
                links.filter(l => l.source.id === nodeId).forEach(l => {
                    nodesToDelete.add(l.target.id);
                    findDescendants(l.target.id);
                });
            };
            findDescendants(nodeToRemove.id);

            nodes = nodes.filter(n => !nodesToDelete.has(n.id));
            links = links.filter(l => !nodesToDelete.has(l.source.id) && !nodesToDelete.has(l.target.id));

            // *** FIX ***: Correctly remove the node from its parent's children array
            if (parentNode && parentNode.children) {
                parentNode.children = parentNode.children.filter(child => child.id !== nodeToRemove.id);
            }

            if (selectedNode && nodesToDelete.has(selectedNode.id)) {
                selectedNode = null;
                updateUserInstruction(nodes.length > 0 ? 'Select a node to continue' : 'Click to create your central idea');
                summarizeBtn.style.display = 'none';
                elaborateBtn.style.display = 'none';
            }
            
            updateGraph();
            simulation.alpha(0.1).restart(); // Quick restart that settles fast
            optimizeView();
        }

        function handleNodeClick(event, d) {
            if (event && event.sourceEvent) event.sourceEvent.stopPropagation();
            else if (event) event.stopPropagation();
            
            if (activeExpandedNode) closeExpandedView(activeExpandedNode);

            // Exit list entry mode if clicking a different node
            if (isListEntryMode && activeListNode && activeListNode.id !== d.id) {
                exitListEntryMode();
            }

            // Only update selection and UI, do not call updateGraph or restart simulation
            if (selectedNode) {
                nodeGroup.selectAll('.node').filter(n => n.id === selectedNode.id).classed('selected', false);
            }
            selectedNode = d;
            isPrimedForChild = true;

            if (selectedNode) {
                nodeGroup.selectAll('.node').filter(n => n.id === selectedNode.id).classed('selected', true);
                summarizeBtn.style.display = 'inline-block';
                elaborateBtn.style.display = 'inline-block';
                
                // Activate Flow Assistant when node is selected
                activateFlowAssistant(selectedNode);
                
                // Update instructions based on context
                if (isListEntryMode && activeListNode && activeListNode.id === d.id) {
                    updateUserInstruction(`Adding items to list "${d.name}" ‚Ä¢ Enter to add item ‚Ä¢ Shift+Enter for child node`);
                } else if (isPrimedForChild) {
                    updateUserInstruction(`Creating child of "${d.name}" ‚Ä¢ Enter to create child ‚Ä¢ Click elsewhere to cancel`);
                } else {
                    updateUserInstruction(`Selected "${d.name}" ‚Ä¢ Enter for sibling ‚Ä¢ Shift+Enter for child ‚Ä¢ Click node again for primed mode`);
                }
            }
            nodeInput.focus();
        }
        
        function handleNodeDoubleClick(event, d) {
            if (event) event.stopPropagation();
            
            // Don't allow expanding list nodes or the central node
            if (d.isListNode || d.isMediaNode || d.depth === 0) return;

            if (activeExpandedNode && activeExpandedNode.id !== d.id) {
                closeExpandedView(activeExpandedNode, () => openExpandedView(d));
            } else if (d.isExpanded) {
                closeExpandedView(d);
            } else {
                openExpandedView(d);
            }
        }
        
        // --- Event Listeners ---
        nodeInput.addEventListener('keydown', (event) => {
            if (event.key !== 'Enter') return;
            event.preventDefault();
            const text = nodeInput.value.trim();
            if (!text) return;

            let newNode;

            // Handle list entry mode
            if (isListEntryMode && activeListNode) {
                if (event.shiftKey) {
                    // Shift+Enter: Add a child node to the focused list node
                    newNode = addNode(text, activeListNode);
                    if (newNode) {
                        nodeInput.value = '';
                        // Exit list entry mode and select the new child node
                        exitListEntryMode();
                        handleNodeClick(null, newNode);
                    }
                } else {
                    // Regular Enter: Add item to the active list node
                activeListNode.listItems.push({
                    text: text,
                    checked: activeListNode.listType === 'task' ? false : undefined,
                    id: Date.now() // Simple ID for tracking
                });
                nodeInput.value = '';
                
                // Trigger smooth resize animation by updating the graph
                updateGraph();
                
                // Optional: Add a subtle flash effect to indicate the new item was added
                setTimeout(() => {
                    const listContainer = nodeGroup.selectAll(".node")
                        .filter(d => d.id === activeListNode.id)
                        .select('foreignObject')
                        .select('.list-node-container');
                    
                    if (!listContainer.empty()) {
                        listContainer.style('background-color', d3.color(activeListNode.color).brighter(0.3).toString())
                            .transition()
                            .duration(300)
                            .style('background-color', d3.color(activeListNode.color).copy({opacity: 0.9}).toString());
                    }
                }, 50);
                }
                
                return;
            }

            // Check if this is a list type entry
            const listTypeMatch = text.match(/^(- |1\. |\[\] )(.*)/);
            const isListType = listTypeMatch !== null;
            
            // Check if this is a YouTube URL - handle it like drag and drop
            const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/)|youtu\.be\/)([\w-]{11})/;
            const youtubeMatch = text.match(youtubeRegex);
            if (youtubeMatch && youtubeMatch[1] && selectedNode && selectedNode.depth > 0) {
                // Transform the selected node into a YouTube media node
                const embedUrl = `https://www.youtube.com/embed/${youtubeMatch[1]}`;
                transformToMediaNode(selectedNode, 'youtube', embedUrl);
                nodeInput.value = '';
                return;
            }
            
            // If trying to create a list and a node is selected, transform it
            if (isListType && selectedNode && !selectedNode.isListNode && selectedNode.depth > 0) {
                // Transform the selected node into a list node (but not the central node)
                let listType = null;
                let listContent = listTypeMatch[2];
                
                if (listTypeMatch[1] === '- ') listType = 'bullet';
                else if (listTypeMatch[1] === '1. ') listType = 'numbered';
                else if (listTypeMatch[1] === '[] ') listType = 'task';
                
                selectedNode.isListNode = true;
                selectedNode.listType = listType;
                selectedNode.listItems = [];
                
                // Add the first item if there's content
                if (listContent) {
                    selectedNode.listItems.push({
                        text: listContent,
                        checked: listType === 'task' ? false : undefined,
                        id: Date.now()
                    });
                }
                
                // Enter list entry mode
                isListEntryMode = true;
                activeListNode = selectedNode;
                nodeInput.value = '';
                updateUserInstruction(`Adding items to list "${selectedNode.name}" ‚Ä¢ Enter to add item ‚Ä¢ Shift+Enter for child node`);
                
                updateGraph();
                // Also apply a gentle restart here for consistency
                simulation.alpha(0.05).restart();
                return;
            }

            if (nodes.length === 0) {
                // Case 1: Create the first node
                newNode = addNode(text, null);
                if (newNode) {
                    handleNodeClick(null, newNode); // Select it and prime it for a child
                    nodeInput.value = '';
                }
            } else if (selectedNode) {
                // Case 2: A node is selected, decide what to create
                if (isPrimedForChild) {
                    // It was primed, so Enter creates a child.
                    newNode = addNode(text, selectedNode);
                } else {
                    // Standard mode: Shift+Enter for child, Enter for sibling.
                    if (event.shiftKey) {
                        newNode = addNode(text, selectedNode); 
                    } else {
                        const parentLink = links.find(l => l.target.id === selectedNode.id);
                        // If root is selected, create a child. Otherwise, create a sibling.
                        const parent = parentLink ? parentLink.source : selectedNode;
                        newNode = addNode(text, parent);
                    }
                }

                if (newNode) {
                    // Clear input first
                    nodeInput.value = '';
                    
                    // Select the new node. This will correctly prime it for the moment.
                    handleNodeClick(null, newNode);
                    
                    // For the next interaction, we always want to be in standard mode
                    // after any key-based creation (unless we entered list mode).
                    if (!isListEntryMode) {
                        isPrimedForChild = false;
                        updateUserInstruction(`Selected "${newNode.name}" ‚Ä¢ Enter for sibling ‚Ä¢ Shift+Enter for child`);
                    }
                }
            }
        });

        d3.select("body").on("keydown", (event) => {
            if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
                // Exit list entry mode on navigation
                if (isListEntryMode) {
                    exitListEntryMode();
                }
                
                if (!selectedNode) {
                    return;
                }
                event.preventDefault();

                // --- Highly intelligent spatial navigation ---
                function findClosestNodeInDirection(fromNode, direction) {
                    // Direction vectors
                    const dirVectors = {
                        ArrowUp:    { x: 0, y: -1 },
                        ArrowDown:  { x: 0, y: 1 },
                        ArrowLeft:  { x: -1, y: 0 },
                        ArrowRight: { x: 1, y: 0 }
                    };
                    const v = dirVectors[direction];
                    if (!v) return null;

                    let bestNode = null;
                    let bestScore = Infinity;

                    for (const node of nodes) {
                        if (node.id === fromNode.id) continue;
                        // Vector from fromNode to node
                        const dx = node.x - fromNode.x;
                        const dy = node.y - fromNode.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist === 0) continue;
                        // Normalize
                        const ndx = dx / dist;
                        const ndy = dy / dist;
                        // Dot product: how well does this node align with the intended direction?
                        const dot = v.x * ndx + v.y * ndy;
                        // Only consider nodes that are at least somewhat in the intended direction
                        if (dot < 0.5) continue; // 0.5 = within 60 degrees of the direction
                        // Penalize by angular deviation and distance
                        const anglePenalty = 1 - dot; // 0 is perfect alignment, 1 is perpendicular
                        const score = dist * (1 + anglePenalty * 2); // Weight angle more
                        if (score < bestScore) {
                            bestScore = score;
                            bestNode = node;
                        }
                    }
                    return bestNode;
                        }

                let newSelection = findClosestNodeInDirection(selectedNode, event.key);

                if (newSelection) {
                    handleNodeClick(null, newSelection);
                }
                return; // Navigation was handled, stop further processing
            }

            // --- Prevent other actions if input is focused ---
            if(document.activeElement === nodeInput) return;

            // --- Undo Logic (Ctrl+Z / Cmd+Z) ---
            if ((event.ctrlKey || event.metaKey) && (event.key === 'z' || event.key === 'Z')) {
                // Don't interfere if user is actively typing
                if (document.activeElement === nodeInput && nodeInput.value.trim() !== '') return;
                
                event.preventDefault();
                const lastAction = historyStack.pop();
                if (lastAction) {
                    if (lastAction.type === 'transform-list') {
                        // Undo list transformation
                        const node = nodes.find(n => n.id === lastAction.nodeId);
                        if (node) {
                            node.isListNode = lastAction.prevState.isListNode;
                            node.listType = lastAction.prevState.listType;
                            node.listItems = lastAction.prevState.listItems;
                            updateGraph();
                            simulation.alpha(0.1).restart();
                        }
                    } else if (lastAction.type === 'transform-media') {
                        // Undo media transformation (implement if you have media node transforms)
                        const node = nodes.find(n => n.id === lastAction.nodeId);
                        if (node) {
                            node.isMediaNode = false;
                            node.mediaType = null;
                            node.mediaSrc = null;
                            node.mediaMetadata = {};
                            updateGraph();
                            simulation.alpha(0.1).restart();
                        }
                    } else {
                        // Default: remove node
                        const nodeToRemove = nodes.find(n => n.id === lastAction.id);
                        if(nodeToRemove) {
                            // Find the previous node to focus on after undo
                            const previousNode = historyStack.length > 0 ? historyStack[historyStack.length - 1] : null;
                            const previousNodeInGraph = previousNode ? nodes.find(n => n.id === previousNode.id) : null;
                            removeNode(nodeToRemove);
                            if (previousNodeInGraph) {
                                handleNodeClick(null, previousNodeInGraph);
                            } else if (nodes.length > 0) {
                                const centralNode = nodes.find(n => n.depth === 0);
                                if (centralNode) {
                                    handleNodeClick(null, centralNode);
                                }
                            }
                        }
                    }
                }
            }
            
            // --- Delete Node Logic (Delete / Backspace) ---
            if(selectedNode && (event.key === 'Delete' || event.key === 'Backspace')){
                event.preventDefault();
                removeNode(selectedNode);
            }
        });
        
        // --- LLM and Dragging ---
        async function triggerProactiveSuggestions(newNode) {
            // Wait a moment for the user to finish their thought
            setTimeout(() => {
                // Don't interrupt if user is actively working
                if (document.activeElement === nodeInput && nodeInput.value.trim() !== '') return;
                if (isDragging) return;
                if (isListEntryMode) return;
                
                generateContextualSuggestions();
            }, 3000); // Increased delay to be less intrusive
        }
        summarizeBtn.addEventListener('click', async () => {
            if (!selectedNode) return;
            
            const context = buildMindMapContext();
            const prompt = `Summarize this mind map: ${context}`;
            
            callDeepSeekAPIWithRateLimit(prompt, 260, 'high').then(response => {
                if (response) {
                    addAssistantMessage("Summary:", []);
                    addAssistantMessage(response, []);
                }
            });
        });
        
        elaborateBtn.addEventListener('click', async () => {
            if (!selectedNode) return;
            
            const prompt = `Elaborate on "${selectedNode.name}" with key insights.`;
            
            callDeepSeekAPIWithRateLimit(prompt, 260, 'high').then(response => {
                if (response) {
                    addAssistantMessage(`About "${selectedNode.name}":`, []);
                    addAssistantMessage(response, []);
                    
                    // Also generate some suggested child nodes
                    const suggestionPrompt = `Suggest 3-4 child nodes for "${selectedNode.name}" (2-3 words each) as JSON array.`;
                    callDeepSeekAPIWithRateLimit(suggestionPrompt, 150, 'medium').then(suggestions => {
                        if (suggestions) {
                            try {
                                const parsed = JSON.parse(suggestions);
                                if (Array.isArray(parsed)) {
                                    addAssistantMessage("Explore:", parsed.slice(0, 4));
                                }
                            } catch (e) {
                                // Silent fail
                            }
                        }
                    });
                }
            });
        });
        function flashNode(nodeId) {
            const nodeToFlash = node.filter(d => d.id === nodeId);
            // ... existing code ...
        }
        function displayAiSuggestions(suggestions) { /* ... same as before ... */ }
        function displayAiResponse(text, title) { /* ... same as before ... */ }
        
        function dragstarted(event, d) {
            // Store starting position to distinguish clicks from drags
            d.startX = event.x;
            d.startY = event.y;
            isDragging = false; // Reset flag
            
            // Store initial distances ONLY for directly connected links (not all links)
            const directlyConnectedLinks = links.filter(l => 
                (l.source.id === d.id) || (l.target.id === d.id)
            );
            directlyConnectedLinks.forEach(link => {
                link.initialDistance = Math.hypot(link.target.x - link.source.x, link.target.y - link.source.y);
            });

            // Track only immediate children for potential repositioning
            d.draggedChildren = [];
            const immediateChildren = links.filter(l => l.source.id === d.id).map(l => l.target);
            immediateChildren.forEach(child => {
                d.draggedChildren.push({
                    node: child,
                    originalX: child.x,
                    originalY: child.y
                });
            });
        }
        function dragged(event, d) {
            if (!isDragging) {
                const dx = event.x - d.startX;
                const dy = event.y - d.startY;
                // Only start a "real" drag if the mouse moves more than 15px (increased threshold)
                if (dx * dx + dy * dy > 225) { // 15px threshold
                    isDragging = true;
                    // Do NOT restart the entire simulation - just pin this node
                    // This prevents affecting nodes from other branches
                }
            }
            
            if (isDragging) {
                // Simply pin the dragged node position - no simulation forces
                d.fx = event.x;
                d.fy = event.y;
                // Do not affect any other nodes during drag
            }
        }
        function dragended(event, d) {
            if (!isDragging) {
                // --- THIS IS A CLICK ---
                handleNodeClick(event, d);
            } else {
                // --- THIS WAS A DRAG ---
                // Pin nodes after dragging to prevent unwanted floating
                // Central node stays pinned, first generation nodes get pinned, others can float
                if (d.depth === 0 || d.depth === 1) {
                    // Keep first generation and central nodes pinned after drag
                    d.fx = d.x;
                    d.fy = d.y;
                } else {
                    // Allow other nodes to settle naturally
                    d.fx = null;
                    d.fy = null;
                }
                
                // Update distances only for directly connected links
                const directlyConnectedLinks = links.filter(l => 
                    (l.source.id === d.id) || (l.target.id === d.id)
                );
                directlyConnectedLinks.forEach(link => {
                    const postDragDistance = Math.hypot(link.target.x - link.source.x, link.target.y - link.source.y);
                    const initialDistance = link.initialDistance || link.targetDistance;
                    const distanceChange = postDragDistance - initialDistance;
                    
                    if (Math.abs(distanceChange) > 5) { // Only update if significant change
                    if (distanceChange > 0) {
                            // Stretched: learn 40% of the new distance (reduced from 60%)
                            link.targetDistance = Math.max(40, link.targetDistance + (distanceChange * 0.4));
                        } else {
                            // Contracted: learn only 20% of the contracted distance (reduced from 30%)
                        const contractionAmount = Math.abs(distanceChange);
                            link.targetDistance = Math.max(40, link.targetDistance - (contractionAmount * 0.2));
                        }
                    }
                    
                    // Clean up the initial distance tracking
                    delete link.initialDistance;
                });
                
                // Gentle post-drag repositioning of immediate children only (45% reduced)
                if (d.draggedChildren && d.draggedChildren.length > 0) {
                    const dragDeltaX = d.x - (d.startX || d.x);
                    const dragDeltaY = d.y - (d.startY || d.y);
                    
                    // Only reposition if there was significant movement
                    if (Math.abs(dragDeltaX) > 20 || Math.abs(dragDeltaY) > 20) { // Balanced threshold (between 15 and 25)
                        setTimeout(() => {
                            gentlyRepositionChildren(d, d.draggedChildren);
                        }, 155); // 45% reduction in delay increase: 100 + (200-100)*0.55 = 155ms
                    }
                    
                    // Clean up children data
                    d.draggedChildren = null;
                }
                
                // Only give a very gentle nudge to the simulation - no major restart
                simulation.alpha(Math.max(simulation.alpha(), 0.02));
            }
            // Clean up start positions
            delete d.startX;
            delete d.startY;
        }

        function gentlyRepositionChildren(parentNode, children) {
            // Apply gentler forces - reduced by 45%
            const repositionStrength = 0.044; // 45% reduction from 0.08 (0.08 * 0.55 = 0.044)
            const maxRepositionDistance = 14; // 45% reduction from 25 (25 * 0.55 ‚âà 14)
            
            children.forEach(childData => {
                const child = childData.node;
                
                // Only apply minimal adjustment
                const dx = parentNode.x - child.x;
                const dy = parentNode.y - child.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Only apply force if child is far from parent
                if (distance > 100) { // Adjusted threshold (between 80 and 120)
                    const targetDistance = 65; // Balanced target distance
                    const pullStrength = (distance - targetDistance) / distance;
                    const limitedPull = Math.min(pullStrength, 0.165); // 45% reduction from 0.3 (0.3 * 0.55 = 0.165)
                    
                    // Apply gentle pull towards parent
                    child.vx += dx * limitedPull * repositionStrength;
                    child.vy += dy * limitedPull * repositionStrength;
                }
            });
            
            // Give the simulation a gentler nudge - 45% reduction
            simulation.alpha(Math.max(simulation.alpha(), 0.0275)); // 45% reduction from 0.05 (0.05 * 0.55 = 0.0275)
        }
        
        // --- Initial State ---
        window.addEventListener('resize', optimizeView);
        
        // Theme dropdown event listener
        const themeDropdown = document.getElementById('theme-dropdown');
        themeDropdown.value = currentTheme; // Set initial value
        themeDropdown.addEventListener('change', (event) => {
            switchTheme(event.target.value);
        });
        
        applyTheme();
        nodeInput.focus(); // Set focus on the input field on load
        
        // Initialize user instructions
        updateUserInstruction('Click to create your central idea');
        // Keep minimal simulation running for drag responsiveness
        d3.timer(() => {
            if (simulation.alpha() < 0.01) {
                simulation.alpha(0.01); // Maintain minimal energy for drag detection
            }
        });
        
        // Initialize dynamic font sizes
        setTimeout(() => updateDynamicFontSizes(), 100);

        // Periodic Flow Assistant refresh for long sessions (much less frequent)
        let lastFlowAssistantUpdate = 0;
        setInterval(() => {
            // Only refresh if user has been idle for a very long time
            if (selectedNode && 
                !isDragging && 
                !isListEntryMode && 
                document.activeElement !== nodeInput &&
                Date.now() - lastFlowAssistantUpdate > 900000) { // 15 minutes instead of 5
                
                activateFlowAssistant(selectedNode);
                lastFlowAssistantUpdate = Date.now();
            }
        }, 300000); // Check every 5 minutes instead of 1 minute

        // Track significant map changes for Flow Assistant triggers
        let lastMapStructureHash = '';
        function getMapStructureHash() {
            const structure = nodes.map(n => `${n.id}:${n.name}:${n.depth}`).sort().join('|');
            return structure;
        }

        // Enhanced node change detection
        const originalUpdateGraph = updateGraph;
        updateGraph = function() {
            const newHash = getMapStructureHash();
            const hasSignificantChange = newHash !== lastMapStructureHash && nodes.length > 1;
            
            // Call original function
            originalUpdateGraph.call(this);
            
            // Trigger Flow Assistant on significant changes (much less frequently)
            if (hasSignificantChange && selectedNode && Date.now() - lastFlowAssistantUpdate > 60000) { // 1 minute instead of 10 seconds
                // Only trigger 20% of the time to reduce API calls
                if (Math.random() < 0.2) {
                    setTimeout(() => {
                        if (selectedNode && !isDragging && !isListEntryMode) {
                            activateFlowAssistant(selectedNode);
                            lastFlowAssistantUpdate = Date.now();
                        }
                    }, 3000); // Longer delay to let user finish their work
                }
            }
            
            lastMapStructureHash = newHash;
        };

        window.addEventListener('dragenter', (event) => {
            event.preventDefault();
            // Show a border on the container to indicate it's a drop zone
            container.style.border = '2px dashed var(--ui-focus-dark)';
        });

        window.addEventListener('dragleave', (event) => {
            event.preventDefault();
            // Check if the cursor is leaving the window. relatedTarget will be null.
            if (event.relatedTarget === null) {
                container.style.border = 'none';
                if (dropTargetNode) {
                    nodeGroup.selectAll('.node').filter(n => n.id === dropTargetNode.id).classed('drop-target', false);
                    dropTargetNode = null;
                }
            }
        });

        window.addEventListener('dragover', (event) => {
            event.preventDefault(); // This is crucial to allow the 'drop' event.

            // Convert screen coordinates to SVG space coordinates, accounting for zoom/pan
            const transform = d3.zoomTransform(svg.node());
            const [mx, my] = d3.pointer(event, masterGroup.node());

            let closestNode = null;
            let minDistance = Infinity;

            // Find the closest node to the cursor
            nodes.forEach(node => {
                // Cannot drop on the central node, or nodes that are already special types.
                if (node.depth === 0 || node.isListNode || node.isExpanded || node.isMediaNode) return;
                
                const dx = node.x - mx;
                const dy = node.y - my;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Check if cursor is within the node's radius + a small buffer
                if (distance < minDistance && distance < node.radius + 30) {
                    minDistance = distance;
                    closestNode = node;
                }
            });

            if (closestNode !== dropTargetNode) {
                // Remove highlight from the old target
                if (dropTargetNode) {
                    nodeGroup.selectAll('.node').filter(n => n.id === dropTargetNode.id).classed('drop-target', false);
                }
                // Add highlight to the new target
                if (closestNode) {
                    nodeGroup.selectAll('.node').filter(n => n.id === closestNode.id).classed('drop-target', true);
                }
                dropTargetNode = closestNode;
            }
        });

        window.addEventListener('drop', (event) => {
            event.preventDefault();
            container.style.border = 'none'; // Hide the container border

            if (dropTargetNode) {
                // Always remove the highlight from the drop target node
                nodeGroup.selectAll('.node').filter(n => n.id === dropTargetNode.id).classed('drop-target', false);
                
                const dt = event.dataTransfer;
                const files = dt.files;
                const url = dt.getData('text/uri-list') || dt.getData('text/plain');

                if (files.length > 0) {
                    // Handle file drop
                    const file = files[0];
                    if (file.type.startsWith('image/')) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            transformToMediaNode(dropTargetNode, 'image', e.target.result);
                        };
                        reader.readAsDataURL(file);
                    } else {
                        // For other file types, just use the file name
                         transformToMediaNode(dropTargetNode, 'file', file.name);
                    }
                } else if (url) {
                    // --- Intelligent URL Processing ---
                    const linkInfo = intelligentLinkDetection(url);
                    transformToMediaNode(dropTargetNode, linkInfo.type, linkInfo.src, linkInfo.metadata);
                }
                // Reset drop target after processing
                dropTargetNode = null;
            }
        });

        svg.on('click', (event) => {
            // Check if we clicked on the background, not a node or button
            if (event.target !== container && event.target !== svg.node()) return;
            
            // Additional check to prevent closing on button clicks
            if (event.target.classList && (
                event.target.classList.contains('ai-action-btn') ||
                event.target.closest('.ai-action-btn') ||
                event.target.closest('.notes-editor') ||
                event.target.closest('.expanded-node-container')
            )) {
                return;
            }
            
            if (activeExpandedNode) {
                closeExpandedView(activeExpandedNode);
            }

            if (selectedNode) {
                nodeGroup.selectAll('.node').filter(n => n.id === selectedNode.id).classed('selected', false);
                selectedNode = null;
                isPrimedForChild = false;
                updateUserInstruction(nodes.length > 0 ? 'Select a node to continue' : 'Click to create your central idea');
                summarizeBtn.style.display = 'none';
                elaborateBtn.style.display = 'none';
            }
        });

        nodeInput.addEventListener('focus', () => {
            if (activeExpandedNode) {
                closeExpandedView(activeExpandedNode);
            }
        });

        function saveToHistory() {
            // TODO: In-depth history implementation for undo/redo
        }

        function openExpandedView(d) {
            d.isExpanded = true;
            activeExpandedNode = d;
            updateGraph();
            // --- Camera pan/zoom to center expanded node ---
            // Get node position
            const svgRect = svg.node().getBoundingClientRect();
            const centerX = svgRect.width / 2;
            const centerY = svgRect.height / 2;
            // Use d.x, d.y as node position in simulation coordinates
            // Calculate the current transform
            const currentTransform = d3.zoomTransform(svg.node());
            // Target: move d.x, d.y to center of viewport
            const targetScale = Math.max(0.7, Math.min(1.2, currentTransform.k)); // Keep scale reasonable
            const tx = centerX - d.x * targetScale;
            const ty = centerY - d.y * targetScale;
            // Animate the zoom/pan
            svg.transition()
                .duration(700)
                .call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(targetScale));
        }

        function closeExpandedView(d, callback) {
            if (!d || !d.isExpanded) {
                if(callback) callback();
                return;
            }
            activeExpandedNode = null;
            d.isExpanded = false;
            d.wasExpanded = true;
            d.fx = null;
            d.fy = null;

            // The actual animation is handled in updateGraph now
            updateGraph();
            
            // Zoom out camera during the transition
            optimizeView();
            
            // Wait for the animation to complete before calling callback
            if (callback) {
                setTimeout(callback, 600);
            }
        }

        function handleBackgroundClick(event) {
            if (event.target !== container && event.target !== svg.node()) return;
            
            if (activeExpandedNode) {
                closeExpandedView(activeExpandedNode);
            }

            // Exit list entry mode
            if (isListEntryMode) {
                exitListEntryMode();
            }

            if (selectedNode) {
                nodeGroup.selectAll('.node').filter(n => n.id === selectedNode.id).classed('selected', false);
                selectedNode = null;
                isPrimedForChild = false;
                updateUserInstruction(nodes.length > 0 ? 'Select a node to continue' : 'Click to create your central idea');
                summarizeBtn.style.display = 'none';
                elaborateBtn.style.display = 'none';
                
                // Show Flow Assistant welcome message when no node is selected
                showFlowAssistantWelcome();
            }
        }

        function centerOnNode(d) {
            const foWidth = Math.min(320, container.clientWidth * 0.32);
            const foHeight = Math.min(230, container.clientHeight * 0.35);

            const width = svg.node().clientWidth;
            const height = svg.node().clientHeight;
            
            // For expanded nodes, calculate scale to ensure it fits comfortably on screen
            const scale = d.isExpanded ? 
                Math.min(
                    width / (foWidth * 2.5), 
                    height / (foHeight * 2.5),
                    1.8 // Increased max scale for closer zoom on expanded nodes
                ) : 
                1.5; // Closer default scale when not expanded

            const transform = d3.zoomIdentity
                .translate(width / 2, height / 2)
                .scale(scale)
                .translate(-d.x, -d.y);

            svg.transition()
                .duration(600) // Reduced transition duration
                .call(zoom.transform, transform)
                .on('end', updateDynamicFontSizes);
        }

        function exitListEntryMode() {
            isListEntryMode = false;
            activeListNode = null;
            if (selectedNode) {
                updateUserInstruction(`Selected "${selectedNode.name}" ‚Ä¢ Enter for sibling ‚Ä¢ Shift+Enter for child`);
            }
        }

        // Custom backspace logic for list entry mode
        let listBackspaceState = 0; // 0: normal, 1: highlight last, 2: delete
        nodeInput.addEventListener('keydown', (event) => {
            if (isListEntryMode && event.key === 'Backspace' && activeListNode && activeListNode.listItems.length > 0 && nodeInput.value === '') {
                event.preventDefault();
                if (listBackspaceState === 0) {
                    // Highlight last item for replacement
                    const idx = activeListNode.listItems.length - 1;
                    const node = nodeGroup.selectAll('.node').filter(d => d.id === activeListNode.id);
                    node.selectAll('.list-items-container > div').filter((d, i) => i === idx)
                        .style('background', '#ffb7b7')
                        .style('color', '#a00');
                    listBackspaceState = 1;
                } else if (listBackspaceState === 1) {
                    // Delete last item
                    activeListNode.listItems.pop();
                    listBackspaceState = 0;
                    updateGraph();
                }
            } else if (event.key !== 'Backspace') {
                listBackspaceState = 0;
                // Remove highlight if present
                if (activeListNode) {
                    const node = nodeGroup.selectAll('.node').filter(d => d.id === activeListNode.id);
                    node.selectAll('.list-items-container > div').style('background', '').style('color', '');
                }
            }
        });

        // Global keyboard event listener for Ctrl+Z undo functionality
        document.addEventListener('keydown', (event) => {
            // Only handle Ctrl+Z / Cmd+Z when not typing in the input field
            if ((event.ctrlKey || event.metaKey) && (event.key === 'z' || event.key === 'Z')) {
                // Don't interfere if user is actively typing
                if (document.activeElement === nodeInput && nodeInput.value.trim() !== '') return;
                
                event.preventDefault();
                const lastAction = historyStack.pop();
                if (lastAction) {
                    if (lastAction.type === 'transform-list') {
                        // Undo list transformation
                        const node = nodes.find(n => n.id === lastAction.nodeId);
                        if (node) {
                            node.isListNode = lastAction.prevState.isListNode;
                            node.listType = lastAction.prevState.listType;
                            node.listItems = lastAction.prevState.listItems;
                            updateGraph();
                            simulation.alpha(0.1).restart();
                        }
                    } else if (lastAction.type === 'transform-media') {
                        // Undo media transformation (implement if you have media node transforms)
                        const node = nodes.find(n => n.id === lastAction.nodeId);
                        if (node) {
                            node.isMediaNode = false;
                            node.mediaType = null;
                            node.mediaSrc = null;
                            node.mediaMetadata = {};
                            updateGraph();
                            simulation.alpha(0.1).restart();
                        }
                    } else {
                        // Default: remove node
                        const nodeToRemove = nodes.find(n => n.id === lastAction.id);
                        if(nodeToRemove) {
                            // Find the previous node to focus on after undo
                            const previousNode = historyStack.length > 0 ? historyStack[historyStack.length - 1] : null;
                            const previousNodeInGraph = previousNode ? nodes.find(n => n.id === previousNode.id) : null;
                            removeNode(nodeToRemove);
                            if (previousNodeInGraph) {
                                handleNodeClick(null, previousNodeInGraph);
                            } else if (nodes.length > 0) {
                                const centralNode = nodes.find(n => n.depth === 0);
                                if (centralNode) {
                                    handleNodeClick(null, centralNode);
                                }
                            }
                        }
                    }
                }
            }
            
            // Handle Ctrl+V for pasting images and URLs
            if ((event.ctrlKey || event.metaKey) && (event.key === 'v' || event.key === 'V')) {
                // Don't interfere if user is actively typing in input field
                if (document.activeElement === nodeInput) return;
                
                event.preventDefault();
                
                // Check if we have a selected node to attach the media to
                if (!selectedNode) {
                    // If no node selected, create a new central node or add to existing central node
                    const centralNode = nodes.find(n => n.depth === 0);
                    if (centralNode) {
                        selectedNode = centralNode;
                    } else {
                        // Create central node if none exists
                        selectedNode = addNode("Media Collection", null);
                        if (!selectedNode) return;
                    }
                }
                
                // Try to get clipboard data
                navigator.clipboard.read().then(async (clipboardItems) => {
                    for (const clipboardItem of clipboardItems) {
                        for (const type of clipboardItem.types) {
                            if (type.startsWith('image/')) {
                                // Handle image paste
                                const blob = await clipboardItem.getType(type);
                                const imageUrl = URL.createObjectURL(blob);
                                createMediaNode(selectedNode, 'image', imageUrl, { source: 'clipboard' });
                                return;
                            }
                        }
                    }
                }).catch(() => {
                    // Fallback: try to get text (URLs)
                    navigator.clipboard.readText().then(text => {
                        if (text && text.trim()) {
                            // Check if it's a URL
                            try {
                                new URL(text);
                                // It's a valid URL, create media node
                                const mediaInfo = intelligentLinkDetection(text);
                                if (mediaInfo) {
                                    createMediaNode(selectedNode, mediaInfo.type, mediaInfo.src, mediaInfo.metadata);
                                }
                            } catch (e) {
                                // Not a URL, ignore
                            }
                        }
                    }).catch(() => {
                        // Clipboard access failed, show user instruction
                        addAssistantMessage("To paste images: Copy an image from another tab, then Ctrl+V here. For URLs: Copy the URL and Ctrl+V here.", []);
                    });
                });
            }

            // --- Delete Node Logic (Delete / Backspace) ---
            // Only delete if not editing text (input, textarea, or contenteditable)
            const active = document.activeElement;
            const isEditing = active && (
                active.tagName === 'INPUT' ||
                active.tagName === 'TEXTAREA' ||
                active.isContentEditable
            );
            if (!isEditing && selectedNode && (event.key === 'Delete' || event.key === 'Backspace')) {
                event.preventDefault();
                removeNode(selectedNode);
            }
        });
        
        // Helper function to create media nodes
        function createMediaNode(parentNode, type, src, metadata = {}) {
            if (!parentNode) return null;
            
            // Save previous state for undo
            const prevState = {
                isMediaNode: parentNode.isMediaNode,
                mediaType: parentNode.mediaType,
                mediaSrc: parentNode.mediaSrc,
                mediaMetadata: parentNode.mediaMetadata ? {...parentNode.mediaMetadata} : {}
            };
            
            // If YouTube, fetch oEmbed data for title/thumbnail
            if (type === 'youtube') {
                // Extract video ID from src or metadata
                let videoId = null;
                if (metadata && metadata.videoId) {
                    videoId = metadata.videoId;
                } else {
                    // Try to extract from src
                    const match = src.match(/[?&]v=([\w-]{11})/) || src.match(/youtu\.be\/([\w-]{11})/);
                    if (match) videoId = match[1];
                }
                if (videoId) {
                    const oembedUrl = `https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${videoId}&format=json`;
                    fetch(oembedUrl)
                        .then(r => r.json())
                        .then(data => {
                            // Update node with oEmbed data
                            parentNode.mediaMetadata = {
                                ...metadata,
                                title: data.title,
                                thumbnail_url: data.thumbnail_url,
                                author_name: data.author_name,
                                oembed: true
                            };
                            updateGraph();
                        })
                        .catch(() => {
                            // Fallback to generic
                            parentNode.mediaMetadata = metadata;
                            updateGraph();
                        });
                }
            }
            // Transform the parent into a media node
            parentNode.isMediaNode = true;
            parentNode.mediaType = type;
            parentNode.mediaSrc = src;
            parentNode.mediaMetadata = metadata;
            
            // Push transformation to historyStack
            historyStack.push({type: 'transform-media', nodeId: parentNode.id, prevState});
            
            updateGraph();
            simulation.alpha(0.1).restart();
            
            // Show success message
            const mediaTypeNames = {
                'image': 'Image',
                'youtube': 'YouTube Video',
                'vimeo': 'Vimeo Video',
                'twitter': 'Twitter Post',
                'github': 'GitHub Repository',
                'pdf': 'PDF Document',
                'link': 'Link'
            };
            const mediaName = mediaTypeNames[type] || 'Media';
            addAssistantMessage(`Added ${mediaName} to "${parentNode.name}"`, []);
            
            return parentNode;
        }

        // Intelligent link detection with metadata extraction
        function intelligentLinkDetection(url) {
            // 1. YouTube videos
            const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/)|youtu\.be\/)([\w-]{11})/;
            const youtubeMatch = url.match(youtubeRegex);
            if (youtubeMatch && youtubeMatch[1]) {
                return {
                    type: 'youtube',
                    src: `https://www.youtube.com/embed/${youtubeMatch[1]}`,
                    metadata: {
                        videoId: youtubeMatch[1],
                        thumbnail: `https://img.youtube.com/vi/${youtubeMatch[1]}/maxresdefault.jpg`,
                        originalUrl: url
                    }
                };
            }

            // 2. Vimeo videos
            const vimeoRegex = /(?:https?:\/\/)?(?:www\.)?vimeo\.com\/(\d+)/;
            const vimeoMatch = url.match(vimeoRegex);
            if (vimeoMatch && vimeoMatch[1]) {
                return {
                    type: 'vimeo',
                    src: `https://player.vimeo.com/video/${vimeoMatch[1]}`,
                    metadata: {
                        videoId: vimeoMatch[1],
                        originalUrl: url
                    }
                };
            }

            // 3. Twitter/X posts
            const twitterRegex = /(?:https?:\/\/)?(?:www\.)?(?:twitter\.com|x\.com)\/\w+\/status\/(\d+)/;
            const twitterMatch = url.match(twitterRegex);
            if (twitterMatch && twitterMatch[1]) {
                return {
                    type: 'twitter',
                    src: url,
                    metadata: {
                        tweetId: twitterMatch[1],
                        embedUrl: `https://platform.twitter.com/embed/Tweet.html?id=${twitterMatch[1]}`
                    }
                };
            }

            // 4. GitHub repositories
            const githubRegex = /(?:https?:\/\/)?(?:www\.)?github\.com\/([^\/]+)\/([^\/]+)/;
            const githubMatch = url.match(githubRegex);
            if (githubMatch && githubMatch[1] && githubMatch[2]) {
                return {
                    type: 'github',
                    src: url,
                    metadata: {
                        owner: githubMatch[1],
                        repo: githubMatch[2],
                        apiUrl: `https://api.github.com/repos/${githubMatch[1]}/${githubMatch[2]}`
                    }
                };
            }

            // 5. Google Images redirect URLs
            const googleMatch = url.match(/[?&]imgurl=([^&]+)/);
            if (googleMatch && googleMatch[1]) {
                try {
                    const decodedUrl = decodeURIComponent(googleMatch[1]);
                    return {
                        type: 'image',
                        src: decodedUrl,
                        metadata: { source: 'google-images', originalUrl: url }
                    };
                } catch (e) {
                    console.error("Could not decode Google Image URL", e);
                }
            }

            // 6. Unsplash photo pages
            const unsplashMatch = url.match(/unsplash\.com\/photos\/([^/]+)/);
            if (unsplashMatch && unsplashMatch[1]) {
                return {
                    type: 'image',
                    src: `https://source.unsplash.com/${unsplashMatch[1]}`,
                    metadata: { source: 'unsplash', photoId: unsplashMatch[1], originalUrl: url }
                };
            }

            // 7. Direct image URLs
            if (url.startsWith('data:image') || /\.(jpg|jpeg|png|gif|svg|webp)$/i.test(url)) {
                return {
                    type: 'image',
                    src: url,
                    metadata: { source: 'direct' }
                };
            }

            // 8. PDF documents
            if (/\.pdf$/i.test(url)) {
                return {
                    type: 'pdf',
                    src: url,
                    metadata: { fileType: 'pdf' }
                };
            }

            // 9. Extract domain for better link preview
            let domain = '';
            try {
                const urlObj = new URL(url.startsWith('http') ? url : `https://${url}`);
                domain = urlObj.hostname.replace('www.', '');
            } catch (e) {
                domain = url.split('/')[0];
            }

            // 10. Default: generic link with domain info
            return {
                type: 'link',
                src: url,
                metadata: {
                    domain: domain,
                    isSecure: url.startsWith('https://'),
                    favicon: `https://www.google.com/s2/favicons?domain=${domain}&sz=32`
                }
            };
        }

        function transformToMediaNode(node, type, src, metadata = {}) {
            node.isMediaNode = true;
            node.mediaType = type;
            node.mediaSrc = src;
            node.mediaMetadata = metadata;
            
            // If it was another special type, reset it
            node.isListNode = false;
            node.isExpanded = false;

            updateGraph();
            simulation.alpha(0.05).restart();
        }

        // Helper function to add a single list item element
        function addListItemElement(listContainer, item, index, nodeData, textColor) {
            const itemDiv = listContainer.append('xhtml:div')
                .attr('data-list-index', index)
                .style('display', 'flex')
                .style('align-items', 'flex-start')
                .style('font-size', '10pt')
                .style('line-height', '1.1')
                .style('min-height', '14px')
                .style('opacity', 0); // Start invisible for smooth fade-in
            
            if (nodeData.listType === 'bullet') {
                itemDiv.append('xhtml:span')
                    .style('margin-right', '6px')
                    .style('margin-top', '1px')
                    .style('color', textColor)
                    .style('font-weight', 'bold')
                    .style('flex-shrink', '0')
                    .style('font-size', '10pt')
                    .text('‚Ä¢');
            } else if (nodeData.listType === 'numbered') {
                itemDiv.append('xhtml:span')
                    .style('margin-right', '6px')
                    .style('margin-top', '1px')
                    .style('color', textColor)
                    .style('font-weight', '500')
                    .style('flex-shrink', '0')
                    .style('min-width', '14px')
                    .style('font-size', '10pt')
                    .text((index + 1) + '.');
            } else if (nodeData.listType === 'task') {
                itemDiv.append('xhtml:input')
                    .attr('type', 'checkbox')
                    .style('margin-right', '6px')
                    .style('margin-top', '2px')
                    .style('flex-shrink', '0')
                    .style('width', '12px')
                    .style('height', '12px')
                    .property('checked', item.checked)
                    .on('change', function() { item.checked = this.checked; })
                    .on('click', event => event.stopPropagation());
            }
            
            itemDiv.append('xhtml:span')
                .attr('class', 'list-item-text')
                .style('flex-grow', '1')
                .style('color', textColor)
                .style('word-wrap', 'break-word')
                .attr('contenteditable', true)
                .text(item.text)
                .on('mousedown', event => event.stopPropagation())
                .on('keydown', function(event) { 
                    if (event.key === 'Enter') { 
                        event.preventDefault(); 
                        
                        // Check if cursor is at the end of the text
                        const selection = window.getSelection();
                        const range = selection.getRangeAt(0);
                        const textContent = this.textContent;
                        const cursorPosition = range.startOffset;
                        
                        if (cursorPosition === textContent.length) {
                            // Cursor is at the end - create a new bullet point
                            nodeData.listItems.push({
                                text: '',
                                checked: nodeData.listType === 'task' ? false : undefined,
                                id: Date.now()
                            });
                            
                            // Update the graph to show the new item
                            updateGraph();
                            
                            // Focus on the new item after a brief delay
                            setTimeout(() => {
                                const listNode = nodeGroup.selectAll('.node').filter(n => n.id === nodeData.id);
                                const newItemText = listNode.select('.list-items-container')
                                    .selectAll('.list-item-text')
                                    .nodes()[nodeData.listItems.length - 1];
                                
                                if (newItemText) {
                                    newItemText.focus();
                                    // Place cursor at the beginning of the new item
                                    const range = document.createRange();
                                    const sel = window.getSelection();
                                    range.setStart(newItemText, 0);
                                    range.collapse(true);
                                    sel.removeAllRanges();
                                    sel.addRange(range);
                                }
                            }, 50);
                        } else {
                            // Cursor is not at the end - just blur (exit editing)
                            this.blur(); 
                        }
                    } 
                    event.stopPropagation(); 
                })
                .on('blur', function() { 
                    item.text = this.innerText; 
                })
                .on('click', function(event) { 
                    event.stopPropagation();
                    // Enter list adding mode when clicking on list item text
                    isListEntryMode = true;
                    activeListNode = nodeData;
                    selectedNode = nodeData;
                    updateUserInstruction(`Adding items to list "${nodeData.name}" ‚Ä¢ Enter to add item ‚Ä¢ Shift+Enter for child node`);
                    nodeInput.focus();
                    
                    // Update UI to show the node as selected
                    nodeGroup.selectAll('.node').classed('selected', false);
                    nodeGroup.selectAll('.node').filter(n => n.id === nodeData.id).classed('selected', true);
                    
                    // Show action buttons
                    summarizeBtn.style.display = 'inline-block';
                    elaborateBtn.style.display = 'inline-block';
                });
            
            // Smooth fade-in for new items
            itemDiv.transition()
                .duration(300)
                .style('opacity', 1);
        }
    </script>
</body>
</html>
