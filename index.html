/* Version: 1751007550 */
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CogniFlow - The LLM-Powered Idea Synthesizer</title>
    <link rel="icon" href="data:,">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/svg-to-pdfkit@0.1.8/source.min.js"></script>
    <style>
        :root {
            /* Base UI Variables */
            --ui-bg-dark: #0d0d0d;
            --ui-input-bg-dark: #2c2c2c;
            --ui-border-dark: #444444;
            --ui-text-dark: #e0e0e0;
            --ui-focus-dark: #e58d47;
            --ui-focus-glow: rgba(229, 141, 71, 0.7);
            
            /* Dynasty Theme Variables */
            --canvas-bg: #0D1117;
            --central-node-color: #30363D;
            --font-heading: 'Roboto', sans-serif;
            --font-subheading: 'Roboto', sans-serif;
            --font-body: 'Roboto', sans-serif;
            --gradient-intensity: 0.1;
            --shadow-blur: 20px;
            --shadow-opacity: 0.3;
            --transition-speed: 0.6s;
        }

        body {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            transition: background-color 1.5s ease-in-out;
            padding-bottom: 120px;
        }

        #mindmap-container { flex-grow: 1; position: relative; background: transparent; }
        svg { display: block; width: 100%; height: 100%; }
        
        .link {
            fill: none;
            stroke-opacity: 0.6;
            stroke-width: 2.5px;
            stroke-linecap: round;
        }

        .node { cursor: pointer; }
        .node circle {
            stroke-width: 0;
            stroke: transparent;
            transition: stroke 0.6s, stroke-width 0.6s, filter 0.6s ease;
        }
        .node.selected circle {
            filter: drop-shadow(0 0 12px rgba(255, 255, 255, 0.4)) !important;
        }
        .node.drop-target circle {
            stroke-width: 4px;
            stroke: #66ff77; /* A bright green to indicate a valid drop target */
            stroke-dasharray: 4;
            animation: drop-target-dash 1s linear infinite;
        }
        .node.flashing circle {
            animation: flash 1s ease-out;
        }

        .node text {
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: central;
            font-weight: 500;
            transition: fill 1.5s ease-in-out;
            fill: #FFFFFF;
        }
        
        #bottom-panel {
            height: auto;
            max-height: 33vh;
            min-height: 120px;
            resize: vertical;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            background-color: var(--ui-bg-dark);
            color: var(--ui-text-dark);
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            position: fixed;
            left: 0;
            right: 0;
            bottom: 0;
            margin-bottom: 60px;
            z-index: 99;
            border-top: 2px solid rgba(255,255,255,0.08);
            box-shadow: 0 -4px 24px rgba(0,0,0,0.25);
        }

        #bottom-panel:hover {
            max-height: 70vh;
            min-height: 200px;
            box-shadow: 0 -12px 32px rgba(0, 0, 0, 0.35);
            border-top: 2px solid rgba(255, 255, 255, 0.15);
        }

        #assistant-messages {
            flex: 1 1 auto;
            padding: 0.75rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-height: 28vh;
            min-height: 60px;
            transition: max-height 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        #bottom-panel:hover #assistant-messages {
            max-height: 60vh;
            min-height: 120px;
        }

        .assistant-message {
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
            padding: 0.5rem;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.03);
        }

        .assistant-avatar {
            display: none;
        }

        .assistant-content {
            flex-grow: 1;
        }

        .assistant-name {
            font-weight: 600;
            color: var(--ui-focus-dark);
            font-size: 0.8rem;
            margin-bottom: 0.2rem;
        }

        .assistant-text {
            color: var(--ui-text-dark);
            line-height: 1.4;
            font-size: 0.8rem;
            white-space: pre-line;
        }

        .assistant-suggestions {
            margin-top: 0.3rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.3rem;
        }

        .suggestion-chip {
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            background-color: var(--ui-input-bg-dark);
            border: none;
            color: var(--ui-text-dark);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .suggestion-chip:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }



        #user-controls {
            position: fixed;
            left: 0;
            bottom: 0;
            width: 100vw;
            z-index: 100;
            background: var(--ui-bg-dark);
            border-top: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 -2px 12px rgba(0,0,0,0.2);
            transition: none !important;
        }

        /* Flow Assistant Insights Styling */
        .flow-insights {
            margin-top: 0.75rem;
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
        }

        .flow-insight {
            background-color: #2c2c2c;
            border-radius: 8px;
            padding: 0.75rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .flow-insight:hover {
            background-color: #363636;
            transform: translateY(-1px);
        }

        .flow-insight.expanded {
            background-color: #404040;
        }

        /* Enhanced styling for different insight types */
        .flow-insight.keyword-suggestion {
            border-left: 4px solid #e58d47;
        }

        .flow-insight.keyword-suggestion:hover {
            border-left-color: #ff9d57;
        }

        .flow-insight.probing-question {
            border-left: 4px solid #6a9fdf;
        }

        .flow-insight.probing-question:hover {
            border-left-color: #7aafef;
        }

        .flow-insight.overview-card {
            border-left: 4px solid #8abfff;
        }

        .flow-insight.overview-card:hover {
            border-left-color: #9acfff;
        }

        .flow-insight.connection-insight {
            border-left: 4px solid #7aa36a;
        }

        .flow-insight.connection-insight:hover {
            border-left-color: #8ab37a;
        }

        .flow-insight.gap-insight {
            border-left: 4px solid #ffaf7a;
        }

        .flow-insight.gap-insight:hover {
            border-left-color: #ffbf8a;
        }

        .flow-insight.structural-suggestion {
            border-left: 4px solid #aa9acd;
        }

        .flow-insight.structural-suggestion:hover {
            border-left-color: #baaadd;
        }

        .insight-title {
            font-weight: 500;
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.8rem;
            margin-bottom: 0.3rem;
            line-height: 1.2;
        }

        .insight-preview {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.75rem;
            line-height: 1.3;
            font-style: italic;
        }

        .insight-full {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.75rem;
            line-height: 1.4;
        }

        .insight-full ul {
            margin: 0.5rem 0;
            padding-left: 1.2rem;
        }

        .insight-full li {
            margin: 0.3rem 0;
            line-height: 1.3;
        }

        .insight-full strong {
            color: rgba(255, 255, 255, 0.9);
        }

        #user-instructions {
            padding: 0.5rem 1rem;
        }

        .instruction-text {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.85rem;
            opacity: 0.8;
            text-align: center;
            font-weight: 400;
            font-style: italic;
        }

        #input-container {
            padding: 1rem;
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        #node-input {
            flex-grow: 1;
            padding: 0.75rem;
            border-radius: 8px;
            border: none;
            outline: none;
            background-color: var(--ui-input-bg-dark);
            color: var(--ui-text-dark);
        }

        .ai-button {
            padding: 0.75rem 1rem;
            border-radius: 8px;
            border: none;
            background-color: var(--ui-input-bg-dark);
            color: var(--ui-text-dark);
            cursor: pointer;
            white-space: nowrap;
            transition: background-color 0.2s;
            display: none;
        }
        .ai-button:hover {
            background-color: var(--ui-focus-dark);
        }
        
        .suggestion-container {
            align-self: flex-start;
            width: 100%;
            padding: 0.5rem;
            border-radius: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .suggestion-node {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            border-radius: 20px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .suggestion-node:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        .suggestion-node .plus-icon {
            font-weight: bold;
        }
        
         .ai-response-bubble {
            align-self: flex-start;
            max-width: 80%;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            background-color: var(--ui-input-bg-dark);
        }
        .ai-response-bubble h3 {
            font-weight: bold;
            margin-bottom: 0.25rem;
            color: var(--ui-focus-dark);
        }

        .loading-indicator {
            position: absolute;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            display: none;
            z-index: 1000;
        }

        .theme-selector {
            position: absolute;
            top: 1rem;
            right: 1rem;
            z-index: 1000;
        }

        #theme-dropdown {
            background-color: var(--ui-input-bg-dark);
            color: var(--ui-text-dark);
            border: none;
            border-radius: 8px;
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            cursor: pointer;
            outline: none;
            transition: background-color 0.2s;
            backdrop-filter: blur(10px);
            background: rgba(44, 44, 44, 0.85);
        }

        #theme-dropdown:hover {
            background-color: var(--ui-focus-dark);
        }

        #theme-dropdown option {
            background-color: var(--ui-input-bg-dark);
            color: var(--ui-text-dark);
        }

        .ai-controls {
            position: absolute;
            top: 1rem;
            left: 1rem;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            backdrop-filter: blur(10px);
            background: rgba(44, 44, 44, 0.85);
            border-radius: 8px;
            padding: 0.5rem;
        }

        .model-status {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--ui-text-dark);
        }

        #current-model {
            background: var(--ui-focus-dark);
            color: white;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-size: 0.7rem;
        }

        .usage-indicator {
            width: 40px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            overflow: hidden;
        }

        .usage-indicator::after {
            content: '';
            display: block;
            height: 100%;
            background: var(--ui-focus-dark);
            width: var(--usage-percent, 0%);
            transition: width 0.3s ease;
        }

        .ai-control-btn {
            background: var(--ui-input-bg-dark);
            color: var(--ui-text-dark);
            border: none;
            border-radius: 6px;
            padding: 0.4rem;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ai-control-btn:hover {
            background: var(--ui-focus-dark);
            transform: scale(1.05);
        }

        .ai-control-btn.active {
            background: var(--ui-focus-dark);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .expanded-node-container {
            border-radius: 16px;
            padding: 1rem;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            backdrop-filter: blur(5px);
        }

        .expanded-node-container h2 {
            font-size: 1.2rem;
            font-weight: bold;
            margin: 0;
            padding: 0;
            text-align: center;
            cursor: text;
        }
        
        .expanded-node-container textarea {
            flex-grow: 1;
            border: 1px solid transparent;
            border-radius: 8px;
            padding: 0.5rem;
            resize: none;
            outline: none;
            transition: border-color 0.6s ease;
        }

        .notes-editor {
            flex-grow: 1;
            overflow-y: auto;
            outline: none;
            padding: 0.5rem;
            border-radius: 8px;
            transition: border-color 0.2s, box-shadow 0.2s;
            border: 1px solid transparent;
        }

        .notes-editor:focus {
            border-color: rgba(255, 255, 255, 0.6);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.4);
        }

        .ai-actions-container {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            align-items: center;
            flex-grow: 1;
            width: 100%;
        }

        .ai-action-btn {
            padding: 4px 8px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            width: 80%;
            text-align: center;
            font-size: 9pt;
            font-weight: 500;
            transition: opacity 0.2s ease;
        }

        .ai-action-btn:hover {
            opacity: 0.8;
        }

        @keyframes flash {
            0% { filter: drop-shadow(0 0 0px #ffffff); }
            50% { filter: drop-shadow(0 0 12px #ffffff); }
            100% { filter: drop-shadow(0 0 0px #ffffff); }
        }

        @keyframes drop-target-dash {
            to {
                stroke-dashoffset: -8;
            }
        }

        @keyframes breathe {
            0%, 100% {
                transform: scale(1);
                opacity: 0.85;
            }
            50% {
                transform: scale(1.05);
                opacity: 0.95;
            }
        }

        /* Remove default browser outline on contenteditable elements */
        [contenteditable="true"]:focus {
            outline: none;
        }

        /* Interactive Flow Assistant Styles */
        .flow-term {
            background: rgba(138, 191, 255, 0.1);
            border-radius: 3px;
            padding: 1px 3px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .flow-term:hover {
            background: rgba(138, 191, 255, 0.2);
            border: 1px solid rgba(138, 191, 255, 0.4);
            transform: translateY(-1px);
        }

        .flow-term.dragging {
            opacity: 0.7;
            transform: scale(0.95);
        }

        .flow-sentence {
            background: rgba(229, 141, 71, 0.1);
            border-radius: 3px;
            padding: 2px 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
            display: inline-block;
            margin: 1px;
        }

        .flow-sentence:hover {
            background: rgba(229, 141, 71, 0.2);
            border: 1px solid rgba(229, 141, 71, 0.4);
            transform: translateY(-1px);
        }

        .flow-sentence.dragging {
            opacity: 0.7;
            transform: scale(0.95);
        }

        .node.drop-target-notes {
            stroke: #66ff77;
            stroke-width: 3px;
            stroke-dasharray: 5,5;
            animation: pulse-green 1s infinite;
        }

        @keyframes pulse-green {
            0%, 100% { stroke-opacity: 0.5; }
            50% { stroke-opacity: 1; }
        }

        .drag-preview {
            position: fixed;
            background: rgba(138, 191, 255, 0.9);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 10000;
            max-width: 200px;
            word-wrap: break-word;
        }

        /* Ghost Node Styles */
        .ghost-node {
            pointer-events: all;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .ghost-node:hover {
            opacity: 0.8;
            transform: scale(1.05);
        }

        .ghost-node circle {
            fill: rgba(229, 141, 71, 0.2);
            stroke: #e58d47;
            stroke-width: 2;
            stroke-dasharray: 5,5;
            animation: breathe 2s infinite;
        }

        .ghost-node text {
            fill: #e58d47;
            font-size: 10px;
            font-weight: 500;
            text-anchor: middle;
            dominant-baseline: central;
        }

        /* Information Card Styles */
        .info-card {
            background: rgba(255, 255, 255, 0.04);
            border-radius: 8px;
            padding: 12px;
            margin: 8px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-section {
            margin-bottom: 12px;
        }

        .info-section h4 {
            margin: 0 0 6px 0;
            color: #8abfff;
            font-size: 12px;
            font-weight: 600;
        }

        .info-section p {
            margin: 0;
            font-size: 11px;
            line-height: 1.4;
            color: rgba(255, 255, 255, 0.8);
        }

        .info-section ul {
            margin: 0;
            padding-left: 16px;
            font-size: 11px;
        }

        .info-section li {
            margin-bottom: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .info-section li:hover {
            color: #e58d47;
            transform: translateX(2px);
        }

        /* Flow Assistant Content Styles */
        .key-info-section {
            margin-top: 10px;
        }

        .info-card {
            margin: 8px 0;
            padding: 8px;
            background: rgba(255, 255, 255, 0.04);
            border-radius: 6px;
        }

        .info-title {
            font-weight: bold;
            color: #8abfff;
            margin-bottom: 4px;
        }

        .info-summary {
            line-height: 1.4;
            margin-bottom: 4px;
        }

        .key-points {
            margin: 4px 0 0 16px;
            padding-left: 0;
        }

        .info-source {
            font-size: 80%;
            color: #888;
            margin-top: 2px;
            font-style: italic;
        }

        .probing-question {
            margin-top: 12px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.02);
            border-left: 3px solid #8abfff;
            border-radius: 4px;
        }

        .keyword-suggestion {
            margin-top: 8px;
        }

        .keyword-highlight {
            color: #e58d47;
        }

        .ghost-suggestions {
            margin-top: 10px;
        }

        .ghost-node-suggestion {
            color: #e58d47;
            font-weight: bold;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 3px;
            transition: all 0.2s;
        }

        .ghost-node-suggestion:hover {
            background: rgba(229, 141, 71, 0.2);
        }

        .structural-tip {
            margin-top: 10px;
        }

        .tip-highlight {
            color: #aa9acd;
        }

        /* Smooth typing animation styles */
        [id^="typing-content-"] {
            position: relative;
        }

        [id^="typing-content-"]:not(.typing-complete)::after {
            content: '|';
            animation: blink 0.6s infinite; /* Reduced from 1s to 0.6s for faster cursor blink */
            color: var(--ui-focus-dark);
            font-weight: bold;
        }

        [id^="typing-content-"].typing-complete::after {
            display: none;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        /* Enhanced assistant message styling */
        .assistant-message {
            animation: fadeInUp 0.15s ease-out; /* Reduced from 0.3s to 0.15s for faster appearance */
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Formatting for structured content */
        .assistant-text br {
            margin-bottom: 0.2rem;
        }

        .assistant-text .section {
            margin-bottom: 0.8rem;
        }
    </style>
</head>
<body>

    <div id="mindmap-container">
        <svg id="mindmap-svg"></svg>
        <div id="loading-indicator" class="loading-indicator">CogniFlow is thinking...</div>
        
        <!-- Theme Selector -->
        <div id="theme-selector" class="theme-selector">
            <select id="theme-dropdown">
                <option value="Cosmic Ocean">Cosmic Ocean</option>
                <option value="Bioluminescence">Bioluminescence</option>
                <option value="Solar Flare">Solar Flare</option>
                <option value="Terra">Terra</option>
                <option value="Stardust">Stardust</option>
                <option value="Digital Retro">Digital Retro</option>
                <option value="Crimson Dusk">Crimson Dusk (Legacy)</option>
            </select>
        </div>
        
        <!-- AI System Status & Controls -->
        <div id="ai-controls" class="ai-controls">
            <div id="model-status" class="model-status">
                <span id="current-model">FLASH</span>
                <div id="usage-indicator" class="usage-indicator"></div>
            </div>
            <button id="toggle-background" class="ai-control-btn" title="Toggle background AI updates">
                🔄
            </button>
        </div>
    </div>
    
    <div id="bottom-panel">
        <!-- LLM Assistant Messages Area (Top) -->
        <div id="assistant-messages">
            <div id="assistant-welcome" class="assistant-message">
                <div class="assistant-content">
                    <div class="assistant-name">🌊 Flow Assistant</div>
                    <div class="assistant-text">Enhanced AI-powered insights with interactive information cards. Click any node to see structured insights, definitions, and suggestions. Drag highlighted terms to create new nodes or add to notes.</div>
            </div>
        </div>
        </div>
        
        <!-- User Instructions & Controls Area (Bottom, now fixed and outside bottom-panel) -->
        <div id="user-controls">
            <div id="user-instructions">
                <div id="current-instruction" class="instruction-text">Click to create your central idea</div>
            </div>
        <div id="input-container">
                <input type="text" id="node-input" placeholder="">
            <button id="summarize-btn" class="ai-button">✨ Summarize</button>
            <button id="elaborate-btn" class="ai-button">✨ Elaborate</button>
            </div>
        </div>
    </div>

    <script type="module">
        // --- Setup ---
        const svg = d3.select("#mindmap-svg");

        // --- Add missing group containers for links and nodes ---
        const masterGroup = svg.append("g");
        const linkGroup = masterGroup.append("g").attr("class", "links");
        const nodeGroup = masterGroup.append("g").attr("class", "nodes");

        // --- Add missing theme state ---
        let currentTheme = 'Crimson Dusk';

        // --- Dynasty Theming System Configuration ---
        const dynastyThemes = {
            'Cosmic Ocean': {
                name: 'Cosmic Ocean',
                canvasBackground: '#0D1117',
                colors: {
                    centralNode: '#30363D',
                    palette: ['#58A6FF', '#1F6FEB', '#A371F7', '#D2A8FF', '#F0883E', '#E4C52E', '#3FB950']
                },
                fonts: {
                    heading: 'Lexend',
                    subheading: 'Poppins',
                    body: 'Inter'
                },
                effects: {
                    gradientIntensity: 0.15,
                    shadowBlur: 30,
                    shadowOpacity: 0.4
                }
            },
            'Bioluminescence': {
                name: 'Bioluminescence',
                canvasBackground: '#010409',
                colors: {
                    centralNode: '#21262D',
                    palette: ['#7EE787', '#238636', '#A9D5FF', '#218BFF', '#F8C775', '#BF8700', '#FF8DC7']
                },
                fonts: {
                    heading: 'Poppins',
                    subheading: 'Nunito',
                    body: 'Nunito'
                },
                effects: {
                    gradientIntensity: 0.2,
                    shadowBlur: 25,
                    shadowOpacity: 0.5
                }
            },
            'Solar Flare': {
                name: 'Solar Flare',
                canvasBackground: '#160B0B',
                colors: {
                    centralNode: '#2C1D1D',
                    palette: ['#F97583', '#E92239', '#FFA657', '#F0883E', '#FFD16E', '#E4C52E', '#F6F8FA']
                },
                fonts: {
                    heading: 'Montserrat',
                    subheading: 'Bitter',
                    body: 'Source Sans Pro'
                },
                effects: {
                    gradientIntensity: 0.25,
                    shadowBlur: 35,
                    shadowOpacity: 0.6
                }
            },
            'Terra': {
                name: 'Terra',
                canvasBackground: '#0C140D',
                colors: {
                    centralNode: '#242E25',
                    palette: ['#56D364', '#B3E5BE', '#A371F7', '#BF87FF', '#F8C775', '#EAC54F', '#FF8DC7']
                },
                fonts: {
                    heading: 'Quattrocento',
                    subheading: 'Exo',
                    body: 'Martel Sans'
                },
                effects: {
                    gradientIntensity: 0.18,
                    shadowBlur: 28,
                    shadowOpacity: 0.45
                }
            },
            'Stardust': {
                name: 'Stardust',
                canvasBackground: '#110D17',
                colors: {
                    centralNode: '#2A2135',
                    palette: ['#D2A8FF', '#A371F7', '#F97583', '#E92239', '#58A6FF', '#1F6FEB', '#E4C52E']
                },
                fonts: {
                    heading: 'Lora',
                    subheading: 'Montserrat',
                    body: 'Hind Madurai'
                },
                effects: {
                    gradientIntensity: 0.22,
                    shadowBlur: 32,
                    shadowOpacity: 0.55
                }
            },
            'Digital Retro': {
                name: 'Digital Retro',
                canvasBackground: '#0A0A0A',
                colors: {
                    centralNode: '#2E2E2E',
                    palette: ['#6AF293', '#2BFF71', '#79C0FF', '#0094FF', '#F487C4', '#FF33A1', '#F2BE5C']
                },
                fonts: {
                    heading: 'Lalezar',
                    subheading: 'Rubik',
                    body: 'Fira Code'
                },
                effects: {
                    gradientIntensity: 0.3,
                    shadowBlur: 40,
                    shadowOpacity: 0.7
                }
            },
            // Legacy theme mapping for backward compatibility
            'Crimson Dusk': {
                name: 'Crimson Dusk',
                canvasBackground: '#0D1117',
                colors: {
                    centralNode: '#30363D',
                    palette: ['#58A6FF', '#1F6FEB', '#A371F7', '#D2A8FF', '#F0883E', '#E4C52E', '#3FB950']
                },
                fonts: {
                    heading: 'Roboto',
                    subheading: 'Roboto',
                    body: 'Roboto'
                },
                effects: {
                    gradientIntensity: 0.1,
                    shadowBlur: 20,
                    shadowOpacity: 0.3
                }
            }
        };

        // Dynasty palettes for node color inheritance
        let dynastyPalettes = [];
        let firstGenPaletteAssignment = new Map();
        let loadedFonts = new Set();
        
        // Color generation helper functions for dynasty inheritance
        function shiftHue(color, amount) {
            const hsl = d3.hsl(color);
            hsl.h = (hsl.h + amount) % 360;
            return hsl.toString();
        }
        
        function adjustSaturation(color, amount) {
            const hsl = d3.hsl(color);
            hsl.s = Math.max(0, Math.min(1, hsl.s + amount));
            return hsl.toString();
        }
        
        function generateDynastyPalettes(theme) {
            // Start with the base palette from the theme
            const basePalette = theme.colors.palette;
            
            // Create 3 dynasty palettes with different color characteristics
            const dynasties = [];
            
            // First dynasty: Original palette
            dynasties.push([...basePalette]);
            
            // Second dynasty: Hue shifted palette (+30 degrees)
            dynasties.push(basePalette.map(color => shiftHue(color, 30)));
            
            // Third dynasty: Hue shifted in opposite direction (-30 degrees)
            dynasties.push(basePalette.map(color => shiftHue(color, -30)));
            
            // Fourth dynasty: Higher saturation palette
            dynasties.push(basePalette.map(color => adjustSaturation(color, 0.15)));
            
            return dynasties;
        }

        // Theme validation function
        function validateTheme(theme) {
            const required = ['name', 'canvasBackground', 'colors', 'fonts', 'effects'];
            const colorRequired = ['centralNode', 'palette'];
            const fontRequired = ['heading', 'subheading', 'body'];
            const effectRequired = ['gradientIntensity', 'shadowBlur', 'shadowOpacity'];
            
            for (const prop of required) {
                if (!theme[prop]) {
                    console.error(`Theme missing required property: ${prop}`);
                    return false;
                }
            }
            
            for (const prop of colorRequired) {
                if (!theme.colors[prop]) {
                    console.error(`Theme colors missing required property: ${prop}`);
                    return false;
                }
            }
            
            for (const prop of fontRequired) {
                if (!theme.fonts[prop]) {
                    console.error(`Theme fonts missing required property: ${prop}`);
                    return false;
                }
            }
            
            for (const prop of effectRequired) {
                if (theme.effects[prop] === undefined) {
                    console.error(`Theme effects missing required property: ${prop}`);
                    return false;
                }
            }
            
            if (!Array.isArray(theme.colors.palette) || theme.colors.palette.length === 0) {
                console.error('Theme palette must be a non-empty array');
                return false;
            }
            
            return true;
        }

        // Initialize dynasty palettes from current theme
        function initializeDynastyPalettes() {
            const theme = dynastyThemes[currentTheme];
            if (theme && validateTheme(theme)) {
                // Generate multiple dynasty palettes with different color characteristics
                dynastyPalettes = generateDynastyPalettes(theme);
                console.log('Dynasty palettes initialized:', dynastyPalettes);
            } else {
                console.error('Failed to initialize dynasty palettes, using fallback');
                // Fallback to a single palette if theme validation fails
                dynastyPalettes = [['#58A6FF', '#1F6FEB', '#A371F7', '#D2A8FF', '#F0883E', '#E4C52E', '#3FB950']];
            }
        }

        // Initialize dynasty system
        initializeDynastyPalettes();

        // Theme switching and application functions
        async function loadThemeFonts(themeName) {
            const theme = dynastyThemes[themeName];
            if (!theme || !validateTheme(theme)) {
                console.error('Invalid theme for font loading:', themeName);
                return;
            }

            const fontsToLoad = [theme.fonts.heading, theme.fonts.subheading, theme.fonts.body];
            const uniqueFonts = [...new Set(fontsToLoad)].filter(font => !loadedFonts.has(font));
            
            if (uniqueFonts.length === 0) {
                console.log('All fonts already loaded for theme:', themeName);
                return;
            }

            try {
                // Create Google Fonts link
                const fontFamilies = uniqueFonts.map(font => font.replace(/\s+/g, '+')).join('|');
                const fontLink = document.createElement('link');
                fontLink.href = `https://fonts.googleapis.com/css2?family=${fontFamilies}:wght@400;500;600;700&display=swap`;
                fontLink.rel = 'stylesheet';
                
                // Add to document head
                document.head.appendChild(fontLink);
                
                // Wait for fonts to load
                await new Promise((resolve, reject) => {
                    fontLink.onload = () => {
                        uniqueFonts.forEach(font => loadedFonts.add(font));
                        console.log('Fonts loaded successfully:', uniqueFonts);
                        resolve();
                    };
                    fontLink.onerror = () => {
                        console.warn('Failed to load fonts, using fallbacks:', uniqueFonts);
                        resolve(); // Don't reject, just use fallbacks
                    };
                    
                    // Timeout after 5 seconds
                    setTimeout(() => {
                        console.warn('Font loading timeout, using fallbacks');
                        resolve();
                    }, 5000);
                });
            } catch (error) {
                console.warn('Error loading fonts:', error);
            }
        }

        function applyTheme(themeName = currentTheme) {
            const theme = dynastyThemes[themeName];
            if (!theme || !validateTheme(theme)) {
                console.error('Invalid theme:', themeName);
                return;
            }

            const root = document.documentElement;
            
            // Apply canvas background
            document.body.style.backgroundColor = theme.canvasBackground;
            root.style.setProperty('--canvas-bg', theme.canvasBackground);
            
            // Apply font variables
            root.style.setProperty('--font-heading', `'${theme.fonts.heading}', sans-serif`);
            root.style.setProperty('--font-subheading', `'${theme.fonts.subheading}', sans-serif`);
            root.style.setProperty('--font-body', `'${theme.fonts.body}', sans-serif`);
            
            // Apply effect variables
            root.style.setProperty('--gradient-intensity', theme.effects.gradientIntensity);
            root.style.setProperty('--shadow-blur', `${theme.effects.shadowBlur}px`);
            root.style.setProperty('--shadow-opacity', theme.effects.shadowOpacity);
            
            // Apply central node color
            root.style.setProperty('--central-node-color', theme.colors.centralNode);
            
            // Update dynasty palettes with multiple color variations
            dynastyPalettes = generateDynastyPalettes(theme);
            
            console.log('Theme applied:', themeName);
        }

        async function switchTheme(themeName) {
            if (!dynastyThemes[themeName]) {
                console.error('Theme not found:', themeName);
                return;
            }

            try {
                // Load fonts first
                await loadThemeFonts(themeName);
                
                // Apply theme
                currentTheme = themeName;
                applyTheme(themeName);
                
                // Update dropdown
                const themeDropdown = document.getElementById('theme-dropdown');
                if (themeDropdown) {
                    themeDropdown.value = themeName;
                }
                
                // Reinitialize dynasty palettes
                initializeDynastyPalettes();
                
                // Update existing nodes if any
                if (nodes.length > 0) {
                    updateGraph();
                }
                
                console.log('Theme switched successfully to:', themeName);
            } catch (error) {
                console.error('Error switching theme:', error);
            }
        }

        const assistantMessages = document.getElementById('assistant-messages');
        const currentInstruction = document.getElementById('current-instruction');
        const nodeInput = document.getElementById('node-input');
        const summarizeBtn = document.getElementById('summarize-btn');
        const elaborateBtn = document.getElementById('elaborate-btn');
        const loadingIndicator = document.getElementById('loading-indicator');
        const container = document.getElementById('mindmap-container');
        
        let nodes = [];
        let links = [];
        let nextId = 0;
        let selectedNode = null;
        let isPrimedForChild = false;
        let activeExpandedNode = null;
        let historyStack = [];
        let isDragging = false;
        let isListEntryMode = false;
        let activeListNode = null;
        let dropTargetNode = null;

        // --- D3 Force Simulation Initialization ---
        let simulation = d3.forceSimulation()
            .force("link", d3.forceLink().id(d => d.id).distance(120).strength(0.5))
            .force("charge", d3.forceManyBody().strength(-420))
            .force("center", d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2))
            .force("collision", d3.forceCollide().radius(d => d.radius ? d.radius + 12 : 32).strength(0.9));
        
        // --- LM Studio Local API Configuration ---
        // Using Google Gemma 3 4B model via LM Studio as per v8.3 spec
        const LM_STUDIO_BASE_URL = 'http://localhost:1234/v1';
        const LOCAL_MODEL_NAME = 'google/gemma-3-4b'; // Google Gemma 3 4B model
        
        // Google Search functionality removed - Flow Assistant now uses only local LLM knowledge
        
        // LM Studio model configuration (local, no rate limits needed)
        const LM_STUDIO_MODELS = {
            'deepseek': {
                url: `${LM_STUDIO_BASE_URL}/chat/completions`,
                model: LOCAL_MODEL_NAME,
                maxTokens: 2048,
                rateLimitDelay: 50, // Reduced from 100ms to 50ms for faster processing
                dailyLimit: 999999, // No limits for local model
                priority: 1
            }
        };
        
        // --- Flow Assistant App-Within-App System ---
        let flowAssistantActive = false;
        let currentWelcomeMessage = '';
        let lastCentralNode = null;
        let infoCardData = null;
        let conversationHistory = [];
        let completedActions = [];

        // Generate random welcome messages
        const welcomeMessages = [
            "🌊 Welcome to CogniFlow! I'm your AI assistant, ready to help you explore ideas. Click anywhere to start your mind map journey.",
            "🚀 Hello! I'm here to help you build and expand your thoughts. Let's create something amazing together - just click to begin.",
            "💡 Welcome! I'm your thinking partner. I'll provide insights, suggestions, and help you organize your ideas. Ready to start?",
            "🎯 Hi there! I'm your AI assistant, designed to help you think deeper and connect ideas. Click to create your first concept.",
            "🌟 Welcome to CogniFlow! I'm here to enhance your creative process with AI-powered insights and suggestions. Let's begin!",
            "🔮 Hello! I'm your intelligent assistant, ready to help you explore, expand, and organize your thoughts. Click to start mapping.",
            "⚡ Welcome! I'm here to accelerate your thinking with real-time insights and smart suggestions. Ready to create something great?",
            "🎨 Hi! I'm your creative AI partner. I'll help you visualize connections and discover new perspectives. Let's start building!"
        ];

        // Initialize Flow Assistant with random welcome
        function initializeFlowAssistant() {
            const randomWelcome = welcomeMessages[Math.floor(Math.random() * welcomeMessages.length)];
            currentWelcomeMessage = randomWelcome;
            
            const assistantMessages = document.getElementById('assistant-messages');
            assistantMessages.innerHTML = `
                <div class="assistant-message">
                    <div class="assistant-content">
                        <div class="assistant-name">🌊 Flow Assistant</div>
                        <div class="assistant-text">${randomWelcome}</div>
                    </div>
                </div>
            `;
            
            flowAssistantActive = true;
        }

        // Enhanced info card generation with clickable elements
        async function generateInteractiveInfoCard(node) {
            const contextData = buildFlowAssistantContext(node);
            if (!contextData) return;
            
            try {
                const raw = await callFlowAssistantAPI(contextData);
                if (!raw) {
                    showFlowAssistantError("Unable to generate insights. Please check LM Studio connection.");
                    return;
                }
                
                // Parse the response
                let cleanText = raw.trim();
                cleanText = cleanText.replace(/^```json[\s\n]*/i, '').replace(/^```[\s\n]*/i, '').replace(/```$/g, '').trim();
                
                try {
                    const parsed = JSON.parse(cleanText);
                    infoCardData = parsed;
                    displayInteractiveInfoCard(node, parsed);
                } catch (parseError) {
                    showFlowAssistantError("Unable to parse AI response. Please try again.");
                }
            } catch (error) {
                console.error('Flow Assistant API error:', error);
                showFlowAssistantError("Error generating insights. Please check your connection.");
            }
        }

        // Display interactive info card with clickable elements
        function displayInteractiveInfoCard(node, data) {
            const assistantMessages = document.getElementById('assistant-messages');
            const themeColor = getComputedStyle(document.documentElement).getPropertyValue('--ui-focus-dark');
            
            // Generate unique card ID
            const cardId = `card-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            
            let cardHTML = `
                <div class="assistant-message" id="${cardId}">
                    <div class="assistant-content">
                        <div class="assistant-name">🌊 Flow Assistant</div>
                        <div class="assistant-text">
                            <div class="info-card-header">
                                <h3>Insights for "${node.name}"</h3>
                            </div>
            `;
            
            // Process each section and make relevant parts clickable
            if (data.sections) {
                data.sections.forEach((section, index) => {
                    switch (section.type) {
                        case 'definition':
                            cardHTML += `
                                <div class="info-section">
                                    <h4>📚 Definition</h4>
                                    <p>${section.content}</p>
                                </div>
                            `;
                            break;
                            
                        case 'paragraph_info':
                            // Extract bold terms and make them clickable
                            const processedContent = section.content.replace(/\*\*(.*?)\*\*/g, 
                                `<span class="clickable-concept" data-action="create-child" data-text="$1" data-card-id="${cardId}" style="color: ${themeColor}; cursor: pointer; font-weight: bold; text-decoration: underline;">$1</span>`
                            );
                            cardHTML += `
                                <div class="info-section">
                                    <h4>💡 Key Information</h4>
                                    <p>${processedContent}</p>
                                </div>
                            `;
                            break;
                            
                        case 'bullet_points':
                            const bulletHTML = section.items.map(item => 
                                `<li class="clickable-bullet" data-action="add-to-notes" data-text="${item.replace(/"/g, '&quot;')}" data-card-id="${cardId}" style="color: ${themeColor}; cursor: pointer;">${item}</li>`
                            ).join('');
                            cardHTML += `
                                <div class="info-section">
                                    <h4>📋 More Details</h4>
                                    <ul>${bulletHTML}</ul>
                                </div>
                            `;
                            break;
                            
                        case 'question':
                            cardHTML += `
                                <div class="info-section">
                                    <h4>🤔 Think Deeper</h4>
                                    <p class="clickable-question" data-action="add-to-notes" data-text="${section.content.replace(/"/g, '&quot;')}" data-card-id="${cardId}" style="color: ${themeColor}; cursor: pointer; font-style: italic;">${section.content}</p>
                                </div>
                            `;
                            break;
                            
                        case 'structural_tip':
                            cardHTML += `
                                <div class="info-section">
                                    <h4>🏗️ Structure Tip</h4>
                                    <p>${section.content}</p>
                                </div>
                            `;
                            break;
                    }
                });
            }
            
            // Add proactive node suggestions as clickable buttons
            if (data.proactiveNodeSuggestions && data.proactiveNodeSuggestions.length > 0) {
                cardHTML += `
                    <div class="info-section">
                        <h4>💡 Explore These Ideas</h4>
                        <div class="suggestion-buttons">
                `;
                
                data.proactiveNodeSuggestions.forEach(suggestion => {
                    cardHTML += `
                        <button class="suggestion-btn" data-action="create-sibling" data-text="${suggestion}" data-card-id="${cardId}" style="background-color: ${themeColor}; color: white; border: none; padding: 4px 8px; margin: 2px; border-radius: 4px; cursor: pointer; font-size: 11px;">
                            ${suggestion}
                        </button>
                    `;
                });
                
                cardHTML += `
                        </div>
                    </div>
                `;
            }
            
            cardHTML += `
                        </div>
                    </div>
                </div>
            `;
            
            // Append new card instead of replacing
            assistantMessages.insertAdjacentHTML('beforeend', cardHTML);
            
            // Scroll to the new card
            const newCard = document.getElementById(cardId);
            if (newCard) {
                newCard.scrollIntoView({ behavior: 'smooth', block: 'end' });
            }
            
            // Add event listeners to clickable elements
            addClickableElementListeners();
            
            // Store card data for context
            conversationHistory.push({
                cardId: cardId,
                nodeName: node.name,
                nodeId: node.id,
                data: data,
                timestamp: Date.now()
            });
            
            // Clean up old cards if there are too many (keep last 8 cards)
            cleanupOldCards();
        }

        // Clean up old cards to keep interface clean
        function cleanupOldCards() {
            const assistantMessages = document.getElementById('assistant-messages');
            const cards = assistantMessages.querySelectorAll('.assistant-message');
            
            if (cards.length > 8) {
                // Remove oldest cards (except the first welcome message)
                const cardsToRemove = Array.from(cards).slice(1, cards.length - 7);
                cardsToRemove.forEach(card => {
                    card.style.opacity = '0';
                    card.style.transform = 'translateY(-20px)';
                    setTimeout(() => {
                        if (card.parentNode) {
                            card.parentNode.removeChild(card);
                        }
                    }, 300);
                });
            }
        }

        // Add event listeners to clickable elements
        function addClickableElementListeners() {
            // Clickable concepts (create child nodes)
            document.querySelectorAll('.clickable-concept').forEach(element => {
                element.addEventListener('click', function() {
                    const text = this.getAttribute('data-text');
                    const cardId = this.getAttribute('data-card-id');
                    if (selectedNode) {
                        const newNode = addNode(text, selectedNode);
                        if (newNode) {
                            // Mark action as completed
                            markActionCompleted(cardId, 'create-child', text, selectedNode.name);
                            
                            // Update the clicked element to show completion
                            this.style.opacity = '0.5';
                            this.style.textDecoration = 'line-through';
                            this.style.cursor = 'default';
                            this.removeEventListener('click', arguments.callee);
                            
                            handleNodeClick(null, newNode);
                            showFeedback(`Created child node: "${text}"`);
                            
                            // Generate new card for the new node
                            setTimeout(() => {
                                generateInteractiveInfoCard(newNode);
                            }, 300);
                        }
                    }
                });
            });
            
            // Clickable bullets (add to notes)
            document.querySelectorAll('.clickable-bullet').forEach(element => {
                element.addEventListener('click', function() {
                    const text = this.getAttribute('data-text');
                    const cardId = this.getAttribute('data-card-id');
                    if (selectedNode) {
                        if (!selectedNode.notes) selectedNode.notes = [];
                        selectedNode.notes.push(text);
                        updateGraph();
                        
                        // Mark action as completed
                        markActionCompleted(cardId, 'add-to-notes', text, selectedNode.name);
                        
                        // Update the clicked element to show completion
                        this.style.opacity = '0.5';
                        this.style.textDecoration = 'line-through';
                        this.style.cursor = 'default';
                        this.removeEventListener('click', arguments.callee);
                        
                        showFeedback(`Added to notes: "${text}"`);
                    }
                });
            });
            
            // Clickable questions (add to notes)
            document.querySelectorAll('.clickable-question').forEach(element => {
                element.addEventListener('click', function() {
                    const text = this.getAttribute('data-text');
                    const cardId = this.getAttribute('data-card-id');
                    if (selectedNode) {
                        if (!selectedNode.notes) selectedNode.notes = [];
                        selectedNode.notes.push(text);
                        updateGraph();
                        
                        // Mark action as completed
                        markActionCompleted(cardId, 'add-to-notes', text, selectedNode.name);
                        
                        // Update the clicked element to show completion
                        this.style.opacity = '0.5';
                        this.style.textDecoration = 'line-through';
                        this.style.cursor = 'default';
                        this.removeEventListener('click', arguments.callee);
                        
                        showFeedback(`Added question to notes: "${text}"`);
                    }
                });
            });
            
            // Suggestion buttons (create sibling nodes)
            document.querySelectorAll('.suggestion-btn').forEach(element => {
                element.addEventListener('click', function() {
                    const text = this.getAttribute('data-text');
                    const cardId = this.getAttribute('data-card-id');
                    if (selectedNode) {
                        const parentLink = links.find(l => l.target.id === selectedNode.id);
                        const parent = parentLink ? parentLink.source : selectedNode;
                        const newNode = addNode(text, parent);
                        if (newNode) {
                            // Mark action as completed
                            markActionCompleted(cardId, 'create-sibling', text, selectedNode.name);
                            
                            // Update the clicked element to show completion
                            this.style.opacity = '0.5';
                            this.style.textDecoration = 'line-through';
                            this.style.cursor = 'default';
                            this.removeEventListener('click', arguments.callee);
                            
                            handleNodeClick(null, newNode);
                            showFeedback(`Created sibling node: "${text}"`);
                            
                            // Generate new card for the new node
                            setTimeout(() => {
                                generateInteractiveInfoCard(newNode);
                            }, 300);
                        }
                    }
                });
            });
        }

        // Show Flow Assistant error
        function showFlowAssistantError(message) {
            const assistantMessages = document.getElementById('assistant-messages');
            assistantMessages.innerHTML = `
                <div class="assistant-message">
                    <div class="assistant-content">
                        <div class="assistant-name">⚠️ Flow Assistant</div>
                        <div class="assistant-text">${message}</div>
                    </div>
                </div>
            `;
        }



        // Initialize Flow Assistant on page load
        document.addEventListener('DOMContentLoaded', function() {
            initializeFlowAssistant();
        });

        // Build context for Flow Assistant
        function buildFlowAssistantContext(node) {
            if (!node) return null;
            
            const context = {
                nodeName: node.name,
                nodeDepth: node.depth,
                nodeType: node.isListNode ? 'list' : node.isMediaNode ? 'media' : 'standard',
                parentNode: node.depth > 0 ? links.find(l => l.target.id === node.id)?.source?.name : null,
                siblingNodes: links.filter(l => l.source.id === (links.find(l => l.target.id === node.id)?.source?.id || node.id))
                    .map(l => l.target.name).filter(name => name !== node.name),
                childNodes: links.filter(l => l.source.id === node.id).map(l => l.target.name),
                notes: node.notes || [],
                listItems: node.isListNode ? node.listItems || [] : [],
                listType: node.isListNode ? node.listType : null,
                conversationHistory: conversationHistory.slice(-5), // Last 5 cards for context
                completedActions: completedActions.slice(-10) // Last 10 completed actions
            };
            
            return context;
        }

        // Mark action as completed
        function markActionCompleted(cardId, actionType, actionText, parentNodeName) {
            const completedAction = {
                cardId: cardId,
                actionType: actionType,
                actionText: actionText,
                parentNodeName: parentNodeName,
                timestamp: Date.now()
            };
            
            completedActions.push(completedAction);
            
            // Update the card to show completion status
            const card = document.getElementById(cardId);
            if (card) {
                // Add a subtle completion indicator
                const completionIndicator = document.createElement('div');
                completionIndicator.style.cssText = `
                    position: absolute;
                    top: 5px;
                    right: 5px;
                    background: #4CAF50;
                    color: white;
                    padding: 2px 6px;
                    border-radius: 10px;
                    font-size: 10px;
                    opacity: 0.8;
                `;
                completionIndicator.textContent = '✓ Done';
                card.style.position = 'relative';
                card.appendChild(completionIndicator);
            }
        }

        // Call Flow Assistant API
        async function callFlowAssistantAPI(contextData) {
            const model = getBestAvailableModel();
            if (!model) {
                console.error('No available model for Flow Assistant');
                return null;
            }

            const prompt = `You are an AI assistant helping a user explore ideas in a mind mapping tool. Analyze the following node and provide structured insights.

Node: "${contextData.nodeName}"
Depth: ${contextData.nodeDepth}
Type: ${contextData.nodeType}
${contextData.parentNode ? `Parent: "${contextData.parentNode}"` : ''}
${contextData.siblingNodes.length > 0 ? `Siblings: ${contextData.siblingNodes.join(', ')}` : ''}
${contextData.childNodes.length > 0 ? `Children: ${contextData.childNodes.join(', ')}` : ''}
${contextData.notes.length > 0 ? `Notes: ${contextData.notes.join('; ')}` : ''}
${contextData.listItems.length > 0 ? `List Items: ${contextData.listItems.map(item => item.text).join('; ')}` : ''}

${contextData.conversationHistory.length > 0 ? `Recent conversation context:
${contextData.conversationHistory.map(card => `- Card for "${card.nodeName}" (${new Date(card.timestamp).toLocaleTimeString()})`).join('\n')}` : ''}

${contextData.completedActions.length > 0 ? `Recently completed actions:
${contextData.completedActions.map(action => `- ${action.actionType}: "${action.actionText}" (from "${action.parentNodeName}")`).join('\n')}` : ''}

IMPORTANT: The user has been actively working with the mind map. Consider what they've already explored and completed. Provide fresh insights that build upon their previous work, avoiding suggestions they've already acted upon.

Provide a JSON response with the following structure:
{
  "sections": [
    {
      "type": "definition",
      "content": "Brief definition or explanation of the concept"
    },
    {
      "type": "paragraph_info",
      "content": "Key information about this concept with **bold terms** for important concepts"
    },
    {
      "type": "bullet_points",
      "items": ["Related aspect 1", "Related aspect 2", "Related aspect 3"]
    },
    {
      "type": "question",
      "content": "A thought-provoking question to explore this concept further"
    },
    {
      "type": "structural_tip",
      "content": "Suggestion for organizing related ideas"
    }
  ],
  "proactiveNodeSuggestions": ["Suggestion 1", "Suggestion 2", "Suggestion 3"]
}

Focus on providing actionable insights and suggestions that help the user expand their thinking, building upon their previous work.`;

            try {
                const response = await fetch(model.config.url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: model.config.model,
                        messages: [
                            {
                                role: 'system',
                                content: 'You are a helpful AI assistant that provides structured insights for mind mapping. Always respond with valid JSON.'
                            },
                            {
                                role: 'user',
                                content: prompt
                            }
                        ],
                        max_tokens: model.config.maxTokens,
                        temperature: 0.7,
                        stream: false
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                return data.choices[0].message.content;
            } catch (error) {
                console.error('Flow Assistant API call failed:', error);
                return null;
            }
        }

        // Show feedback message
        function showFeedback(message) {
            // Create a temporary feedback element
            const feedback = document.createElement('div');
            feedback.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: var(--ui-focus-dark);
                color: white;
                padding: 8px 12px;
                border-radius: 6px;
                font-size: 12px;
                z-index: 1000;
                opacity: 0;
                transform: translateY(-10px);
                transition: all 0.3s ease;
            `;
            feedback.textContent = message;
            document.body.appendChild(feedback);
            
            // Animate in
            setTimeout(() => {
                feedback.style.opacity = '1';
                feedback.style.transform = 'translateY(0)';
            }, 10);
            
            // Remove after 3 seconds
            setTimeout(() => {
                feedback.style.opacity = '0';
                feedback.style.transform = 'translateY(-10px)';
                setTimeout(() => {
                    document.body.removeChild(feedback);
                }, 300);
            }, 3000);
        }
        
        // Track usage per model (local model has no limits)
        let modelUsage = {
            'deepseek': { today: 0, lastReset: new Date().toDateString() }
        };
        
        // Get the best available model (always returns local DeepSeek model)
        function getBestAvailableModel(requestType = 'standard') {
            const today = new Date().toDateString();
            
            // Reset daily counters if new day (not really needed for local model)
            if (modelUsage.deepseek.lastReset !== today) {
                modelUsage.deepseek.today = 0;
                modelUsage.deepseek.lastReset = today;
            }
            
            // Always return the local DeepSeek model
            return { name: 'deepseek', config: LM_STUDIO_MODELS['deepseek'] };
        }
        
        // Enhanced rate limiting configuration
        let lastApiCall = {};  // Track per model
        let apiCallQueue = [];
        let isProcessingQueue = false;

        // --- Core Functions ---
        
        // Generate node style with gradients and shadows based on theme configuration
        function generateNodeStyle(color, depth) {
            const theme = dynastyThemes[currentTheme] || dynastyThemes['Cosmic Ocean'];
            const gradientIntensity = theme.effects.gradientIntensity || 0.15;
            const shadowBlur = theme.effects.shadowBlur || 20;
            const shadowOpacity = theme.effects.shadowOpacity || 0.3;
            
            // Create a brighter color for gradient
            const baseColor = d3.color(color);
            const brighterColor = d3.color(color).brighter(gradientIntensity * 2);
            
            // Create a darker color for gradient
            const darkerColor = d3.color(color).darker(gradientIntensity);
            
            // Create shadow color based on node color with adjusted opacity
            const shadowColor = d3.color(color);
            shadowColor.opacity = shadowOpacity;
            
            // Adjust shadow blur based on depth
            const depthAdjustedBlur = Math.max(5, shadowBlur - (depth * 4));
            
            return {
                backgroundColor: color,
                backgroundImage: `radial-gradient(circle at 30% 30%, ${brighterColor}, ${baseColor} 65%, ${darkerColor})`,
                boxShadow: `0 0 ${depthAdjustedBlur}px ${shadowColor}`,
                color: isColorTooBright(color) ? '#000000' : '#FFFFFF'
            };
        }
        
        function updateGraph() {
            // --- LINKS ---
            linkGroup.selectAll(".link")
                .data(links, d => `${d.source.id}-${d.target.id}`)
                .join("path")
                .attr("class", "link")
                .attr("stroke", d => d.source.color)
                .style("stroke-opacity", 0.5);

            // --- NODES (The General Update Pattern) ---
            const node = nodeGroup.selectAll(".node")
                .data(nodes, d => d.id);

            // Exit
            node.exit().transition().duration(800).attr("transform", "scale(0)").remove();

            // Enter
            const nodeEnter = node.enter().append("g")
                .attr("class", "node")
                .attr("transform", d => `translate(${d.x},${d.y})`)
                .on("dblclick", handleNodeDoubleClick)
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            nodeEnter.append("circle");
            
            nodeEnter.append("text");

            nodeEnter.append('foreignObject')
                .style('opacity', 0)
                .style('pointer-events', 'none');

            // Update
            const nodeUpdate = nodeEnter.merge(node)
                .classed('selected', d => d.id === selectedNode?.id);

            nodeUpdate.each(function(d) {
                const el = d3.select(this);
                const circle = el.select('circle');
                const text = el.select('text');
                const fo = el.select('foreignObject');

                // Remove the hamburger icon indicator completely

                // Calculate dimensions based on state - larger to accommodate ghost nodes
                const foWidth = Math.min(320, container.clientWidth * 0.32); // Larger width for ghost nodes
                // Height calculation with more space for ghost nodes
                const baseHeight = 40; // Header height
                const notesHeight = 120; // Fixed notes area height
                const ghostNodeHeight = 90; // Space for ghost nodes
                const padding = 24; // Top and bottom padding
                const foHeight = Math.min(230, baseHeight + notesHeight + ghostNodeHeight + padding); // Larger height
                
                // Logic for Expanded View
                if (d.isExpanded) {
                    el.raise();
                    
                    // Smoothly morph the circle to a rounded rectangle
                    circle.transition()
                        .duration(600)
                        .ease(d3.easeCubicInOut)
                        .attr('r', 0);
                    
                    // Scale out text
                    text.transition()
                        .duration(300)
                        .attr('transform', 'scale(0)');
                    
                    // Expanded node sizing: auto height, max 70vh, min 180px, width matches list node
                    const foWidth = Math.max(260, Math.min(420, container.clientWidth * 0.35));
                    const minHeight = 180;
                    const maxHeight = Math.max(320, window.innerHeight * 0.7);
                    // We'll let the content determine the height, but cap it at maxHeight
                    fo.transition()
                        .duration(600)
                        .ease(d3.easeCubicInOut)
                        .attr('x', -foWidth / 2)
                        .attr('y', 0)
                        .attr('width', foWidth)
                        .attr('height', maxHeight)
                        .style('opacity', 1)
                        .on('end', () => {
                            fo.style('pointer-events', 'all')
                              .on('click', event => event.stopPropagation());
                        });
                    if (fo.select('.expanded-node-container').empty()) {
                        fo.html(''); // Clear previous content before rebuilding
                        const baseColor = d.color === '#FFFFFF' ? '#EAEAEA' : d.color;
                        const bgColor = d3.color(baseColor);
                        bgColor.opacity = 0.93;
                        const textColor = isColorTooBright(baseColor) ? '#000000' : '#FFFFFF';
                        const h2Color = isColorTooBright(baseColor) ? d3.color(baseColor).darker(1.5) : d3.color(baseColor).brighter(1.5);
                        // Match list node design
                        const borderRadius = '10px';
                        const padding = '12px 10px';
                        const fontSize = '11pt';
                        const notesFontSize = '10pt';
                        const notesLineHeight = '1.3';
                        const notesMinHeight = '60px';
                        const notesMaxHeight = 'none';
                        const notesPadding = '8px';
                        const notesBorderRadius = '8px';
                        const notesBg = 'rgba(255,255,255,0.10)';
                        const div = fo.append('xhtml:div')
                            .attr('class', 'expanded-node-container')
                            .style('width', '100%')
                            .style('min-height', minHeight + 'px')
                            .style('max-height', maxHeight + 'px')
                            .style('background-color', bgColor.toString())
                            .style('color', textColor)
                            .style('opacity', 0)
                            .style('border-radius', borderRadius)
                            .style('padding', padding)
                            .style('box-sizing', 'border-box')
                            .style('display', 'flex')
                            .style('flex-direction', 'column')
                            .style('gap', '8px')
                            .style('backdrop-filter', 'blur(4px)')
                            .style('font-size', fontSize)
                            .style('overflow', 'visible');
                        // Fade in the content after a delay
                        div.transition()
                            .delay(300)
                            .duration(300)
                            .style('opacity', 1);
                        // Header (title)
                        div.append('xhtml:h3')
                            .style('font-weight', '600')
                            .style('color', h2Color.toString())
                            .style('font-size', fontSize)
                            .style('margin', '0')
                            .style('padding', '0')
                            .style('text-align', 'center')
                            .style('flex-shrink', '0')
                            .attr('contenteditable', true)
                            .text(d.name)
                            .on('mousedown', event => event.stopPropagation())
                            .on('click', event => event.stopPropagation())
                            .on('keydown', function(event) { 
                                if (event.key === 'Enter') { 
                                    event.preventDefault(); 
                                    this.blur(); 
                                } 
                                event.stopPropagation(); 
                            })
                            .on('blur', function() { 
                                d.name = this.innerText; 
                                updateGraph(); 
                            });
                        // Notes text area - placed at the top, no scroll, let modal grow
                        const notesArea = div.append('xhtml:div')
                            .attr('class', 'notes-editor')
                            .style('min-height', notesMinHeight)
                            .style('max-height', notesMaxHeight)
                            .style('background-color', notesBg)
                            .style('border-radius', notesBorderRadius)
                            .style('padding', notesPadding)
                            .style('color', textColor)
                            .style('font-size', notesFontSize)
                            .style('line-height', notesLineHeight)
                            .style('overflow', 'visible')
                            .style('resize', 'none')
                            .style('margin-bottom', '8px')
                            .attr('contenteditable', true)
                            .text(d.notes || '')
                            .on('mousedown', event => event.stopPropagation())
                            .on('click', event => event.stopPropagation())
                            .on('keydown', event => event.stopPropagation())
                            .on('blur', function() { 
                                d.notes = this.innerText.trim(); 
                                updateGraph(); 
                            });
                        // Add placeholder text when empty
                        if (!d.notes) {
                            notesArea.style('color', 'rgba(255,255,255,0.5)')
                                .text('Click to add notes...')
                                .on('focus', function() {
                                    if (this.innerText === 'Click to add notes...') {
                                        this.innerText = '';
                                        d3.select(this).style('color', textColor);
                                    }
                                })
                                .on('click', event => event.stopPropagation());
                        }
                        // Bottom content area - horizontal layout for buttons and ghost nodes
                        const bottomArea = div.append('xhtml:div')
                            .style('display', 'flex')
                            .style('flex-direction', 'row')
                            .style('gap', '8px')
                            .style('flex-grow', '1')
                            .style('min-height', '80px')
                            .style('align-items', 'flex-start');
                        // Left side - Action buttons
                        const actionsContainer = bottomArea.append('xhtml:div')
                            .attr('class', 'ai-actions-container')
                            .style('display', 'flex')
                            .style('flex-direction', 'column')
                            .style('gap', '3px')
                            .style('flex-shrink', '0')
                            .style('width', '80px')
                            .style('align-items', 'stretch');
                        // Calculate lighter button color based on node color
                        const buttonColor = d3.color(baseColor).brighter(0.5).toString();
                        const buttonTextColor = isColorTooBright(buttonColor) ? '#000000' : '#FFFFFF';
                        const actions = ['Define', 'Expand On', 'Solutions'];
                        actions.forEach(action => {
                            actionsContainer.append('xhtml:button')
                                .attr('class', 'ai-action-btn')
                                .style('background-color', buttonColor)
                                .style('color', buttonTextColor)
                                .style('padding', '5px 8px')
                                .style('border-radius', '4px')
                                .style('border', 'none')
                                .style('cursor', 'pointer')
                                .style('font-size', '8pt')
                                .style('font-weight', '500')
                                .style('transition', 'opacity 0.2s ease')
                                .text(action)
                                .on('mouseover', function() {
                                    d3.select(this).style('opacity', '0.8');
                                })
                                .on('mouseout', function() {
                                    d3.select(this).style('opacity', '1');
                                })
                                .on('click', async function(event) {
                                    event.stopPropagation();
                                    event.preventDefault();
                                    let prompt = '';
                                    if (action === 'Define') {
                                        prompt = `Define "${d.name}" clearly and concisely.`;
                                    } else if (action === 'Expand On') {
                                        prompt = `Elaborate on "${d.name}" with key details or examples.`;
                                    } else if (action === 'Solutions') {
                                        prompt = `Suggest practical solutions or approaches for "${d.name}".`;
                                    }
                                    const aiResponse = await callLocalAPIWithRateLimit(prompt, 260, 'high', 'standard');
                                    if (aiResponse) {
                                        const currentNotes = d.notes || '';
                                        const newContent = aiResponse;
                                        d.notes = currentNotes ? `${currentNotes}\n\n${newContent}` : newContent;
                                        if (notesArea && notesArea.node()) {
                                            notesArea.node().innerText = d.notes;
                                            notesArea.style('color', textColor);
                                        }
                                        if (d.notes && notesArea.text() !== 'Click to add notes...') {
                                            notesArea.style('color', textColor);
                                        }
                                    } else {
                                        const currentNotes = d.notes || '';
                                        const newContent = `${action}: Content generation unavailable. Please check your API key.`;
                                        d.notes = currentNotes ? `${currentNotes}\n\n${newContent}` : newContent;
                                        if (notesArea && notesArea.node()) {
                                            notesArea.node().innerText = d.notes;
                                            notesArea.style('color', textColor);
                                        }
                                    }
                                });
                        });
                        // Right side - Ghost node suggestions with breathing animation
                        const ghostContainer = bottomArea.append('xhtml:div')
                            .attr('class', 'ghost-suggestions-container')
                            .style('display', 'flex')
                            .style('flex-direction', 'row')
                            .style('gap', '6px')
                            .style('flex-grow', '1')
                            .style('justify-content', 'flex-start')
                            .style('align-items', 'center')
                            .style('flex-wrap', 'wrap')
                            .style('overflow', 'hidden')
                            .style('padding', '2px');
                        generateAIGhostSuggestions(d).then(ghostSuggestions => {
                            ghostContainer.selectAll('*').remove();
                            ghostSuggestions.forEach((suggestion, index) => {
                                const textLength = suggestion.length;
                                const minSize = 45;
                                const maxSize = 70;
                                const size = Math.min(maxSize, Math.max(minSize, textLength * 3 + 35));
                                const ghostWrapper = ghostContainer.append('xhtml:div')
                                    .style('position', 'relative')
                                    .style('width', `${size}px`)
                                    .style('height', `${size}px`)
                                    .style('flex-shrink', '0');
                                const ghostNode = ghostWrapper.append('xhtml:div')
                                    .attr('class', 'ghost-node')
                                    .style('width', '100%')
                                    .style('height', '100%')
                                    .style('border-radius', '50%')
                                    .style('background-color', 'rgba(255,255,255,0.85)')
                                    .style('border', '2px solid rgba(255,255,255,0.3)')
                                    .style('display', 'flex')
                                    .style('align-items', 'center')
                                    .style('justify-content', 'center')
                                    .style('cursor', 'pointer')
                                    .style('transition', 'all 0.3s ease')
                                    .style('font-size', textLength > 12 ? '6pt' : '7pt')
                                    .style('font-weight', '500')
                                    .style('color', '#333')
                                    .style('text-align', 'center')
                                    .style('padding', '4px')
                                    .style('box-sizing', 'border-box')
                                    .style('word-break', 'break-word')
                                    .style('overflow', 'hidden')
                                    .style('line-height', '1.1')
                                    .style('white-space', 'normal')
                                    .style('hyphens', 'auto')
                                    .style('animation', `breathe ${3 + index * 0.3}s ease-in-out infinite`)
                                    .style('animation-delay', `${index * 0.2}s`)
                                    .text(suggestion)
                                .on('mouseover', function() {
                                    d3.select(this)
                                        .style('background-color', 'rgba(255,255,255,1)')
                                        .style('border-color', 'rgba(255,255,255,0.8)')
                                        .style('transform', 'scale(1.1)')
                                        .style('animation-play-state', 'paused');
                                })
                                .on('mouseout', function() {
                                    d3.select(this)
                                        .style('background-color', 'rgba(255,255,255,0.85)')
                                        .style('border-color', 'rgba(255,255,255,0.3)')
                                        .style('transform', 'scale(1)')
                                        .style('animation-play-state', 'running');
                                })
                                .on('click', function(event) {
                                    event.stopPropagation();
                                    // Add the suggested node as a child
                                    const newNode = addNode(suggestion, d);
                                    if (newNode) {
                                        // Close the expanded view
                                        closeExpandedView(d);
                                        // Select the new node
                                        handleNodeClick(null, newNode);
                                    }
                                });
                            });
                        });
                    }
                } else if (d.isListNode) { // Logic for List Node View
                    // Compact sizing for list node
                    const itemHeight = 22;
                    const headerHeight = 28;
                    const topBottomPadding = 12; // Consistent top and bottom padding
                    const sidePadding = 10;
                    const minListItems = Math.max(3, d.listItems.length);
                    const listHeight = headerHeight + (minListItems * itemHeight) + (topBottomPadding * 2);
                    const maxItemTextLength = Math.max(d.name.length, ...d.listItems.map(item => item.text.length));
                    const listWidth = Math.max(220, Math.min(400, maxItemTextLength * 8 + 60));
                    d.radius = Math.hypot(listWidth, listHeight) / 2;
                    circle.attr('r', 0);
                    text.attr('transform', 'scale(0)');
                    
                    // Check if this is the first time rendering or if content has changed
                    const existingContainer = fo.select('.list-node-container');
                    const needsRebuild = existingContainer.empty() || d._lastListName !== d.name;
                    const needsItemUpdate = d._lastListItemCount !== d.listItems.length;
                    
                    if (needsRebuild) {
                        // Store current state for comparison
                        d._lastListItemCount = d.listItems.length;
                        d._lastListName = d.name;
                        
                    fo.transition()
                      .duration(400)
                      .ease(d3.easeCubicInOut)
                      .attr('x', -listWidth / 2)
                      .attr('y', -listHeight / 2)
                      .attr('width', listWidth)
                      .attr('height', listHeight)
                      .style('opacity', 1)
                      .on('end', () => {
                          fo.style('pointer-events', 'all')
                            .on('click', event => event.stopPropagation());
                          // Only render the list items after the expand animation completes
                              if (fo.select('.list-items-container').empty()) {
                          renderListNodeContent();
                              }
                      });
                    // Render only the container and header immediately
                    fo.html('');
                    const baseColor = d.color === '#FFFFFF' ? '#EAEAEA' : d.color;
                    const bgColor = d3.color(baseColor); bgColor.opacity = 0.9;
                    const textColor = isColorTooBright(baseColor) ? '#000000' : '#FFFFFF';
                    const headerColor = isColorTooBright(baseColor) ? d3.color(baseColor).darker(1.5) : d3.color(baseColor).brighter(1.5);
                    const div = fo.append('xhtml:div')
                        .attr('class', 'list-node-container')
                        .style('width', '100%')
                        .style('height', '100%')
                        .style('background-color', bgColor.toString())
                        .style('color', textColor)
                        .style('border-radius', '10px')
                            .style('padding', `${topBottomPadding}px ${sidePadding}px`)
                        .style('box-sizing', 'border-box')
                        .style('backdrop-filter', 'blur(4px)')
                        .style('display', 'flex')
                        .style('flex-direction', 'column')
                        .style('transition', 'background-color 0.3s ease');
                    // Header
                    div.append('xhtml:h3')
                            .style('margin', '0')
                        .style('font-size', '11pt')
                        .style('font-weight', '600')
                        .style('color', headerColor.toString())
                        .style('text-align', 'center')
                        .style('flex-shrink', '0')
                        .attr('contenteditable', true)
                        .text(d.name)
                        .on('mousedown', event => event.stopPropagation())
                        .on('keydown', function(event) { if (event.key === 'Enter') { event.preventDefault(); this.blur(); } event.stopPropagation(); })
                        .on('blur', function() { d.name = this.innerText; updateGraph(); });
                    // Function to render list items after animation
                    function renderListNodeContent() {
                        const listContainer = div.append('xhtml:div')
                            .attr('class', 'list-items-container')
                            .style('flex-grow', '1')
                            .style('display', 'flex')
                            .style('flex-direction', 'column')
                            .style('gap', '4px')
                                .style('margin-top', `${topBottomPadding}px`)
                            .style('transition', 'all 0.3s ease');
                        d.listItems.forEach((item, index) => {
                                addListItemElement(listContainer, item, index, d, textColor);
                            });
                        }
                    } else if (needsItemUpdate) {
                        // Only add new items without rebuilding existing ones
                        d._lastListItemCount = d.listItems.length;
                        
                        // Update container size
                        fo.transition()
                          .duration(400)
                          .ease(d3.easeCubicInOut)
                          .attr('x', -listWidth / 2)
                          .attr('y', -listHeight / 2)
                          .attr('width', listWidth)
                          .attr('height', listHeight);
                        
                        // Add only the new items
                        const listContainer = fo.select('.list-items-container');
                        const existingItems = listContainer.selectAll('[data-list-index]').size();
                        
                        // Add new items starting from the existing count
                        for (let i = existingItems; i < d.listItems.length; i++) {
                            const item = d.listItems[i];
                            addListItemElement(listContainer, item, i, d, isColorTooBright(d.color === '#FFFFFF' ? '#EAEAEA' : d.color) ? '#000000' : '#FFFFFF');
                        }
                    } else {
                        // Just update the size if content hasn't changed
                        fo.transition()
                          .duration(400)
                          .ease(d3.easeCubicInOut)
                          .attr('x', -listWidth / 2)
                          .attr('y', -listHeight / 2)
                          .attr('width', listWidth)
                          .attr('height', listHeight)
                          .style('opacity', 1);
                    }
                } else if (d.isMediaNode) { // Logic for Media Node View
                    // Better proportioned sizing to prevent clipping
                    const mediaWidth = 140;
                    const mediaHeight = 90;
                    d.radius = Math.hypot(mediaWidth, mediaHeight) / 2;
                    circle.attr('r', 0);
                    text.attr('transform', 'scale(0)');

                    fo.transition()
                      .duration(400)
                      .ease(d3.easeCubicInOut)
                      .attr('x', -mediaWidth / 2)
                      .attr('y', -mediaHeight / 2)
                      .attr('width', mediaWidth)
                      .attr('height', mediaHeight)
                      .style('opacity', 1)
                      .on('end', () => {
                          fo.style('pointer-events', 'all')
                            .on('click', event => event.stopPropagation());
                      });

                    // Render the container only once
                    if (fo.select('.media-node-container').empty()) {
                        fo.html('');
                        const baseColor = d.color === '#FFFFFF' ? '#EAEAEA' : d.color;
                        const bgColor = d3.color(baseColor); bgColor.opacity = 0.9;
                        const textColor = isColorTooBright(baseColor) ? '#000000' : '#FFFFFF';
                        const headerColor = isColorTooBright(baseColor) ? d3.color(baseColor).darker(1.5) : d3.color(baseColor).brighter(1.5);

                        const div = fo.append('xhtml:div')
                            .attr('class', 'media-node-container')
                            .style('width', '100%')
                            .style('height', '100%')
                            .style('background-color', bgColor.toString())
                                    .style('color', textColor)
                            .style('border-radius', '6px')
                            .style('padding', '8px')
                            .style('box-sizing', 'border-box')
                            .style('backdrop-filter', 'blur(4px)')
                            .style('display', 'flex')
                            .style('flex-direction', 'column')
                            .style('justify-content', 'space-between')
                            .style('align-items', 'center')
                            .style('text-align', 'center')
                            .style('overflow', 'hidden');

                        // Header (editable name) - better sizing and spacing
                        div.append('xhtml:h3')
                            .style('margin', '0')
                            .style('font-size', '8pt')
                            .style('font-weight', '600')
                            .style('color', headerColor.toString())
                            .style('text-align', 'center')
                                    .style('flex-shrink', '0')
                            .style('padding', '2px 4px')
                            .style('cursor', 'text')
                            .style('white-space', 'nowrap')
                            .style('overflow', 'hidden')
                            .style('text-overflow', 'ellipsis')
                            .style('max-width', '100%')
                            .attr('contenteditable', true)
                            .text(d.name)
                            .on('mousedown', event => event.stopPropagation())
                            .on('keydown', function(event) { if (event.key === 'Enter') { event.preventDefault(); this.blur(); } event.stopPropagation(); })
                            .on('blur', function() { d.name = this.innerText; });

                        // Media Preview Container - better proportioned
                        const previewContainer = div.append('xhtml:div')
                            .style('flex-grow', '1')
                            .style('display', 'flex')
                            .style('flex-direction', 'column')
                            .style('justify-content', 'center')
                            .style('align-items', 'center')
                            .style('overflow', 'hidden')
                            .style('border-radius', '4px')
                            .style('background', 'rgba(0,0,0,0.05)')
                            .style('padding', '6px')
                            .style('min-height', '0');

                        // Render based on media type with cleaner design
                        if (d.mediaType === 'image') {
                            // Show icon only for deeper generations (not first gen)
                            if (d.depth > 1) {
                                previewContainer.append('xhtml:div')
                                    .style('font-size', '16px')
                                    .style('margin-bottom', '3px')
                                    .text('🖼️');
                            }
                            // Link
                            previewContainer.append('xhtml:a')
                                .attr('href', d.mediaSrc)
                                .attr('target', '_blank')
                                .style('font-size', '8pt')
                                    .style('color', textColor)
                                .style('text-decoration', 'underline')
                                .style('cursor', 'pointer')
                                .style('text-align', 'center')
                                .style('line-height', '1.2')
                                .style('word-wrap', 'break-word')
                                .style('hyphens', 'auto')
                                .text('View Image');
                        } else if (d.mediaType === 'youtube') {
                            // Always try to get videoId from metadata or src
                            let videoId = d.mediaMetadata && d.mediaMetadata.videoId;
                            if (!videoId && d.mediaSrc) {
                                const match = d.mediaSrc.match(/[?&]v=([\w-]{11})/) || d.mediaSrc.match(/youtu\.be\/([\w-]{11})/);
                                if (match) videoId = match[1];
                            }
                            // Fallback: try to extract from originalUrl if present
                            if (!videoId && d.mediaMetadata && d.mediaMetadata.originalUrl) {
                                const match = d.mediaMetadata.originalUrl.match(/[?&]v=([\w-]{11})/) || d.mediaMetadata.originalUrl.match(/youtu\.be\/([\w-]{11})/);
                                if (match) videoId = match[1];
                            }
                            if (videoId) {
                                // Embed the YouTube video
                                previewContainer.append('xhtml:div')
                                    .style('width', '100%')
                                    .style('display', 'flex')
                                    .style('flex-direction', 'column')
                                    .style('align-items', 'center')
                                    .html(`
                                        <iframe width='100' height='56' style='border-radius:6px; margin-bottom:4px; border:none; background:#000;' src='https://www.youtube.com/embed/${videoId}' allowfullscreen></iframe>
                                        <div style='color:${textColor}; font-size:8pt; font-weight:600; text-align:center; max-width:90px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;'>${d.mediaMetadata && d.mediaMetadata.title ? d.mediaMetadata.title : 'YouTube'}</div>
                                    `);
                            } else if (d.mediaMetadata && d.mediaMetadata.thumbnail_url) {
                                previewContainer.append('xhtml:a')
                                    .attr('href', d.mediaMetadata?.originalUrl || d.mediaSrc)
                                    .attr('target', '_blank')
                                    .style('display', 'flex')
                                    .style('flex-direction', 'column')
                                    .style('align-items', 'center')
                                    .style('text-decoration', 'none')
                                    .html(`
                                        <img src='${d.mediaMetadata.thumbnail_url}' style='width:80px; border-radius:6px; margin-bottom:4px;'>
                                        <div style='color:${textColor}; font-size:8pt; font-weight:600; text-align:center; max-width:90px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;'>${d.mediaMetadata.title || 'YouTube'}</div>
                                    `);
                            } else {
                                // Fallback: generic icon and label
                            if (d.depth > 1) {
                                previewContainer.append('xhtml:div')
                                    .style('font-size', '16px')
                                    .style('margin-bottom', '3px')
                                    .text('▶️');
                            }
                            previewContainer.append('xhtml:a')
                                .attr('href', d.mediaMetadata?.originalUrl || d.mediaSrc)
                                .attr('target', '_blank')
                                .style('font-size', '8pt')
                                .style('color', textColor)
                                .style('text-decoration', 'underline')
                                .style('cursor', 'pointer')
                                .style('text-align', 'center')
                                .style('line-height', '1.2')
                                .text('YouTube');
                            }
                        } else if (d.mediaType === 'vimeo') {
                            // Show icon only for deeper generations
                            if (d.depth > 1) {
                                previewContainer.append('xhtml:div')
                                    .style('font-size', '16px')
                                    .style('margin-bottom', '3px')
                                    .text('🎬');
                            }
                            // Link
                            previewContainer.append('xhtml:a')
                                .attr('href', d.mediaMetadata?.originalUrl || d.mediaSrc)
                                .attr('target', '_blank')
                                .style('font-size', '8pt')
                                .style('color', textColor)
                                .style('text-decoration', 'underline')
                                .style('cursor', 'pointer')
                                .style('text-align', 'center')
                                .style('line-height', '1.2')
                                .text('Vimeo');
                        } else if (d.mediaType === 'twitter') {
                            // Show icon only for deeper generations
                            if (d.depth > 1) {
                                previewContainer.append('xhtml:div')
                                    .style('font-size', '16px')
                                    .style('margin-bottom', '3px')
                                    .text('𝕏');
                            }
                            // Link
                            previewContainer.append('xhtml:a')
                                .attr('href', d.mediaSrc)
                                .attr('target', '_blank')
                                .style('font-size', '8pt')
                                .style('color', textColor)
                                .style('text-decoration', 'underline')
                                .style('cursor', 'pointer')
                                .style('text-align', 'center')
                                .style('line-height', '1.2')
                                .text('x.com');
                        } else if (d.mediaType === 'github') {
                            const metadata = d.mediaMetadata || {};
                            // Show icon only for deeper generations
                            if (d.depth > 1) {
                                previewContainer.append('xhtml:div')
                                    .style('font-size', '16px')
                                    .style('margin-bottom', '3px')
                                    .text('⚡');
                            }
                            // Link
                            previewContainer.append('xhtml:a')
                                .attr('href', d.mediaSrc)
                                .attr('target', '_blank')
                                .style('font-size', '8pt')
                                .style('color', textColor)
                                .style('text-decoration', 'underline')
                                .style('cursor', 'pointer')
                                .style('text-align', 'center')
                                .style('line-height', '1.2')
                                .style('word-wrap', 'break-word')
                                .text(`${metadata.owner}/${metadata.repo}` || 'GitHub');
                        } else if (d.mediaType === 'pdf') {
                            // Show icon only for deeper generations
                            if (d.depth > 1) {
                                previewContainer.append('xhtml:div')
                                    .style('font-size', '16px')
                                    .style('margin-bottom', '3px')
                                    .text('📄');
                            }
                            // Link
                            previewContainer.append('xhtml:a')
                                .attr('href', d.mediaSrc)
                                .attr('target', '_blank')
                                .style('font-size', '8pt')
                                .style('color', textColor)
                                .style('text-decoration', 'underline')
                                .style('cursor', 'pointer')
                                .style('text-align', 'center')
                                .style('line-height', '1.2')
                                .text('PDF');
                        } else if (d.mediaType === 'link') {
                            const metadata = d.mediaMetadata || {};
                            // Show icon only for deeper generations
                            if (d.depth > 1) {
                                previewContainer.append('xhtml:div')
                                    .style('font-size', '16px')
                                    .style('margin-bottom', '3px')
                                    .text(metadata.isSecure ? '🔗' : '🌐');
                            }
                            // Domain link
                            previewContainer.append('xhtml:a')
                                .attr('href', d.mediaSrc)
                                .attr('target', '_blank')
                                .style('font-size', '8pt')
                                .style('color', textColor)
                                .style('text-decoration', 'underline')
                                .style('cursor', 'pointer')
                                .style('text-align', 'center')
                                .style('line-height', '1.2')
                                .style('word-wrap', 'break-word')
                                .text(metadata.domain || 'Link');
                        } else if (d.mediaType === 'file') {
                            // Show icon only for deeper generations
                            if (d.depth > 1) {
                                previewContainer.append('xhtml:div')
                                    .style('font-size', '16px')
                                    .style('margin-bottom', '3px')
                                    .text('📁');
                            }
                            // Filename
                            previewContainer.append('xhtml:div')
                                .style('font-size', '8pt')
                                .style('color', textColor)
                                .style('text-align', 'center')
                                .style('word-wrap', 'break-word')
                                .style('line-height', '1.2')
                                .style('hyphens', 'auto')
                                .text(d.mediaSrc);
                        }
                    }
                } else { // Logic for Standard (Circle) View
                    // Set proper dimensions for the circle based on depth
                    if (d.depth === 0) {
                        // Make central node smaller by 5px
                        d.radius = 22; // Reduced from 27 by 5px
                        
                        // Text positioning for central node - below the circle, capitalized
                        const words = d.name.toUpperCase().split(/\s+/); // Convert to uppercase
                        const lineHeight = 22; // Line height for below-circle text
                        const maxWidth = 120; // Increased for better readability
                        const textOffsetY = d.radius + 16; // Set to 16 pixels spacing below circle
                        
                        // Clear existing text
                        text.text('');
                        
                        // Use the new text wrapping function
                        wrapText(text, words.join(' '), maxWidth, lineHeight, 0, '#E0E0E0', '500');
                        
                        // Add notes text if available - with proper wrapping
                        if (d.notes && d.notes.trim() !== '') {
                            const notesText = d.notes.trim();
                            const currentTspanCount = text.selectAll('tspan').size();
                            const startingDy = currentTspanCount > 0 ? lineHeight * 0.8 : 0;
                            
                            // Add wrapped notes with preview formatting (wider, smaller font, max 3 lines)
                            wrapTextPreview(text, notesText, maxWidth * 0.85, lineHeight * 0.5, startingDy, '#FFFFFF', '400', '6pt', 0.6, 3);
                        }
                        
                        // Position the text below the circle
                        const totalLines = text.selectAll('tspan').size();
                        text.attr('transform', `translate(0, ${textOffsetY})`)
                            .attr('dominant-baseline', 'hanging'); // Ensure text starts below circle
                        
                        // Style the text - smaller and less bold for a softer look
                        text.style('font-size', '13pt')
                            .style('letter-spacing', '0px')
                            .style('fill', '#E0E0E0')
                            .style('font-weight', '500');
                        
                        // Remove fisheye effect handlers
                        el.on('mouseenter', null).on('mouseleave', null);
                        // Add minimal breathing effect to the central node's circle
                        if (!circle.classed('breathing')) {
                            circle.classed('breathing', true);
                            circle.transition('breathe-in')
                                .duration(1800)
                                .ease(d3.easeSinInOut)
                                .attr('r', d.radius * 1.07)
                                .transition('breathe-out')
                                .duration(1800)
                                .ease(d3.easeSinInOut)
                                .attr('r', d.radius)
                                .on('end', function repeat() {
                                    d3.select(this)
                                      .transition('breathe-in')
                                      .duration(1800)
                                      .ease(d3.easeSinInOut)
                                      .attr('r', d.radius * 1.07)
                                      .transition('breathe-out')
                                      .duration(1800)
                                      .ease(d3.easeSinInOut)
                                      .attr('r', d.radius)
                                      .on('end', repeat);
                                });
                        }
                    } else {
                        // Optimized node size scaling for better content visibility
                        if (d.depth === 1) {
                            d.radius = 18; // Slightly smaller first generation for better balance
                        } else if (d.depth === 2) {
                            d.radius = 14; // Second generation
                        } else if (d.depth === 3) {
                            d.radius = 11; // Third generation  
                        } else if (d.depth === 4) {
                            d.radius = 9; // Fourth generation
                        } else {
                            d.radius = 8; // Fifth generation and beyond - larger minimum for readability
                        }
                        
                        // For non-central nodes, ensure single line text and proper color
                        let textColor;
                        if (d.depth === 1) {
                            // First generation: use a softer, lighter version of the background color, 10% whiter
                            const baseTextColor = d3.color(d.color).brighter(1.8);
                            // Make it 10% whiter by interpolating towards white
                            textColor = d3.interpolate(baseTextColor, '#FFFFFF')(0.1).toString();
                        } else {
                            // Other depths: use a soft light gray or black
                            textColor = isColorTooBright(d.color) ? '#000000' : '#E0E0E0';
                        }
                        
                        // Clear existing text and rebuild with notes
                        text.text('');
                        
                        // Optimized text positioning and sizing for content viewing
                        let textOffsetY;
                        let maxWidth;
                        // Reduce line height for 2nd generation and beyond
                        let lineHeight;
                        if (d.depth >= 2) {
                            lineHeight = 14; // Balanced compactness and readability
                        } else {
                            lineHeight = 16;
                        }

                        if (d.depth === 1) {
                            // First generation: text inside the node (centered)
                            textOffsetY = 0;
                            maxWidth = 120; // Increased for first generation to prevent truncation
                            text.attr('dominant-baseline', 'middle');
                        } else if (d.depth === 2) {
                            // Second generation: text below the node
                            textOffsetY = d.radius + 14;
                            maxWidth = 80; // Increased for better readability
                            text.attr('dominant-baseline', 'hanging');
                        } else if (d.depth === 3) {
                            // Third generation: balanced width
                            textOffsetY = d.radius + 12;
                            maxWidth = 70; // Increased for better readability
                            text.attr('dominant-baseline', 'hanging');
                        } else {
                            // Fourth generation and beyond: still readable
                            textOffsetY = d.radius + 10;
                            maxWidth = 60; // Increased for better readability
                            text.attr('dominant-baseline', 'hanging');
                        }
                        
                        // Use the new text wrapping function for the main heading
                        wrapText(text, d.name, maxWidth, lineHeight, 0, textColor, '500');
                        
                        // Add notes if available - with proper wrapping
                        if (d.notes && d.notes.trim() !== '') {
                            const notesText = d.notes.trim();
                            const currentTspanCount = text.selectAll('tspan').size();
                            const startingDy = currentTspanCount > 0 ? lineHeight * 0.8 : 0;
                            
                            // Add wrapped notes with preview formatting (wider, smaller font, max 3 lines)
                            wrapTextPreview(text, notesText, maxWidth * 0.75, lineHeight * 0.6, startingDy, '#FFFFFF', '400', '6pt', 0.6, 3);
                        }
                        
                        // Position the text properly
                        text.attr('transform', `translate(0, ${textOffsetY})`);
                    }
                    
                    // If we're transitioning back from expanded, animate it
                    if (d.wasExpanded) {
                        d.wasExpanded = false; // Consume the flag immediately

                        fo.style('pointer-events', 'none');
                        
                        // All animations happen simultaneously
                        // Fade out the content
                        fo.select('.expanded-node-container')
                            .transition()
                            .duration(300)
                            .style('opacity', 0);
                        
                        // Shrink the foreignObject
                        fo.transition()
                            .duration(600)
                            .ease(d3.easeCubicInOut)
                            .attr('x', 0)
                            .attr('y', 0)
                            .attr('width', 0)
                            .attr('height', 0)
                            .style('opacity', 0)
                            .on('end', function() {
                                d3.select(this).html(''); // Clean up content after transition
                            });
                        
                        // Simultaneously morph back to circle
                        circle.transition()
                            .duration(600)
                            .ease(d3.easeCubicInOut)
                            .attr('r', d.radius);
                        
                        // And scale text back in
                        text.transition()
                            .duration(600)
                            .ease(d3.easeCubicInOut)
                            .attr('transform', d.depth === 0 ? `translate(0, ${d.radius + 16}) scale(1)` : 'scale(1)');
                    } else {
                        // Normal rendering (no transition needed)
                        fo.style('opacity', 0).style('pointer-events', 'none');
                        circle.attr('r', d.radius);
                        text.attr('transform', d.depth === 0 ? `translate(0, ${d.radius + 16}) scale(1)` : 'scale(1)');
                    }
                    
                    // Handle fill and fadeout effect for selected nodes
                    const isSelected = selectedNode && selectedNode.id === d.id;
                    
                    if (isSelected) {
                        // Update gradient color and apply it to selected nodes
                        const fadeoutGradient = defs.select("#edge-fadeout");
                        fadeoutGradient.selectAll("stop")
                            .attr("stop-color", d.color);
                        circle.attr('fill', 'url(#edge-fadeout)');
                    } else {
                        // Apply theme-based gradient styling
                        const nodeStyle = generateNodeStyle(d.color, d.depth);
                        
                        // Apply the gradient background
                        if (!defs.select(`#node-gradient-${d.id}`).size()) {
                            // Create a unique radial gradient for this node
                            const gradient = defs.append("radialGradient")
                                .attr("id", `node-gradient-${d.id}`)
                                .attr("cx", "30%")
                                .attr("cy", "30%")
                                .attr("r", "70%");
                                
                            // Extract colors from the backgroundImage CSS
                            const gradientMatch = nodeStyle.backgroundImage.match(/radial-gradient\(circle at .+?, (.+?), (.+?) \d+%, (.+?)\)/);
                            if (gradientMatch && gradientMatch.length >= 4) {
                                gradient.append("stop")
                                    .attr("offset", "0%")
                                    .attr("stop-color", gradientMatch[1]);
                                    
                                gradient.append("stop")
                                    .attr("offset", "65%")
                                    .attr("stop-color", gradientMatch[2]);
                                    
                                gradient.append("stop")
                                    .attr("offset", "100%")
                                    .attr("stop-color", gradientMatch[3]);
                            } else {
                                // Fallback if regex fails
                                gradient.append("stop")
                                    .attr("offset", "0%")
                                    .attr("stop-color", d3.color(d.color).brighter(0.3));
                                    
                                gradient.append("stop")
                                    .attr("offset", "100%")
                                    .attr("stop-color", d.color);
                            }
                        }
                        
                        // Apply the gradient
                        circle.attr('fill', `url(#node-gradient-${d.id})`);
                    }
                    
                    // Add theme-appropriate shadow to nodes
                    if (!isSelected) {
                        const nodeStyle = generateNodeStyle(d.color, d.depth);
                        const shadowMatch = nodeStyle.boxShadow.match(/0 0 (\d+)px (rgba\(\d+, \d+, \d+, [\d\.]+\))/);
                        
                        if (shadowMatch && shadowMatch.length >= 3) {
                            const blurSize = parseInt(shadowMatch[1]);
                            const shadowColor = shadowMatch[2];
                            
                            // Apply shadow as filter
                            circle.style('filter', `drop-shadow(0 0 ${blurSize}px ${shadowColor})`);
                        } else if (d.depth === 0) {
                            // Fallback for central node
                            circle.style('filter', 'drop-shadow(0 0 8px rgba(255, 255, 255, 0.05))');
                        } else {
                            // Fallback for other nodes
                            const theme = dynastyThemes[currentTheme] || dynastyThemes['Cosmic Ocean'];
                            const shadowOpacity = theme.effects.shadowOpacity || 0.3;
                            const shadowBlur = Math.max(5, (theme.effects.shadowBlur || 20) - (d.depth * 4));
                            
                            const shadowColor = d3.color(d.color);
                            shadowColor.opacity = shadowOpacity;
                            
                            circle.style('filter', `drop-shadow(0 0 ${shadowBlur}px ${shadowColor})`);
                        }
                    }
                    // When selected (including central node), the CSS .node.selected circle filter takes over
                }
            });

            simulation.nodes(nodes);
            simulation.force("link").links(links);
            
            // Apply dynamic font sizing after node updates
            setTimeout(() => updateDynamicFontSizes(), 50);
        }

        function generateBranchPath(d) {
            const dx = d.target.x - d.source.x;
            const dy = d.target.y - d.source.y;
            const length = Math.sqrt(dx * dx + dy * dy);

            // If nodes are on top of each other, fallback to a straight line
            if (length === 0) {
                return `M${d.source.x},${d.source.y} L${d.target.x},${d.target.y}`;
            }

            // Normalized perpendicular vector to calculate control point offset
            let nx = -dy / length;
            let ny = dx / length;

            // Randomly reverse curve direction for some connectors
            // Use a combination of node IDs to create consistent but varied curve directions
            const curveHash = (d.source.id * 31 + d.target.id * 17) % 100;
            const shouldReverseCurve = curveHash < 50; // 50% chance to reverse
            
            if (shouldReverseCurve) {
                nx = -nx;
                ny = -ny;
            }

            // Base curvature is reactive to the child's depth, creating a fanning effect.
            const baseCurvature = d.target.depth * 8;

            // A continuous, subtle sine wave animation, applied only to children of the central node
            // and only for nodes up to generation 3 (depth <= 3).
            // We add node IDs to desynchronize the animations of different links.
            const animOffset = (d.source.depth === 0 && d.target.depth <= 3) 
                ? Math.sin(Date.now() / 700 + d.source.id + d.target.id) * 4
                : 0;

            const totalCurvature = baseCurvature + animOffset;

            // Calculate the quadratic Bezier curve control point.
            const cpx = (d.source.x + d.target.x) / 2 + nx * totalCurvature;
            const cpy = (d.source.y + d.target.y) / 2 + ny * totalCurvature;

            const path = d3.path();
            path.moveTo(d.source.x, d.source.y);
            path.quadraticCurveTo(cpx, cpy, d.target.x, d.target.y);
            return path.toString();
        }
        
        simulation.on("tick", () => {
            linkGroup.selectAll(".link").attr("d", generateBranchPath);
            nodeGroup.selectAll(".node").attr("transform", d => `translate(${d.x},${d.y})`);
            updateDynamicFontSizes(); // Update font sizes on every tick
            
            // Maintain minimum movement
            if (simulation.alpha() < 0.015) {
                simulation.alpha(0.015);
            }
        });
        
        function optimizeView(force = false) {
            if (nodes.length === 0) return;
            
            // Check if any nodes are outside the current viewport
            const transform = d3.zoomTransform(svg.node());
            const margin = 100;
            let needsReframing = force;
            
            if (!force) {
                nodes.forEach(node => {
                    const screenX = (node.x * transform.k) + transform.x;
                    const screenY = (node.y * transform.k) + transform.y;
                    const nodeRadius = (node.radius || 20) * transform.k;
                    
                    if (screenX - nodeRadius < margin || 
                        screenX + nodeRadius > container.clientWidth - margin ||
                        screenY - nodeRadius < margin || 
                        screenY + nodeRadius > container.clientHeight - margin) {
                        needsReframing = true;
                    }
                });
            }
            
            if (!needsReframing) return;
            
            const padding = 80; // Reduced padding for tighter zoom
            const xExtent = d3.extent(nodes, d => d.x);
            const yExtent = d3.extent(nodes, d => d.y);
            if (xExtent[0] === undefined) return;
            const [x0, x1] = xExtent;
            const [y0, y1] = yExtent;
            const fullWidth = x1 - x0;
            const fullHeight = y1 - y0;
            if (fullWidth === 0 || fullHeight === 0) return;
            const midX = x0 + fullWidth / 2;
            const midY = y0 + fullHeight / 2;
            const scale = Math.min(2.5, 1.8 / Math.max((fullWidth + padding) / container.clientWidth, (fullHeight + padding) / container.clientHeight)); // Much closer zoom by default
            const newTransform = d3.zoomIdentity.translate(container.clientWidth / 2 - scale * midX, container.clientHeight / 2 - scale * midY).scale(scale);
            svg.transition().duration(800).call(zoom.transform, newTransform) // Slightly longer for smoother transitions
                .on('end', updateDynamicFontSizes); // Update font sizes after zoom transition
        }

        // --- State Management ---
        // Removed setMode and selectNode functions, reverting to older, direct logic.

        // --- Interaction Logic ---
        function addNode(name, parent = null) {
            if (!name.trim()) return null;
            let newNode;

            // Check if this is a list type entry
            const listTypeMatch = name.match(/^(- |1\. |\[\] )(.*)/);
            const isListType = listTypeMatch !== null;
            let listType = null;
            let listContent = name;
            
            if (isListType) {
                if (listTypeMatch[1] === '- ') listType = 'bullet';
                else if (listTypeMatch[1] === '1. ') listType = 'numbered';
                else if (listTypeMatch[1] === '[] ') listType = 'task';
                listContent = listTypeMatch[2];
            }

            if (parent === null) {
                // This block should only ever create the VERY FIRST node.
                if (nodes.length > 0) {
                    console.error("Attempted to create a second central node. Action blocked.");
                    return null; // Prevent creating more than one root.
                }
                
                // Clear Flow Assistant state for new project
                clearFlowAssistantState();
                
                const color = "#FFFFFF"; // Central nodes are always white
                let x, y;
                x = container.clientWidth / 2;
                y = container.clientHeight / 2;
                newNode = { 
                    id: nextId++, 
                    name: isListType ? (listContent || 'New List') : name, 
                    depth: 0, 
                    children:[], 
                    x, y, fx: x, fy: y, 
                    color: color,
                    isListNode: false, // Central node cannot be a list
                    listType: undefined,
                listItems: undefined,
                isMediaNode: false,
                mediaType: null,
                mediaSrc: null,
                mediaMetadata: {},
                createdAt: Date.now() // Track creation time for consistency
                };
                nodes.push(newNode);
            } else {
                // If this is a list type entry, transform the parent into a list node
                if (isListType && parent && !parent.isListNode) {
                    // Save previous state for undo
                    const prevState = {
                        isListNode: parent.isListNode,
                        listType: parent.listType,
                        listItems: parent.listItems ? [...parent.listItems] : undefined
                    };
                    // Transform the parent into a list node
                    parent.isListNode = true;
                    parent.listType = listType;
                    parent.listItems = [];
                    
                    // Add the first item if there's content
                    if (listContent) {
                        parent.listItems.push({
                            text: listContent,
                            checked: listType === 'task' ? false : undefined,
                            id: Date.now()
                        });
                    }
                    // Push transformation to historyStack
                    historyStack.push({type: 'transform-list', nodeId: parent.id, prevState});
                    // Enter list entry mode for this node
                    isListEntryMode = true;
                    activeListNode = parent;
                    
                    updateGraph();
                    simulation.alpha(0.05).restart();
                    return parent; // Return the transformed parent
                }
                
                // Regular node creation
                const depth = parent.depth + 1;
                // Distance logic with reduced 1st generation connector length
                let targetDistance;
                if (depth === 1) {
                    // 1st generation: much larger minimum distance for better spacing
                    // Now: minimum 500px, maximum 650px
                    targetDistance = Math.max(500, 650 - parent.children.length * 8); // Varies from 650 down to 500
                } else {
                    // Other generations: keep original logic
                    targetDistance = Math.max(40, 150 - depth * 35); // e.g., 80, 45, 40...
                }

                if (!parent.children) parent.children = [];

                let finalColor;
                if (depth === 1) {
                    // First generation: each child gets a unique dynasty palette
                    // Distribute children evenly across available dynasty palettes
                    const dynastyIndex = parent.children.length % dynastyPalettes.length;
                    
                    // Store the dynasty assignment for this node
                    firstGenPaletteAssignment.set(nextId, dynastyIndex);
                    
                    // Get the first color from the assigned dynasty palette
                    finalColor = getNodeColor(depth, dynastyIndex);
                } else {
                    // Deeper generations: inherit from their dynasty's palette with gradient evolution
                    // Find the first generation ancestor to determine which dynasty this node belongs to
                    let firstGenAncestor = parent;
                    while (firstGenAncestor && firstGenAncestor.depth > 1) {
                        const parentLink = links.find(l => l.target.id === firstGenAncestor.id);
                        if (!parentLink) break;
                        firstGenAncestor = parentLink.source;
                    }
                    
                    // Get the dynasty index from the first generation ancestor
                    let dynastyIndex = 0; // Default to first dynasty
                    
                    if (firstGenAncestor && firstGenAncestor.depth === 1) {
                        // Find the dynasty assignment for this branch
                        const ancestorId = firstGenAncestor.id;
                        const assignedDynasty = firstGenPaletteAssignment.get(ancestorId);
                        
                        if (assignedDynasty !== undefined) {
                            dynastyIndex = assignedDynasty;
                        }
                    }
                    
                    // Get color from the appropriate dynasty palette based on depth
                    finalColor = getNodeColor(depth, dynastyIndex);
                }

                // Restore cone-based placement logic
                const rootNode = nodes[0];
                if (!rootNode) return null; // Should not happen if we have a parent

                let bestAngle;
                if (parent.depth === 0) {
                    // For the central node, cycle through 7 positions with variations
                    const childIndex = parent.children.length;
                    const baseAngles = [
                        0,                      // Right (0°)
                        Math.PI,               // Left (180°)
                        -Math.PI / 2,          // Top (-90°)
                        -3 * Math.PI / 4,      // Top-left (-135°)
                        -Math.PI / 4,          // Top-right (-45°)
                        3 * Math.PI / 4,       // Bottom-left (135°)
                        Math.PI / 4            // Bottom-right (45°)
                    ];
                    
                    // Cycle through the seven base positions
                    const baseAngleIndex = childIndex % 7;
                    let baseAngle = baseAngles[baseAngleIndex];
                    
                    // Add more random variation for visual variety
                    const variationGroup = Math.floor(childIndex / 7); // Which cycle we're in (0, 1, 2, ...)
                    const maxVariation = Math.PI / 7; // ±~25 degrees max variation
                    // Add a random offset within the allowed range
                    const randomOffset = (Math.random() - 0.5) * maxVariation;
                    const variation = (variationGroup * (maxVariation / 2)) * (baseAngleIndex % 2 === 0 ? 1 : -1) + randomOffset;
                    bestAngle = baseAngle + variation;
                } else {
                    // For other nodes, use a 160-degree cone based on their own angle from the center
                    const parentAngle = Math.atan2(parent.y - rootNode.y, parent.x - rootNode.x);
                    const coneWidth = (160 * Math.PI) / 180;
                const coneStart = parentAngle - coneWidth / 2;

                const siblingAngles = parent.children.map(child => Math.atan2(child.y - parent.y, child.x - parent.x));
                    bestAngle = parentAngle; // Default to center

                if (siblingAngles.length > 0) {
                    let normalizedSiblings = siblingAngles.map(a => {
                        let norm = a - coneStart;
                        while(norm < 0) norm += 2 * Math.PI;
                        return norm % (2 * Math.PI);
                    }).filter(a => a <= coneWidth + 0.001).sort((a,b)=>a-b);

                    if (normalizedSiblings.length > 0) {
                        let maxGap = 0;
                        let angleAtMaxGap = -1;

                        maxGap = normalizedSiblings[0];
                        angleAtMaxGap = coneStart + maxGap / 2;

                        for(let i = 0; i < normalizedSiblings.length - 1; i++){
                            let gap = normalizedSiblings[i+1] - normalizedSiblings[i];
                            if (gap > maxGap) {
                                maxGap = gap;
                                angleAtMaxGap = coneStart + normalizedSiblings[i] + gap / 2;
                            }
                        }

                        let lastGap = coneWidth - normalizedSiblings[normalizedSiblings.length - 1];
                        if (lastGap > maxGap){
                            angleAtMaxGap = coneStart + normalizedSiblings[normalizedSiblings.length - 1] + lastGap / 2;
                        }
                        bestAngle = angleAtMaxGap;
                        }
                    }
                }

                newNode = {
                    id: nextId++, 
                    name: isListType ? (listContent || 'New List') : name, 
                    depth, 
                    children: [], 
                    x: parent.x + 20 * Math.cos(bestAngle), 
                    y: parent.y + 20 * Math.sin(bestAngle), 
                    color: finalColor,
                    isListNode: false,
                    listType: undefined,
                    listItems: undefined,
                    isMediaNode: false,
                    mediaType: null,
                    mediaSrc: null,
                    mediaMetadata: {},
                    createdAt: Date.now() // Track creation time for position fixing
                };
                nodes.push(newNode);
                
                // Fix position after shorter time delay for faster stabilization
                if (depth >= 1) {
                    const fixDelay = depth === 1 ? 1000 : 2000; // Reduced from 2000/4000ms to 1000/2000ms for faster stabilization
                    setTimeout(() => {
                        // Find the node again in case it was moved in the array
                        const nodeToFix = nodes.find(n => n.id === newNode.id);
                        if (nodeToFix && !nodeToFix.fx && !nodeToFix.fy) {
                            // Fix the node's position to stop floating
                            nodeToFix.fx = nodeToFix.x;
                            nodeToFix.fy = nodeToFix.y;
                        }
                    }, fixDelay);
                }

                links.push({ 
                    source: parent, target: newNode, 
                    targetDistance: targetDistance,
                    cp_dx_factor: (Math.random() - 0.5) * 0.4, cp_dy_factor: (Math.random() - 0.5) * 0.4
                });
                parent.children.push(newNode);
            }

            if (newNode) {
                historyStack.push(newNode);
                
                // Trigger immediate background processing for new node events
                if (nodes.length > 1) {
                    detectSignificantChange('node_added', { 
                        id: newNode.id, 
                        parent: parent,
                        name: newNode.name 
                    });
                    
                    // Trigger immediate Flow Assistant activation for new nodes only
                    setTimeout(() => {
                    if (flowAssistantActive) {
                        generateInteractiveInfoCard(newNode);
                    }
                }, 50); // Reduced from 100ms to 50ms
                    
                    // Trigger contextual suggestions more frequently and faster
                    if (Math.random() < 0.5) { // Increased frequency from 0.3 to 0.5
                        setTimeout(() => generateContextualSuggestions(), 1000); // Reduced from 6000ms to 1000ms
                    }
                }
            }
            
                        updateGraph();
            simulation.alpha(0.2).restart(); // Increased alpha from 0.1 to 0.2 for faster settling
            
            // Intelligent camera panning - for central node, center immediately
            if (newNode && newNode.depth === 0) {
                setTimeout(() => optimizeView(true), 50); // Reduced from 100ms to 50ms for faster centering
            } else {
                // For other nodes, check if new node needs reframing
                setTimeout(() => optimizeView(), 100); // Further reduced from 200ms to 100ms for faster view optimization
            }
            
            return newNode;
        }

        function removeNode(nodeToRemove) {
            if (!nodeToRemove) return;

            // Find parent before links are filtered, so we can update its children array
            const parentLink = links.find(l => l.target.id === nodeToRemove.id);
            const parentNode = parentLink ? parentLink.source : null;

            const nodesToDelete = new Set([nodeToRemove.id]);
            const findDescendants = (nodeId) => {
                links.filter(l => l.source.id === nodeId).forEach(l => {
                    nodesToDelete.add(l.target.id);
                    findDescendants(l.target.id);
                });
            };
            findDescendants(nodeToRemove.id);

            nodes = nodes.filter(n => !nodesToDelete.has(n.id));
            links = links.filter(l => !nodesToDelete.has(l.source.id) && !nodesToDelete.has(l.target.id));

            // *** FIX ***: Correctly remove the node from its parent's children array
            if (parentNode && parentNode.children) {
                parentNode.children = parentNode.children.filter(child => child.id !== nodeToRemove.id);
            }

            if (selectedNode && nodesToDelete.has(selectedNode.id)) {
                selectedNode = null;
                updateUserInstruction(nodes.length > 0 ? 'Select a node to continue' : 'Click to create your central idea');
                summarizeBtn.style.display = 'none';
                elaborateBtn.style.display = 'none';
            }
            
            updateGraph();
            simulation.alpha(0.1).restart(); // Quick restart that settles fast
            optimizeView();
        }

        function handleNodeClick(event, d) {
            if (event && event.sourceEvent) event.sourceEvent.stopPropagation();
            else if (event) event.stopPropagation();
            
            if (activeExpandedNode) closeExpandedView(activeExpandedNode);

            // Exit list entry mode if clicking a different node
            if (isListEntryMode && activeListNode && activeListNode.id !== d.id) {
                exitListEntryMode();
            }

            // Only update selection and UI, do not call updateGraph or restart simulation
            if (selectedNode) {
                nodeGroup.selectAll('.node').filter(n => n.id === selectedNode.id).classed('selected', false);
            }
            selectedNode = d;
            isPrimedForChild = true;

            if (selectedNode) {
                nodeGroup.selectAll('.node').filter(n => n.id === selectedNode.id).classed('selected', true);
                summarizeBtn.style.display = 'inline-block';
                elaborateBtn.style.display = 'inline-block';
                
                // Update instruction text
                updateUserInstruction(`Selected "${selectedNode.name}" • Enter for sibling • Shift+Enter for child`);
                
                // Flow Assistant integration
                if (flowAssistantActive) {
                    // Always generate a new card for any node click
                    // This ensures each node gets its own card and the conversation flows naturally
                    generateInteractiveInfoCard(selectedNode);
                }
            }
            nodeInput.focus();
        }
        
        function handleNodeDoubleClick(event, d) {
            if (event) event.stopPropagation();
            
            // Don't allow expanding list nodes or the central node
            if (d.isListNode || d.isMediaNode || d.depth === 0) return;

            if (activeExpandedNode && activeExpandedNode.id !== d.id) {
                closeExpandedView(activeExpandedNode, () => openExpandedView(d));
            } else if (d.isExpanded) {
                closeExpandedView(d);
            } else {
                openExpandedView(d);
            }
        }
        
        // --- Event Listeners ---
        nodeInput.addEventListener('keydown', (event) => {
            if (event.key !== 'Enter') return;
            event.preventDefault();
            const text = nodeInput.value.trim();
            if (!text) return;

            let newNode;

            // Handle list entry mode
            if (isListEntryMode && activeListNode) {
                if (event.shiftKey) {
                    // Shift+Enter: Add a child node to the focused list node
                    newNode = addNode(text, activeListNode);
                    if (newNode) {
                        nodeInput.value = '';
                        // Exit list entry mode and select the new child node
                        exitListEntryMode();
                        handleNodeClick(null, newNode);
                    }
                } else {
                    // Regular Enter: Add item to the active list node
                activeListNode.listItems.push({
                    text: text,
                    checked: activeListNode.listType === 'task' ? false : undefined,
                    id: Date.now() // Simple ID for tracking
                });
                nodeInput.value = '';
                
                // Trigger smooth resize animation by updating the graph
                updateGraph();
                
                // Optional: Add a subtle flash effect to indicate the new item was added
                setTimeout(() => {
                    const listContainer = nodeGroup.selectAll(".node")
                        .filter(d => d.id === activeListNode.id)
                        .select('foreignObject')
                        .select('.list-node-container');
                    
                    if (!listContainer.empty()) {
                        listContainer.style('background-color', d3.color(activeListNode.color).brighter(0.3).toString())
                            .transition()
                            .duration(300)
                            .style('background-color', d3.color(activeListNode.color).copy({opacity: 0.9}).toString());
                    }
                }, 50);
                }
                
                return;
            }

            // Check if this is a list type entry
            const listTypeMatch = text.match(/^(- |1\. |\[\] )(.*)/);
            const isListType = listTypeMatch !== null;
            
            // Check if this is a YouTube URL - handle it like drag and drop
            const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/)|youtu\.be\/)([\w-]{11})/;
            const youtubeMatch = text.match(youtubeRegex);
            if (youtubeMatch && youtubeMatch[1] && selectedNode && selectedNode.depth > 0) {
                // Transform the selected node into a YouTube media node
                const embedUrl = `https://www.youtube.com/embed/${youtubeMatch[1]}`;
                transformToMediaNode(selectedNode, 'youtube', embedUrl);
                nodeInput.value = '';
                return;
            }
            
            // If trying to create a list and a node is selected, transform it
            if (isListType && selectedNode && !selectedNode.isListNode && selectedNode.depth > 0) {
                // Transform the selected node into a list node (but not the central node)
                let listType = null;
                let listContent = listTypeMatch[2];
                
                if (listTypeMatch[1] === '- ') listType = 'bullet';
                else if (listTypeMatch[1] === '1. ') listType = 'numbered';
                else if (listTypeMatch[1] === '[] ') listType = 'task';
                
                selectedNode.isListNode = true;
                selectedNode.listType = listType;
                selectedNode.listItems = [];
                
                // Add the first item if there's content
                if (listContent) {
                    selectedNode.listItems.push({
                        text: listContent,
                        checked: listType === 'task' ? false : undefined,
                        id: Date.now()
                    });
                }
                
                // Enter list entry mode
                isListEntryMode = true;
                activeListNode = selectedNode;
                nodeInput.value = '';
                updateUserInstruction(`Adding items to list "${selectedNode.name}" • Enter to add item • Shift+Enter for child node`);
                
                updateGraph();
                // Also apply a gentle restart here for consistency
                simulation.alpha(0.05).restart();
                return;
            }

            if (nodes.length === 0) {
                // Case 1: Create the first node (central node)
                newNode = addNode(text, null);
                if (newNode) {
                    handleNodeClick(null, newNode); // Select it and prime it for a child
                    nodeInput.value = '';
                    
                    // Flow Assistant: Generate info card for central node
                    if (flowAssistantActive) {
                        setTimeout(() => {
                            generateInteractiveInfoCard(newNode);
                        }, 500); // Small delay to ensure node is fully created
                    }
                }
            } else if (selectedNode) {
                // Case 2: A node is selected, decide what to create
                if (isPrimedForChild) {
                    // It was primed, so Enter creates a child.
                    newNode = addNode(text, selectedNode);
                } else {
                    // Standard mode: Shift+Enter for child, Enter for sibling.
                    if (event.shiftKey) {
                        newNode = addNode(text, selectedNode); 
                    } else {
                        const parentLink = links.find(l => l.target.id === selectedNode.id);
                        // If root is selected, create a child. Otherwise, create a sibling.
                        const parent = parentLink ? parentLink.source : selectedNode;
                        newNode = addNode(text, parent);
                    }
                }

                if (newNode) {
                    // Clear input first
                    nodeInput.value = '';
                    
                    // Select the new node. This will correctly prime it for the moment.
                    handleNodeClick(null, newNode);
                    
                    // For the next interaction, we always want to be in standard mode
                    // after any key-based creation (unless we entered list mode).
                    if (!isListEntryMode) {
                        isPrimedForChild = false;
                        updateUserInstruction(`Selected "${newNode.name}" • Enter for sibling • Shift+Enter for child`);
                    }
                }
            }
        });

        // --- Continuous AI Suggestions as User Types (Flow Assistant Integration) ---
        // (REMOVED: let typingTimer;)
        // (REMOVED: showTypingSuggestions function)
        // (REMOVED: nodeInput.addEventListener('input', ...))
        // (REMOVED: nodeInput.addEventListener('blur', ...))
        // (REMOVED: any addAssistantMessage calls with suggestions for live typing)
        // (REMOVED: .assistant-suggestions and .suggestion-chip from assistantMessages)
        // The assistant area now only uses chat-style text output.
        // ... existing code ...

        d3.select("body").on("keydown", (event) => {
            if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
                // Exit list entry mode on navigation
                if (isListEntryMode) {
                    exitListEntryMode();
                }
                
                if (!selectedNode) {
                    return;
                }
                event.preventDefault();

                // --- Highly intelligent spatial navigation ---
                function findClosestNodeInDirection(fromNode, direction) {
                    // Direction vectors
                    const dirVectors = {
                        ArrowUp:    { x: 0, y: -1 },
                        ArrowDown:  { x: 0, y: 1 },
                        ArrowLeft:  { x: -1, y: 0 },
                        ArrowRight: { x: 1, y: 0 }
                    };
                    const v = dirVectors[direction];
                    if (!v) return null;

                    let bestNode = null;
                    let bestScore = Infinity;

                    for (const node of nodes) {
                        if (node.id === fromNode.id) continue;
                        // Vector from fromNode to node
                        const dx = node.x - fromNode.x;
                        const dy = node.y - fromNode.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist === 0) continue;
                        // Normalize
                        const ndx = dx / dist;
                        const ndy = dy / dist;
                        // Dot product: how well does this node align with the intended direction?
                        const dot = v.x * ndx + v.y * ndy;
                        // Only consider nodes that are at least somewhat in the intended direction
                        if (dot < 0.5) continue; // 0.5 = within 60 degrees of the direction
                        // Penalize by angular deviation and distance
                        const anglePenalty = 1 - dot; // 0 is perfect alignment, 1 is perpendicular
                        const score = dist * (1 + anglePenalty * 2); // Weight angle more
                        if (score < bestScore) {
                            bestScore = score;
                            bestNode = node;
                        }
                    }
                    return bestNode;
                        }

                let newSelection = findClosestNodeInDirection(selectedNode, event.key);

                if (newSelection) {
                    handleNodeClick(null, newSelection);
                }
                return; // Navigation was handled, stop further processing
            }

            // --- Prevent other actions if input is focused ---
            if(document.activeElement === nodeInput) return;

            // --- Undo Logic (Ctrl+Z / Cmd+Z) ---
            if ((event.ctrlKey || event.metaKey) && (event.key === 'z' || event.key === 'Z')) {
                // Don't interfere if user is actively typing
                if (document.activeElement === nodeInput && nodeInput.value.trim() !== '') return;
                
                event.preventDefault();
                const lastAction = historyStack.pop();
                if (lastAction) {
                    if (lastAction.type === 'transform-list') {
                        // Undo list transformation
                        const node = nodes.find(n => n.id === lastAction.nodeId);
                        if (node) {
                            node.isListNode = lastAction.prevState.isListNode;
                            node.listType = lastAction.prevState.listType;
                            node.listItems = lastAction.prevState.listItems;
                            updateGraph();
                            simulation.alpha(0.1).restart();
                        }
                    } else if (lastAction.type === 'transform-media') {
                        // Undo media transformation (implement if you have media node transforms)
                        const node = nodes.find(n => n.id === lastAction.nodeId);
                        if (node) {
                            node.isMediaNode = false;
                            node.mediaType = null;
                            node.mediaSrc = null;
                            node.mediaMetadata = {};
                            updateGraph();
                            simulation.alpha(0.1).restart();
                        }
                    } else {
                        // Default: remove node
                        const nodeToRemove = nodes.find(n => n.id === lastAction.id);
                        if(nodeToRemove) {
                            // Find the previous node to focus on after undo
                            const previousNode = historyStack.length > 0 ? historyStack[historyStack.length - 1] : null;
                            const previousNodeInGraph = previousNode ? nodes.find(n => n.id === previousNode.id) : null;
                            removeNode(nodeToRemove);
                            if (previousNodeInGraph) {
                                handleNodeClick(null, previousNodeInGraph);
                            } else if (nodes.length > 0) {
                                const centralNode = nodes.find(n => n.depth === 0);
                                if (centralNode) {
                                    handleNodeClick(null, centralNode);
                                }
                            }
                        }
                    }
                }
            }
            
            // --- Delete Node Logic (Delete / Backspace) ---
            if(selectedNode && (event.key === 'Delete' || event.key === 'Backspace')){
                event.preventDefault();
                removeNode(selectedNode);
            }
        });
        
        // --- LLM and Dragging ---
        async function triggerProactiveSuggestions(newNode) {
            // Wait a moment for the user to finish their thought
            setTimeout(() => {
                // Don't interrupt if user is actively working
                if (document.activeElement === nodeInput && nodeInput.value.trim() !== '') return;
                if (isDragging) return;
                if (isListEntryMode) return;
                
                generateContextualSuggestions();
            }, 3000); // Increased delay to be less intrusive
        }
        summarizeBtn.addEventListener('click', async () => {
            if (!selectedNode) return;
            
            const context = buildMindMapContext();
            const prompt = `Summarize this mind map: ${context}`;
            
            callLocalAPIWithRateLimit(prompt, 260, 'high', 'standard').then(response => {
                if (response) {
                    addAssistantMessage("Summary:", []);
                    addAssistantMessage(response, []);
                }
            });
        });
        
        elaborateBtn.addEventListener('click', async () => {
            if (!selectedNode) return;
            
            const prompt = `Elaborate on "${selectedNode.name}" with key insights.`;
            
            callLocalAPIWithRateLimit(prompt, 260, 'high', 'standard').then(response => {
                if (response) {
                    addAssistantMessage(`About "${selectedNode.name}":`, []);
                    addAssistantMessage(response, []);
                    
                    // Also generate some suggested child nodes
                    const suggestionPrompt = `Suggest 3-4 child nodes for "${selectedNode.name}" (2-3 words each) as JSON array.`;
                    callLocalAPIWithRateLimit(suggestionPrompt, 150, 'medium', 'standard').then(suggestions => {
                        if (suggestions) {
                            try {
                                const parsed = JSON.parse(suggestions);
                                if (Array.isArray(parsed)) {
                                    addAssistantMessage("Explore:", parsed.slice(0, 4));
                                }
                            } catch (e) {
                                // Silent fail
                            }
                        }
                    });
                }
            });
        });
        function flashNode(nodeId) {
            const nodeToFlash = node.filter(d => d.id === nodeId);
            // ... existing code ...
        }
        function displayAiSuggestions(suggestions) { /* ... same as before ... */ }
        function displayAiResponse(text, title) { /* ... same as before ... */ }
        
        function dragstarted(event, d) {
            // Store starting position to distinguish clicks from drags
            d.startX = event.x;
            d.startY = event.y;
            isDragging = false; // Reset flag
            
            // Store initial distances ONLY for directly connected links (not all links)
            const directlyConnectedLinks = links.filter(l => 
                (l.source.id === d.id) || (l.target.id === d.id)
            );
            directlyConnectedLinks.forEach(link => {
                link.initialDistance = Math.hypot(link.target.x - link.source.x, link.target.y - link.source.y);
            });

            // Track only immediate children for potential repositioning
            d.draggedChildren = [];
            const immediateChildren = links.filter(l => l.source.id === d.id).map(l => l.target);
            immediateChildren.forEach(child => {
                d.draggedChildren.push({
                    node: child,
                    originalX: child.x,
                    originalY: child.y
                });
            });
        }
        function dragged(event, d) {
            if (!isDragging) {
                const dx = event.x - d.startX;
                const dy = event.y - d.startY;
                // Only start a "real" drag if the mouse moves more than 15px (increased threshold)
                if (dx * dx + dy * dy > 225) { // 15px threshold
                    isDragging = true;
                    // Do NOT restart the entire simulation - just pin this node
                    // This prevents affecting nodes from other branches
                }
            }
            
            if (isDragging) {
                // Simply pin the dragged node position - no simulation forces
                d.fx = event.x;
                d.fy = event.y;
                // Do not affect any other nodes during drag
            }
        }
        function dragended(event, d) {
            if (!isDragging) {
                // --- THIS IS A CLICK ---
                handleNodeClick(event, d);
            } else {
                // --- THIS WAS A DRAG ---
                // Pin nodes after dragging to prevent unwanted floating
                // Central node stays pinned, first generation nodes get pinned, others can float
                if (d.depth === 0 || d.depth === 1) {
                    // Keep first generation and central nodes pinned after drag
                    d.fx = d.x;
                    d.fy = d.y;
                } else {
                    // Allow other nodes to settle naturally
                    d.fx = null;
                    d.fy = null;
                }
                
                // Update distances only for directly connected links
                const directlyConnectedLinks = links.filter(l => 
                    (l.source.id === d.id) || (l.target.id === d.id)
                );
                directlyConnectedLinks.forEach(link => {
                    const postDragDistance = Math.hypot(link.target.x - link.source.x, link.target.y - link.source.y);
                    const initialDistance = link.initialDistance || link.targetDistance;
                    const distanceChange = postDragDistance - initialDistance;
                    
                    if (Math.abs(distanceChange) > 5) { // Only update if significant change
                    if (distanceChange > 0) {
                            // Stretched: learn 40% of the new distance (reduced from 60%)
                            link.targetDistance = Math.max(40, link.targetDistance + (distanceChange * 0.4));
                        } else {
                            // Contracted: learn only 20% of the contracted distance (reduced from 30%)
                        const contractionAmount = Math.abs(distanceChange);
                            link.targetDistance = Math.max(40, link.targetDistance - (contractionAmount * 0.2));
                        }
                    }
                    
                    // Clean up the initial distance tracking
                    delete link.initialDistance;
                });
                
                // Gentle post-drag repositioning of immediate children only (45% reduced)
                if (d.draggedChildren && d.draggedChildren.length > 0) {
                    const dragDeltaX = d.x - (d.startX || d.x);
                    const dragDeltaY = d.y - (d.startY || d.y);
                    
                    // Only reposition if there was significant movement
                    if (Math.abs(dragDeltaX) > 20 || Math.abs(dragDeltaY) > 20) { // Balanced threshold (between 15 and 25)
                        setTimeout(() => {
                            gentlyRepositionChildren(d, d.draggedChildren);
                        }, 155); // 45% reduction in delay increase: 100 + (200-100)*0.55 = 155ms
                    }
                    
                    // Clean up children data
                    d.draggedChildren = null;
                }
                
                // Only give a very gentle nudge to the simulation - no major restart
                simulation.alpha(Math.max(simulation.alpha(), 0.02));
            }
            // Clean up start positions
            delete d.startX;
            delete d.startY;
        }

        function gentlyRepositionChildren(parentNode, children) {
            // Apply gentler forces - reduced by 45%
            const repositionStrength = 0.044; // 45% reduction from 0.08 (0.08 * 0.55 = 0.044)
            const maxRepositionDistance = 14; // 45% reduction from 25 (25 * 0.55 ≈ 14)
            
            children.forEach(childData => {
                const child = childData.node;
                
                // Only apply minimal adjustment
                const dx = parentNode.x - child.x;
                const dy = parentNode.y - child.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Only apply force if child is far from parent
                if (distance > 100) { // Adjusted threshold (between 80 and 120)
                    const targetDistance = 65; // Balanced target distance
                    const pullStrength = (distance - targetDistance) / distance;
                    const limitedPull = Math.min(pullStrength, 0.165); // 45% reduction from 0.3 (0.3 * 0.55 = 0.165)
                    
                    // Apply gentle pull towards parent
                    child.vx += dx * limitedPull * repositionStrength;
                    child.vy += dy * limitedPull * repositionStrength;
                }
            });
            
            // Give the simulation a gentler nudge - 45% reduction
            simulation.alpha(Math.max(simulation.alpha(), 0.0275)); // 45% reduction from 0.05 (0.05 * 0.55 = 0.0275)
        }
        
        // --- Initial State ---
        window.addEventListener('resize', optimizeView);
        
        // Theme dropdown event listener
        const themeDropdown = document.getElementById('theme-dropdown');
        themeDropdown.value = currentTheme; // Set initial value
        themeDropdown.addEventListener('change', (event) => {
            switchTheme(event.target.value);
        });
        
        // AI Controls Setup
        const currentModelElement = document.getElementById('current-model');
        const usageIndicator = document.getElementById('usage-indicator');
        const toggleBackgroundBtn = document.getElementById('toggle-background');
        
        // Update AI status indicators
        function updateAIStatus() {
            // Show the actual model name, not the key
            currentModelElement.textContent = LOCAL_MODEL_NAME.replace(/[-_:]/g, ' ').replace(/\s+/g, ' ').toUpperCase();
            const { name: modelName, config: modelConfig } = getBestAvailableModel();
            const usage = modelUsage[modelName];
            const usagePercent = (usage.today / modelConfig.dailyLimit) * 100;
            usageIndicator.style.setProperty('--usage-percent', `${usagePercent}%`);
            // Color coding based on usage
            if (usagePercent > 80) {
                currentModelElement.style.background = '#ff6b6b'; // Red
            } else if (usagePercent > 60) {
                currentModelElement.style.background = '#ffa726'; // Orange
            } else {
                currentModelElement.style.background = 'var(--ui-focus-dark)'; // Normal
            }
        }
        
        // Toggle background processing button
        toggleBackgroundBtn.addEventListener('click', () => {
            const enabled = toggleBackgroundProcessing();
            toggleBackgroundBtn.classList.toggle('active', enabled);
            toggleBackgroundBtn.title = `Background AI updates ${enabled ? 'enabled' : 'disabled'}`;
        });
        
        // Initialize button state
        toggleBackgroundBtn.classList.add('active');
        
        // Update status every 30 seconds
        setInterval(updateAIStatus, 30000);
        updateAIStatus(); // Initial update
        
        applyTheme();
        nodeInput.focus(); // Set focus on the input field on load
        
        // Initialize user instructions
        updateUserInstruction('Click to create your central idea');
        // Keep minimal simulation running for drag responsiveness
        d3.timer(() => {
            if (simulation.alpha() < 0.01) {
                simulation.alpha(0.01); // Maintain minimal energy for drag detection
            }
        });
        
        // Initialize dynamic font sizes
        setTimeout(() => updateDynamicFontSizes(), 100);
        
        // Setup interactive Flow Assistant
        setupNodeDropTargets();

        // Periodic Flow Assistant refresh for long sessions (much less frequent)
        let lastFlowAssistantUpdate = 0;
        setInterval(() => {
            // Only refresh if user has been idle for a very long time
            if (selectedNode && 
                !isDragging && 
                !isListEntryMode && 
                document.activeElement !== nodeInput &&
                Date.now() - lastFlowAssistantUpdate > 900000) { // 15 minutes instead of 5
                
                if (flowAssistantActive) {
                    generateInteractiveInfoCard(selectedNode);
                }
                lastFlowAssistantUpdate = Date.now();
            }
        }, 300000); // Check every 5 minutes instead of 1 minute

        // Track significant map changes for Flow Assistant triggers
        let lastMapStructureHash = '';
        function getMapStructureHash() {
            const structure = nodes.map(n => `${n.id}:${n.name}:${n.depth}`).sort().join('|');
            return structure;
        }

        // Enhanced node change detection
        if (typeof originalUpdateGraph === 'undefined') {
            var originalUpdateGraph = updateGraph;
        }
        updateGraph = function() {
            const newHash = getMapStructureHash();
            const changed = newHash !== lastMapStructureHash;
            originalUpdateGraph.call(this);
            if (changed && nodes.length > 1) {
                triggerFlowAssistant('mapchange');
            }
            lastMapStructureHash = newHash;
        };

        window.addEventListener('dragenter', (event) => {
            event.preventDefault();
            // Show a border on the container to indicate it's a drop zone
            container.style.border = '2px dashed var(--ui-focus-dark)';
        });

        window.addEventListener('dragleave', (event) => {
            event.preventDefault();
            // Check if the cursor is leaving the window. relatedTarget will be null.
            if (event.relatedTarget === null) {
                container.style.border = 'none';
                if (dropTargetNode) {
                    nodeGroup.selectAll('.node').filter(n => n.id === dropTargetNode.id).classed('drop-target', false);
                    dropTargetNode = null;
                }
            }
        });

        window.addEventListener('dragover', (event) => {
            event.preventDefault(); // This is crucial to allow the 'drop' event.

            // Convert screen coordinates to SVG space coordinates, accounting for zoom/pan
            const transform = d3.zoomTransform(svg.node());
            const [mx, my] = d3.pointer(event, masterGroup.node());

            let closestNode = null;
            let minDistance = Infinity;

            // Find the closest node to the cursor
            nodes.forEach(node => {
                // Cannot drop on the central node, or nodes that are already special types.
                if (node.depth === 0 || node.isListNode || node.isExpanded || node.isMediaNode) return;
                
                const dx = node.x - mx;
                const dy = node.y - my;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Check if cursor is within the node's radius + a small buffer
                if (distance < minDistance && distance < node.radius + 30) {
                    minDistance = distance;
                    closestNode = node;
                }
            });

            if (closestNode !== dropTargetNode) {
                // Remove highlight from the old target
                if (dropTargetNode) {
                    nodeGroup.selectAll('.node').filter(n => n.id === dropTargetNode.id).classed('drop-target', false);
                }
                // Add highlight to the new target
                if (closestNode) {
                    nodeGroup.selectAll('.node').filter(n => n.id === closestNode.id).classed('drop-target', true);
                }
                dropTargetNode = closestNode;
            }
        });

        window.addEventListener('drop', (event) => {
            event.preventDefault();
            container.style.border = 'none'; // Hide the container border

            if (dropTargetNode) {
                // Always remove the highlight from the drop target node
                nodeGroup.selectAll('.node').filter(n => n.id === dropTargetNode.id).classed('drop-target', false);
                
                const dt = event.dataTransfer;
                const files = dt.files;
                const url = dt.getData('text/uri-list') || dt.getData('text/plain');

                if (files.length > 0) {
                    // Handle file drop
                    const file = files[0];
                    if (file.type.startsWith('image/')) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            transformToMediaNode(dropTargetNode, 'image', e.target.result);
                        };
                        reader.readAsDataURL(file);
                    } else {
                        // For other file types, just use the file name
                         transformToMediaNode(dropTargetNode, 'file', file.name);
                    }
                } else if (url) {
                    // --- Intelligent URL Processing ---
                    const linkInfo = intelligentLinkDetection(url);
                    transformToMediaNode(dropTargetNode, linkInfo.type, linkInfo.src, linkInfo.metadata);
                }
                // Reset drop target after processing
                dropTargetNode = null;
            }
        });

        svg.on('click', (event) => {
            // Check if we clicked on the background, not a node or button
            if (event.target !== container && event.target !== svg.node()) return;
            
            // Additional check to prevent closing on button clicks
            if (event.target.classList && (
                event.target.classList.contains('ai-action-btn') ||
                event.target.closest('.ai-action-btn') ||
                event.target.closest('.notes-editor') ||
                event.target.closest('.expanded-node-container')
            )) {
                return;
            }
            
            if (activeExpandedNode) {
                closeExpandedView(activeExpandedNode);
            }

            if (selectedNode) {
                nodeGroup.selectAll('.node').filter(n => n.id === selectedNode.id).classed('selected', false);
                selectedNode = null;
                isPrimedForChild = false;
                updateUserInstruction(nodes.length > 0 ? 'Select a node to continue' : 'Click to create your central idea');
                summarizeBtn.style.display = 'none';
                elaborateBtn.style.display = 'none';
            }
        });

        nodeInput.addEventListener('focus', () => {
            if (activeExpandedNode) {
                closeExpandedView(activeExpandedNode);
            }
        });

        function saveToHistory() {
            // History implementation for undo/redo (placeholder for future enhancement)
        }

        function openExpandedView(d) {
            d.isExpanded = true;
            activeExpandedNode = d;
            updateGraph();
            // --- Camera pan/zoom to center expanded node ---
            // Get node position
            const svgRect = svg.node().getBoundingClientRect();
            const centerX = svgRect.width / 2;
            const centerY = svgRect.height / 2;
            // Use d.x, d.y as node position in simulation coordinates
            // Calculate the current transform
            const currentTransform = d3.zoomTransform(svg.node());
            // Target: move d.x, d.y to center of viewport
            const targetScale = Math.max(0.7, Math.min(1.2, currentTransform.k)); // Keep scale reasonable
            const tx = centerX - d.x * targetScale;
            const ty = centerY - d.y * targetScale;
            // Animate the zoom/pan
            svg.transition()
                .duration(700)
                .call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(targetScale));
        }

        function closeExpandedView(d, callback) {
            if (!d || !d.isExpanded) {
                if(callback) callback();
                return;
            }
            activeExpandedNode = null;
            d.isExpanded = false;
            d.wasExpanded = true;
            d.fx = null;
            d.fy = null;

            // The actual animation is handled in updateGraph now
            updateGraph();
            
            // Zoom out camera during the transition
            optimizeView();
            
            // Wait for the animation to complete before calling callback
            if (callback) {
                setTimeout(callback, 600);
            }
        }

        function handleBackgroundClick(event) {
            if (event.target !== container && event.target !== svg.node()) return;
            
            if (activeExpandedNode) {
                closeExpandedView(activeExpandedNode);
            }

            // Exit list entry mode
            if (isListEntryMode) {
                exitListEntryMode();
            }

            if (selectedNode) {
                nodeGroup.selectAll('.node').filter(n => n.id === selectedNode.id).classed('selected', false);
                selectedNode = null;
                isPrimedForChild = false;
                updateUserInstruction(nodes.length > 0 ? 'Select a node to continue' : 'Click to create your central idea');
                summarizeBtn.style.display = 'none';
                elaborateBtn.style.display = 'none';
                
                // Show Flow Assistant welcome message when no node is selected
                showFlowAssistantWelcome();
            }
        }

        function centerOnNode(d) {
            const foWidth = Math.min(320, container.clientWidth * 0.32);
            const foHeight = Math.min(230, container.clientHeight * 0.35);

            const width = svg.node().clientWidth;
            const height = svg.node().clientHeight;
            
            // For expanded nodes, calculate scale to ensure it fits comfortably on screen
            const scale = d.isExpanded ? 
                Math.min(
                    width / (foWidth * 2.5), 
                    height / (foHeight * 2.5),
                    1.8 // Increased max scale for closer zoom on expanded nodes
                ) : 
                1.5; // Closer default scale when not expanded

            const transform = d3.zoomIdentity
                .translate(width / 2, height / 2)
                .scale(scale)
                .translate(-d.x, -d.y);

            svg.transition()
                .duration(600) // Reduced transition duration
                .call(zoom.transform, transform)
                .on('end', updateDynamicFontSizes);
        }

        function exitListEntryMode() {
            isListEntryMode = false;
            activeListNode = null;
            if (selectedNode) {
                updateUserInstruction(`Selected "${selectedNode.name}" • Enter for sibling • Shift+Enter for child`);
            }
        }

        // Custom backspace logic for list entry mode
        let listBackspaceState = 0; // 0: normal, 1: highlight last, 2: delete
        nodeInput.addEventListener('keydown', (event) => {
            if (isListEntryMode && event.key === 'Backspace' && activeListNode && activeListNode.listItems.length > 0 && nodeInput.value === '') {
                event.preventDefault();
                if (listBackspaceState === 0) {
                    // Highlight last item for replacement
                    const idx = activeListNode.listItems.length - 1;
                    const node = nodeGroup.selectAll('.node').filter(d => d.id === activeListNode.id);
                    node.selectAll('.list-items-container > div').filter((d, i) => i === idx)
                        .style('background', '#ffb7b7')
                        .style('color', '#a00');
                    listBackspaceState = 1;
                } else if (listBackspaceState === 1) {
                    // Delete last item
                    activeListNode.listItems.pop();
                    listBackspaceState = 0;
                    updateGraph();
                }
            } else if (event.key !== 'Backspace') {
                listBackspaceState = 0;
                // Remove highlight if present
                if (activeListNode) {
                    const node = nodeGroup.selectAll('.node').filter(d => d.id === activeListNode.id);
                    node.selectAll('.list-items-container > div').style('background', '').style('color', '');
                }
            }
        });

        // Global keyboard event listener for Ctrl+Z undo functionality
        document.addEventListener('keydown', (event) => {
            // Only handle Ctrl+Z / Cmd+Z when not typing in the input field
            if ((event.ctrlKey || event.metaKey) && (event.key === 'z' || event.key === 'Z')) {
                // Don't interfere if user is actively typing
                if (document.activeElement === nodeInput && nodeInput.value.trim() !== '') return;
                
                event.preventDefault();
                const lastAction = historyStack.pop();
                if (lastAction) {
                    if (lastAction.type === 'transform-list') {
                        // Undo list transformation
                        const node = nodes.find(n => n.id === lastAction.nodeId);
                        if (node) {
                            node.isListNode = lastAction.prevState.isListNode;
                            node.listType = lastAction.prevState.listType;
                            node.listItems = lastAction.prevState.listItems;
                            updateGraph();
                            simulation.alpha(0.1).restart();
                        }
                    } else if (lastAction.type === 'transform-media') {
                        // Undo media transformation (implement if you have media node transforms)
                        const node = nodes.find(n => n.id === lastAction.nodeId);
                        if (node) {
                            node.isMediaNode = false;
                            node.mediaType = null;
                            node.mediaSrc = null;
                            node.mediaMetadata = {};
                            updateGraph();
                            simulation.alpha(0.1).restart();
                        }
                    } else {
                        // Default: remove node
                        const nodeToRemove = nodes.find(n => n.id === lastAction.id);
                        if(nodeToRemove) {
                            // Find the previous node to focus on after undo
                            const previousNode = historyStack.length > 0 ? historyStack[historyStack.length - 1] : null;
                            const previousNodeInGraph = previousNode ? nodes.find(n => n.id === previousNode.id) : null;
                            removeNode(nodeToRemove);
                            if (previousNodeInGraph) {
                                handleNodeClick(null, previousNodeInGraph);
                            } else if (nodes.length > 0) {
                                const centralNode = nodes.find(n => n.depth === 0);
                                if (centralNode) {
                                    handleNodeClick(null, centralNode);
                                }
                            }
                        }
                    }
                }
            }
            
            // Handle Ctrl+V for pasting images and URLs
            if ((event.ctrlKey || event.metaKey) && (event.key === 'v' || event.key === 'V')) {
                // Don't interfere if user is actively typing in input field
                if (document.activeElement === nodeInput) return;
                
                event.preventDefault();
                
                // Check if we have a selected node to attach the media to
                if (!selectedNode) {
                    // If no node selected, create a new central node or add to existing central node
                    const centralNode = nodes.find(n => n.depth === 0);
                    if (centralNode) {
                        selectedNode = centralNode;
                    } else {
                        // Create central node if none exists
                        selectedNode = addNode("Media Collection", null);
                        if (!selectedNode) return;
                    }
                }
                
                // Try to get clipboard data
                navigator.clipboard.read().then(async (clipboardItems) => {
                    for (const clipboardItem of clipboardItems) {
                        for (const type of clipboardItem.types) {
                            if (type.startsWith('image/')) {
                                // Handle image paste
                                const blob = await clipboardItem.getType(type);
                                const imageUrl = URL.createObjectURL(blob);
                                createMediaNode(selectedNode, 'image', imageUrl, { source: 'clipboard' });
                                return;
                            }
                        }
                    }
                }).catch(() => {
                    // Fallback: try to get text (URLs)
                    navigator.clipboard.readText().then(text => {
                        if (text && text.trim()) {
                            // Check if it's a URL
                            try {
                                new URL(text);
                                // It's a valid URL, create media node
                                const mediaInfo = intelligentLinkDetection(text);
                                if (mediaInfo) {
                                    createMediaNode(selectedNode, mediaInfo.type, mediaInfo.src, mediaInfo.metadata);
                                }
                            } catch (e) {
                                // Not a URL, ignore
                            }
                        }
                    }).catch(() => {
                        // Clipboard access failed, show user instruction
                        addAssistantMessage("To paste images: Copy an image from another tab, then Ctrl+V here. For URLs: Copy the URL and Ctrl+V here.", []);
                    });
                });
            }

            // --- Delete Node Logic (Delete / Backspace) ---
            // Only delete if not editing text (input, textarea, or contenteditable)
            const active = document.activeElement;
            const isEditing = active && (
                active.tagName === 'INPUT' ||
                active.tagName === 'TEXTAREA' ||
                active.isContentEditable
            );
            if (!isEditing && selectedNode && (event.key === 'Delete' || event.key === 'Backspace')) {
                event.preventDefault();
                removeNode(selectedNode);
            }
        });
        
        // Helper function to create media nodes
        function createMediaNode(parentNode, type, src, metadata = {}) {
            if (!parentNode) return null;
            
            // Save previous state for undo
            const prevState = {
                isMediaNode: parentNode.isMediaNode,
                mediaType: parentNode.mediaType,
                mediaSrc: parentNode.mediaSrc,
                mediaMetadata: parentNode.mediaMetadata ? {...parentNode.mediaMetadata} : {}
            };
            
            // If YouTube, fetch oEmbed data for title/thumbnail
            if (type === 'youtube') {
                // Extract video ID from src or metadata
                let videoId = null;
                if (metadata && metadata.videoId) {
                    videoId = metadata.videoId;
                } else {
                    // Try to extract from src
                    const match = src.match(/[?&]v=([\w-]{11})/) || src.match(/youtu\.be\/([\w-]{11})/);
                    if (match) videoId = match[1];
                }
                if (videoId) {
                    const oembedUrl = `https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${videoId}&format=json`;
                    fetch(oembedUrl)
                        .then(r => r.json())
                        .then(data => {
                            // Update node with oEmbed data
                            parentNode.mediaMetadata = {
                                ...metadata,
                                title: data.title,
                                thumbnail_url: data.thumbnail_url,
                                author_name: data.author_name,
                                oembed: true
                            };
                            updateGraph();
                        })
                        .catch(() => {
                            // Fallback to generic
                            parentNode.mediaMetadata = metadata;
                            updateGraph();
                        });
                }
            }
            // Transform the parent into a media node
            parentNode.isMediaNode = true;
            parentNode.mediaType = type;
            parentNode.mediaSrc = src;
            parentNode.mediaMetadata = metadata;
            
            // Push transformation to historyStack
            historyStack.push({type: 'transform-media', nodeId: parentNode.id, prevState});
            
            updateGraph();
            simulation.alpha(0.1).restart();
            
            // Show success message
            const mediaTypeNames = {
                'image': 'Image',
                'youtube': 'YouTube Video',
                'vimeo': 'Vimeo Video',
                'twitter': 'Twitter Post',
                'github': 'GitHub Repository',
                'pdf': 'PDF Document',
                'link': 'Link'
            };
            const mediaName = mediaTypeNames[type] || 'Media';
            addAssistantMessage(`Added ${mediaName} to "${parentNode.name}"`, []);
            
            return parentNode;
        }

        // Intelligent link detection with metadata extraction
        function intelligentLinkDetection(url) {
            // 1. YouTube videos
            const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/)|youtu\.be\/)([\w-]{11})/;
            const youtubeMatch = url.match(youtubeRegex);
            if (youtubeMatch && youtubeMatch[1]) {
                return {
                    type: 'youtube',
                    src: `https://www.youtube.com/embed/${youtubeMatch[1]}`,
                    metadata: {
                        videoId: youtubeMatch[1],
                        thumbnail: `https://img.youtube.com/vi/${youtubeMatch[1]}/maxresdefault.jpg`,
                        originalUrl: url
                    }
                };
            }

            // 2. Vimeo videos
            const vimeoRegex = /(?:https?:\/\/)?(?:www\.)?vimeo\.com\/(\d+)/;
            const vimeoMatch = url.match(vimeoRegex);
            if (vimeoMatch && vimeoMatch[1]) {
                return {
                    type: 'vimeo',
                    src: `https://player.vimeo.com/video/${vimeoMatch[1]}`,
                    metadata: {
                        videoId: vimeoMatch[1],
                        originalUrl: url
                    }
                };
            }

            // 3. Twitter/X posts
            const twitterRegex = /(?:https?:\/\/)?(?:www\.)?(?:twitter\.com|x\.com)\/\w+\/status\/(\d+)/;
            const twitterMatch = url.match(twitterRegex);
            if (twitterMatch && twitterMatch[1]) {
                return {
                    type: 'twitter',
                    src: url,
                    metadata: {
                        tweetId: twitterMatch[1],
                        embedUrl: `https://platform.twitter.com/embed/Tweet.html?id=${twitterMatch[1]}`
                    }
                };
            }

            // 4. GitHub repositories
            const githubRegex = /(?:https?:\/\/)?(?:www\.)?github\.com\/([^\/]+)\/([^\/]+)/;
            const githubMatch = url.match(githubRegex);
            if (githubMatch && githubMatch[1] && githubMatch[2]) {
                return {
                    type: 'github',
                    src: url,
                    metadata: {
                        owner: githubMatch[1],
                        repo: githubMatch[2],
                        apiUrl: `https://api.github.com/repos/${githubMatch[1]}/${githubMatch[2]}`
                    }
                };
            }

            // 5. Google Images redirect URLs
            const googleMatch = url.match(/[?&]imgurl=([^&]+)/);
            if (googleMatch && googleMatch[1]) {
                try {
                    const decodedUrl = decodeURIComponent(googleMatch[1]);
                    return {
                        type: 'image',
                        src: decodedUrl,
                        metadata: { source: 'google-images', originalUrl: url }
                    };
                } catch (e) {
                    console.error("Could not decode Google Image URL", e);
                }
            }

            // 6. Unsplash photo pages
            const unsplashMatch = url.match(/unsplash\.com\/photos\/([^/]+)/);
            if (unsplashMatch && unsplashMatch[1]) {
                return {
                    type: 'image',
                    src: `https://source.unsplash.com/${unsplashMatch[1]}`,
                    metadata: { source: 'unsplash', photoId: unsplashMatch[1], originalUrl: url }
                };
            }

            // 7. Direct image URLs
            if (url.startsWith('data:image') || /\.(jpg|jpeg|png|gif|svg|webp)$/i.test(url)) {
                return {
                    type: 'image',
                    src: url,
                    metadata: { source: 'direct' }
                };
            }

            // 8. PDF documents
            if (/\.pdf$/i.test(url)) {
                return {
                    type: 'pdf',
                    src: url,
                    metadata: { fileType: 'pdf' }
                };
            }

            // 9. Extract domain for better link preview
            let domain = '';
            try {
                const urlObj = new URL(url.startsWith('http') ? url : `https://${url}`);
                domain = urlObj.hostname.replace('www.', '');
            } catch (e) {
                domain = url.split('/')[0];
            }

            // 10. Default: generic link with domain info
            return {
                type: 'link',
                src: url,
                metadata: {
                    domain: domain,
                    isSecure: url.startsWith('https://'),
                    favicon: `https://www.google.com/s2/favicons?domain=${domain}&sz=32`
                }
            };
        }

        function transformToMediaNode(node, type, src, metadata = {}) {
            node.isMediaNode = true;
            node.mediaType = type;
            node.mediaSrc = src;
            node.mediaMetadata = metadata;
            
            // If it was another special type, reset it
            node.isListNode = false;
            node.isExpanded = false;

            updateGraph();
            simulation.alpha(0.05).restart();
        }

        // Helper function to add a single list item element
        function addListItemElement(listContainer, item, index, nodeData, textColor) {
            const itemDiv = listContainer.append('xhtml:div')
                .attr('data-list-index', index)
                .style('display', 'flex')
                .style('align-items', 'flex-start')
                .style('font-size', '10pt')
                .style('line-height', '1.1')
                .style('min-height', '14px')
                .style('opacity', 0); // Start invisible for smooth fade-in
            
            if (nodeData.listType === 'bullet') {
                itemDiv.append('xhtml:span')
                    .style('margin-right', '6px')
                    .style('margin-top', '1px')
                    .style('color', textColor)
                    .style('font-weight', 'bold')
                    .style('flex-shrink', '0')
                    .style('font-size', '10pt')
                    .text('•');
            } else if (nodeData.listType === 'numbered') {
                itemDiv.append('xhtml:span')
                    .style('margin-right', '6px')
                    .style('margin-top', '1px')
                    .style('color', textColor)
                    .style('font-weight', '500')
                    .style('flex-shrink', '0')
                    .style('min-width', '14px')
                    .style('font-size', '10pt')
                    .text((index + 1) + '.');
            } else if (nodeData.listType === 'task') {
                itemDiv.append('xhtml:input')
                    .attr('type', 'checkbox')
                    .style('margin-right', '6px')
                    .style('margin-top', '2px')
                    .style('flex-shrink', '0')
                    .style('width', '12px')
                    .style('height', '12px')
                    .property('checked', item.checked)
                    .on('change', function() { item.checked = this.checked; })
                    .on('click', event => event.stopPropagation());
            }
            
            itemDiv.append('xhtml:span')
                .attr('class', 'list-item-text')
                .style('flex-grow', '1')
                .style('color', textColor)
                .style('word-wrap', 'break-word')
                .attr('contenteditable', true)
                .text(item.text)
                .on('mousedown', event => event.stopPropagation())
                .on('keydown', function(event) { 
                    if (event.key === 'Enter') { 
                        event.preventDefault(); 
                        
                        // Check if cursor is at the end of the text
                        const selection = window.getSelection();
                        const range = selection.getRangeAt(0);
                        const textContent = this.textContent;
                        const cursorPosition = range.startOffset;
                        
                        if (cursorPosition === textContent.length) {
                            // Cursor is at the end - create a new bullet point
                            nodeData.listItems.push({
                                text: '',
                                checked: nodeData.listType === 'task' ? false : undefined,
                                id: Date.now()
                            });
                            
                            // Update the graph to show the new item
                            updateGraph();
                            
                            // Focus on the new item after a brief delay
                            setTimeout(() => {
                                const listNode = nodeGroup.selectAll('.node').filter(n => n.id === nodeData.id);
                                const newItemText = listNode.select('.list-items-container')
                                    .selectAll('.list-item-text')
                                    .nodes()[nodeData.listItems.length - 1];
                                
                                if (newItemText) {
                                    newItemText.focus();
                                    // Place cursor at the beginning of the new item
                                    const range = document.createRange();
                                    const sel = window.getSelection();
                                    range.setStart(newItemText, 0);
                                    range.collapse(true);
                                    sel.removeAllRanges();
                                    sel.addRange(range);
                                }
                            }, 50);
                        } else {
                            // Cursor is not at the end - just blur (exit editing)
                            this.blur(); 
                        }
                    } 
                    event.stopPropagation(); 
                })
                .on('blur', function() { 
                    item.text = this.innerText; 
                })
                .on('click', function(event) { 
                    event.stopPropagation();
                    // Enter list adding mode when clicking on list item text
                    isListEntryMode = true;
                    activeListNode = nodeData;
                    selectedNode = nodeData;
                    updateUserInstruction(`Adding items to list "${nodeData.name}" • Enter to add item • Shift+Enter for child node`);
                    nodeInput.focus();
                    
                    // Update UI to show the node as selected
                    nodeGroup.selectAll('.node').classed('selected', false);
                    nodeGroup.selectAll('.node').filter(n => n.id === nodeData.id).classed('selected', true);
                    
                    // Show action buttons
                    summarizeBtn.style.display = 'inline-block';
                    elaborateBtn.style.display = 'inline-block';
                });
            
            // Smooth fade-in for new items
            itemDiv.transition()
                .duration(300)
                .style('opacity', 1);
        }



        

        // 12. Make functions available globally (removed duplicates)
        
        // Generate contextual focus for re-selected nodes
        function generateContextualFocus(node, cardData) {
            const responses = [];
            const nodeName = node.name.toLowerCase();
            
            // Show focused information based on the existing card data
            if (cardData.analysis && cardData.analysis.definitions && cardData.analysis.definitions.length > 0) {
                responses.push('📚 Key Definitions:\n' + cardData.analysis.definitions.slice(0, 2).map(def => 
                    `• ${def.term}: ${def.definition}`).join('\n'));
            }
            
            if (cardData.ghostNodeSuggestions && cardData.ghostNodeSuggestions.length > 0) {
                responses.push('💡 Explore these related ideas:\n' + cardData.ghostNodeSuggestions.slice(0, 3).map(s => 
                    `• ${s}`).join('\n'));
            }
            
            if (cardData.analysis && cardData.analysis.probingQuestion) {
                responses.push(`🤔 Consider this: ${cardData.analysis.probingQuestion}`);
            }
            
            if (cardData.mapInsights && cardData.mapInsights.structuralSuggestion) {
                responses.push(`🏗️ Structure tip: ${cardData.mapInsights.structuralSuggestion.description}`);
            }
            
            // Add contextual prompts based on node type
            if (nodeName.includes('project') || nodeName.includes('work')) {
                responses.push('🎯 Next steps:\n• What specific aspects would you like to explore?\n• Are there any challenges you\'re facing?\n• What resources do you need?');
            } else if (nodeName.includes('tool') || nodeName.includes('equipment')) {
                responses.push('🎯 Next steps:\n• What specific tools are you looking for?\n• What\'s your experience level?\n• What\'s your budget range?');
            } else if (nodeName.includes('hobby') || nodeName.includes('interest')) {
                responses.push('🎯 Next steps:\n• What interests you most about this?\n• How much time can you dedicate?\n• What\'s your learning goal?');
            } else {
                responses.push('🎯 Next steps:\n• What specific aspect interests you?\n• What would you like to explore further?\n• How can I help you dive deeper?');
            }
            
            return responses.join('\n\n');
        }



        // --- Polyfills for Flow Assistant context ---
        function getParentNode(node) {
            if (!node) return null;
            const parentLink = links.find(l => l.target.id === node.id);
            return parentLink ? parentLink.source : null;
        }
        function getSiblingNodes(node) {
            if (!node) return [];
            const parent = getParentNode(node);
            if (!parent) return [];
            return nodes.filter(n => {
                const parentLink = links.find(l => l.target.id === n.id);
                return parentLink && parentLink.source.id === parent.id && n.id !== node.id;
            });
        }
        function getFullMapStructure() {
            // Return a simple array of node objects with id, text, parentId
            return nodes.map(n => ({
                id: n.id,
                text: n.name,
                parentId: getParentNode(n)?.id || null
            }));
        }
        function getMapGoal() {
            // Use the central node's text as the map goal
            const central = nodes.find(n => n.depth === 0);
            return central ? central.name : '';
        }

       
        // ... existing code ...



        // Update node appearance to show notes
        function updateNodeAppearance(node) {
            const nodeElement = nodeGroup.selectAll('.node').filter(d => d.id === node.id);
            if (node.notes && node.notes.length > 0) {
                nodeElement.select('circle').style('stroke', '#66ff77').style('stroke-width', '2px');
            }
        }



         // Ghost node click handlers removed - now using direct onclick handlers in suggestion chips

        // Add CSS animation for feedback
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeInOut {
                0% { opacity: 0; transform: translateY(-10px); }
                20%, 80% { opacity: 1; transform: translateY(0); }
                100% { opacity: 0; transform: translateY(-10px); }
            }
        `;
        document.head.appendChild(style);

        // Enhanced drag and drop for nodes
        function setupNodeDropTargets() {
            // Handle drag over nodes
            nodeGroup.selectAll('.node')
                .on('dragover', function(event, d) {
                    event.preventDefault();
                    d3.select(this).classed('drop-target-notes', true);
                })
                .on('dragleave', function(event, d) {
                    d3.select(this).classed('drop-target-notes', false);
                })
                .on('drop', function(event, d) {
                    event.preventDefault();
                    d3.select(this).classed('drop-target-notes', false);
                    
                    const flowData = event.dataTransfer.getData('application/flow-content');
                    if (flowData) {
                        const data = JSON.parse(flowData);
                        addToNodeNotes(d, data.content);
                        showFeedback(`Added "${data.content}" to ${d.name}`);
                    }
                });
        }

        // Handle drop on empty space to create new node
        svg.on('drop', function(event) {
            event.preventDefault();
            const flowData = event.dataTransfer.getData('application/flow-content');
            if (flowData) {
                const data = JSON.parse(flowData);
                const coords = d3.pointer(event);
                const newNode = createNodeAtPosition(data.content, coords[0], coords[1]);
                if (newNode) {
                    showFeedback(`Created new node: "${data.content}"`);
                }
            }
        });

        svg.on('dragover', function(event) {
            event.preventDefault();
        });

                 // Helper function to get node color based on depth and dynasty
         function getNodeColor(depth, dynastyIndex = 0) {
             if (depth === 0) return "#FFFFFF"; // Central node is always white
             
             // Ensure we have valid dynasty palettes
             if (!dynastyPalettes || dynastyPalettes.length === 0) {
                 initializeDynastyPalettes();
             }
             
             // Use specified dynasty palette or fallback to first one
             const paletteIndex = Math.min(dynastyIndex, dynastyPalettes.length - 1);
             const palette = dynastyPalettes[paletteIndex];
             
             if (!palette || palette.length === 0) {
                 console.error('Invalid palette:', paletteIndex);
                 return "#58A6FF"; // Fallback color
             }
             
             // For first generation nodes (depth=1), use the first color in the palette
             if (depth === 1) {
                 return ensureTextVisible(palette[0]);
             }
             
             // For deeper generations, create smooth transitions through the palette
             const relativeDepth = depth - 1; // Adjust depth to be relative to first generation
             const colorIndex = Math.min(relativeDepth, palette.length - 1);
             
             // For 3rd+ generation, create gradient blending between colors
             if (depth >= 3 && colorIndex < palette.length - 1) {
                 const baseColor = d3.color(palette[colorIndex - 1]);
                 const nextColor = d3.color(palette[colorIndex]);
                 const blendFactor = (depth - 3) % 1; // Smooth transition between colors
                 
                 if (baseColor && nextColor) {
                     const blendedColor = d3.interpolate(baseColor, nextColor)(blendFactor);
                     return ensureTextVisible(blendedColor.toString());
                 }
             }
             
             return ensureTextVisible(palette[colorIndex]);
         }

         // Create node at specific position
         function createNodeAtPosition(name, x, y) {
             const newNode = {
                 id: nextId++,
                 name: name,
                 depth: selectedNode ? selectedNode.depth + 1 : 0,
                 children: [],
                 x: x,
                 y: y,
                 color: getNodeColor(selectedNode ? selectedNode.depth + 1 : 0),
                 isListNode: false,
                 isMediaNode: false,
                 mediaType: null,
                 mediaSrc: null,
                 mediaMetadata: {},
                 createdAt: Date.now(),
                 notes: []
             };
             
             nodes.push(newNode);
             
             // Create link if there's a selected node
             if (selectedNode) {
                 links.push({
                     source: selectedNode,
                     target: newNode,
                     targetDistance: 80
                 });
             }
             
             updateGraph();
             simulation.alpha(0.1).restart();
             return newNode;
         }

        // Proactive, always-on Flow Assistant background analysis loop
        let lastUserAction = Date.now();
        let lastMapHash = '';
        let idleTimeout = null;
        let idleDelay = 2000; // Reduced from 4000ms to 2000ms for faster background processing

        function getMapHash() {
            return nodes.map(n => `${n.id}:${n.name}:${n.depth}`).sort().join('|');
        }

        function triggerFlowAssistant(reason = 'proactive') {
            if (selectedNode) {
                if (flowAssistantActive) {
                    generateInteractiveInfoCard(selectedNode);
                }
            } else if (nodes.length > 0) {
                // Fallback: use central node
                const central = nodes.find(n => n.depth === 0);
                if (central && flowAssistantActive) {
                    generateInteractiveInfoCard(central);
                }
            }
        }

        function onUserAction() {
            lastUserAction = Date.now();
            if (idleTimeout) clearTimeout(idleTimeout);
            idleTimeout = setTimeout(() => {
                triggerFlowAssistant('idle');
            }, idleDelay);
        }

        // Listen for user actions
        ['keydown', 'mousedown', 'mousemove', 'touchstart'].forEach(evt => {
            window.addEventListener(evt, onUserAction, true);
        });

        // Listen for node selection
        function onNodeSelection(node) {
            if (flowAssistantActive) {
                generateInteractiveInfoCard(node);
            }
            onUserAction();
        }

        // Initial idle trigger
        idleTimeout = setTimeout(() => {
            triggerFlowAssistant('initial');
        }, idleDelay);

        // Ghost node management
        let currentGhostNodes = [];
        let ghostNodeParentId = null;

        function renderGhostNodes() {
            // Remove existing ghost nodes
            d3.selectAll('.ghost-node').remove();
            if (!selectedNode || !currentGhostNodes || currentGhostNodes.length === 0) return;
            const parent = selectedNode;
            const angleStep = Math.PI * 2 / currentGhostNodes.length;
            const radius = (parent.r || 40) + 60;
            currentGhostNodes.forEach((suggestion, i) => {
                const angle = i * angleStep - Math.PI / 2;
                const x = parent.x + Math.cos(angle) * radius;
                const y = parent.y + Math.sin(angle) * radius;
                d3.select('#mindmap-svg').append('g')
                    .attr('class', 'ghost-node')
                    .attr('transform', `translate(${x},${y})`)
                    .append('circle')
                    .attr('r', 32)
                    .attr('fill', 'rgba(255,255,255,0.4)')
                    .attr('stroke', '#e58d47')
                    .attr('stroke-dasharray', '6,4')
                    .attr('stroke-width', 2)
                    .style('opacity', 0.7)
                    .style('animation', `breathe ${2 + i * 0.3}s ease-in-out infinite`);
                d3.select('#mindmap-svg').append('g')
                    .attr('class', 'ghost-node')
                    .attr('transform', `translate(${x},${y})`)
                    .append('text')
                    .attr('text-anchor', 'middle')
                    .attr('dy', '0.35em')
                    .attr('font-size', '13px')
                    .attr('fill', '#e58d47')
                    .attr('pointer-events', 'none')
                    .text(suggestion);
                // Add click handler
                d3.select('#mindmap-svg').append('g')
                    .attr('class', 'ghost-node clickable')
                    .attr('transform', `translate(${x},${y})`)
                    .append('circle')
                    .attr('r', 32)
                    .attr('fill', 'transparent')
                    .style('cursor', 'pointer')
                    .on('click', () => {
                        addNode(suggestion, parent);
                        currentGhostNodes = [];
                        ghostNodeParentId = null;
                        renderGhostNodes();
                        updateGraph();
                    });
            });
        }

        // Remove ghost nodes on context change
        function clearGhostNodes() {
            currentGhostNodes = [];
            ghostNodeParentId = null;
            d3.selectAll('.ghost-node').remove();
        }

        // Update ghost nodes after each assistant response
        function updateGhostNodesFromAI(parsed) {
            if (parsed.proactiveNodeSuggestions && parsed.proactiveNodeSuggestions.length > 0 && selectedNode) {
                currentGhostNodes = parsed.proactiveNodeSuggestions;
                ghostNodeParentId = selectedNode.id;
            } else {
                currentGhostNodes = [];
                ghostNodeParentId = null;
            }
            renderGhostNodes();
        }

        // Call updateGhostNodesFromAI after parsing the AI response in appendAssistantChatMessageWithTyping
        // Remove ghost nodes on node selection, map change, or user action
        function onAnyContextChange() {
            clearGhostNodes();
        }
        ['keydown', 'mousedown', 'mousemove', 'touchstart'].forEach(evt => {
            window.addEventListener(evt, onAnyContextChange, true);
        });
        // Also call clearGhostNodes in updateGraph and onNodeSelection
        // ... existing code ...

        // Ensure the chat always scrolls to the bottom after new messages
        function scrollAssistantMessagesToBottom() {
            const assistantMessages = document.getElementById('assistant-messages');
            assistantMessages.scrollTop = assistantMessages.scrollHeight;
        }
        // Call this after adding a new assistant message
        // Example: after appendAssistantChatMessageWithTyping or similar

        // Add this placeholder if not already defined
        function clearFlowAssistantState() {
          // Placeholder: implement as needed
        }

        function addToNodeNotes(nodeId, content) {
            const node = nodes.find(n => n.id === nodeId);
            if (node) {
                if (!node.notes) node.notes = [];
                node.notes.push(content);
                updateGraph();
                flashNode(nodeId);
            }
        }
        window.addToNodeNotes = addToNodeNotes;

        function addToListItems(nodeId, content) {
            const node = nodes.find(n => n.id === nodeId);
            if (node) {
                if (!node.listItems) node.listItems = [];
                node.listItems.push(content);
                // Convert to list node if not already
                if (!node.isListNode) {
                    node.isListNode = true;
                }
                updateGraph();
                flashNode(nodeId);
            }
        }
        window.addToListItems = addToListItems;

        // Add missing createNodeFromHighlightedText function
        function createNodeFromHighlightedText(text, x, y) {
            const newNode = addNode(text, selectedNode);
            if (newNode) {
                newNode.x = x;
                newNode.y = y;
                updateGraph();
                flashNode(newNode.id);
            }
        }

        // Make functions available globally
        window.addToNodeNotes = addToNodeNotes;
        window.addToListItems = addToListItems;
        window.createNodeFromHighlightedText = createNodeFromHighlightedText;
        
        // Generate contextual focus for re-selected nodes
    </script>
</body>
</html>
