<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CogniFlow - The LLM-Powered Idea Synthesizer</title>
    <link rel="icon" href="data:,">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/svg-to-pdfkit@0.1.8/source.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --ui-bg-dark: #0d0d0d;
            --ui-input-bg-dark: #2c2c2c;
            --ui-border-dark: #444444;
            --ui-text-dark: #e0e0e0;
            --ui-focus-dark: #e58d47;
        }

        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            transition: background-color 0.8s;
        }

        #mindmap-container { flex-grow: 1; position: relative; background: transparent; }
        svg { display: block; width: 100%; height: 100%; }
        
        .link {
            fill: none;
            stroke-opacity: 0.6;
            stroke-width: 2.5px;
            stroke-linecap: round;
        }

        .node { cursor: pointer; }
        .node circle {
            stroke-width: 0;
            stroke: transparent;
            transition: stroke 0.3s, stroke-width 0.3s, filter 0.3s;
        }
        .node.selected circle {
            stroke-width: 4px;
        }
        .node.flashing circle {
            animation: flash 1s ease-out;
        }

        .node text {
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: central;
            font-weight: 500;
            transition: fill 0.8s;
            fill: #FFFFFF;
        }
        
        #bottom-panel {
            height: 20vh;
            min-height: 120px;
            resize: vertical;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            border-top-width: 1px;
            background-color: var(--ui-bg-dark);
            border-color: var(--ui-border-dark);
            color: var(--ui-text-dark);
        }

        #suggestion-panel {
            flex-grow: 1;
            padding: 1rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        #input-container {
            padding: 1rem;
            border-top-width: 1px;
            display: flex;
            gap: 0.5rem;
            align-items: center;
            border-color: var(--ui-border-dark);
        }

        #node-input {
            flex-grow: 1;
            padding: 0.75rem;
            border-radius: 8px;
            border: 1px solid var(--ui-border-dark);
            outline: none;
            background-color: var(--ui-input-bg-dark);
            color: var(--ui-text-dark);
        }
        #node-input:focus {
            border-color: var(--ui-focus-dark);
        }

        .ai-button {
            padding: 0.75rem 1rem;
            border-radius: 8px;
            border: 1px solid var(--ui-border-dark);
            background-color: var(--ui-input-bg-dark);
            color: var(--ui-text-dark);
            cursor: pointer;
            white-space: nowrap;
            transition: background-color 0.2s, border-color 0.2s;
            display: none;
        }
        .ai-button:hover {
            border-color: var(--ui-focus-dark);
        }
        
        .suggestion-container {
            align-self: flex-start;
            width: 100%;
            padding: 0.5rem;
            border: 1px dashed var(--ui-border-dark);
            border-radius: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .suggestion-node {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            border-radius: 20px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .suggestion-node:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        .suggestion-node .plus-icon {
            font-weight: bold;
        }
        
         .ai-response-bubble {
            align-self: flex-start;
            max-width: 80%;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            background-color: var(--ui-input-bg-dark);
            border: 1px solid var(--ui-border-dark);
        }
        .ai-response-bubble h3 {
            font-weight: bold;
            margin-bottom: 0.25rem;
            color: var(--ui-focus-dark);
        }

        .loading-indicator {
            position: absolute;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            display: none;
            z-index: 1000;
        }

        .expanded-node-container {
            border-radius: 16px;
            padding: 1rem;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            backdrop-filter: blur(5px);
        }

        .expanded-node-container h2 {
            font-size: 1.2rem;
            font-weight: bold;
            margin: 0;
            padding: 0;
            text-align: center;
            cursor: text;
        }
        
        .expanded-node-container textarea {
            flex-grow: 1;
            border: 1px solid transparent;
            border-radius: 8px;
            padding: 0.5rem;
            resize: none;
            outline: none;
            transition: border-color 0.3s;
        }

        .notes-editor {
            flex-grow: 1;
            overflow-y: auto;
            outline: none;
            padding: 0.5rem;
            border-radius: 8px;
        }

        @keyframes flash {
            0% { filter: drop-shadow(0 0 0px #ffffff); }
            50% { filter: drop-shadow(0 0 12px #ffffff); }
            100% { filter: drop-shadow(0 0 0px #ffffff); }
        }
    </style>
</head>
<body>

    <div id="mindmap-container">
        <svg id="mindmap-svg"></svg>
        <div id="loading-indicator" class="loading-indicator">CogniFlow is thinking...</div>
    </div>
    
    <div id="bottom-panel" id="bottom-panel">
        <div id="suggestion-panel">
            <div id="initial-help-text" class="text-center text-gray-500">
                Enter your central idea to begin.
            </div>
        </div>
        <div id="input-container">
            <input type="text" id="node-input" placeholder="Enter your central idea...">
            <button id="summarize-btn" class="ai-button">✨ Summarize</button>
            <button id="elaborate-btn" class="ai-button">✨ Elaborate</button>
        </div>
    </div>

    <script type="module">
        // --- Setup ---
        const svg = d3.select("#mindmap-svg");
        const suggestionPanel = document.getElementById('suggestion-panel');
        const nodeInput = document.getElementById('node-input');
        const summarizeBtn = document.getElementById('summarize-btn');
        const elaborateBtn = document.getElementById('elaborate-btn');
        const loadingIndicator = document.getElementById('loading-indicator');
        const container = document.getElementById('mindmap-container');
        
        let nodes = [];
        let links = [];
        let nextId = 0;
        let selectedNode = null;
        let isPrimedForChild = false;
        let historyStack = [];
        let isAnimatingExit = false;

        // --- New Color & Theme Engine ---
        const dynastyPalettes = [
            // Palette 1 - Pink to Blue gradient
            ["#e58d8d", "#b5738c", "#7a6b9f", "#4e6b9f"],
            // Palette 2 - Dark Red to Yellow gradient  
            ["#5d1a3a", "#8e3a59", "#d44a5c", "#f5e65c"],
            // Palette 3 - Orange to Purple gradient
            ["#f0a84a", "#d6704a", "#d44a72", "#8e3a8e"],
            // Palette 4 - Dark Teal to Light gradient
            ["#2f4b4b", "#4a7b7b", "#8eb5b5", "#e2f8f5"],
            // Palette 5 - Navy to Yellow gradient
            ["#2d3e5d", "#4a6b4a", "#8eb55c", "#f5e65c"],
            // Palette 6 - Light Green to Purple gradient
            ["#b5d95f", "#69aeff", "#8e7bef", "#6b4a8e"],
            // Palette 7 - Red to Green gradient
            ["#d44a4a", "#e6a84a", "#f5e65c", "#8eb55c"],
            // Palette 8 - Green to Muted Teal gradient
            ["#8eb55c", "#f5ff65", "#008080", "#e58d65"]
        ];
        
        const paletteIndex = Math.floor(Math.random() * dynastyPalettes.length);
        
        // Track which palette each first-gen node gets
        let firstGenPaletteAssignment = new Map();
        
        const defs = svg.append("defs");

        function applyTheme() {
            // Set the focus color for UI elements
            document.querySelector(':root').style.setProperty('--ui-focus-dark', dynastyPalettes[paletteIndex][0]);
            
            // Create a very dark, desaturated background gradient
            const paletteColor = dynastyPalettes[paletteIndex][2] || '#888888';
            const baseColor = d3.hsl(paletteColor);
            baseColor.s *= 0.3; // Reduce saturation significantly
            
            const centerColor = d3.color(baseColor).darker(4).toString();
            const edgeColor = d3.color(baseColor).darker(6).toString();

            document.body.style.background = `radial-gradient(ellipse at center, ${centerColor} 0%, ${edgeColor} 100%)`;
        }
        
        // Helper function to check if a color is too bright for white text
        function isColorTooBright(color) {
            const rgb = d3.rgb(color);
            const luminance = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;
            return luminance > 0.7; // Threshold for white text visibility
        }
        
        // Helper function to darken a color if it's too bright
        function ensureTextVisible(color) {
            if (isColorTooBright(color)) {
                return d3.color(color).darker(1.5).toString();
            }
            return color;
        }

        function outwardForce(alpha) {
            const rootNode = nodes[0];
            if (!rootNode) return;

            const strength = 0.04; 

            nodes.forEach(node => {
                if (node === rootNode) return;

                const dx = node.x - rootNode.x;
                const dy = node.y - rootNode.y;
                const distance = Math.hypot(dx, dy) || 1;
                
                const force = strength * alpha;
                
                node.vx += (dx / distance) * force;
                node.vy += (dy / distance) * force;
            });
        }

        const simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).id(d => d.id).distance(d => d.targetDistance).strength(0.7))
            .force("charge", d3.forceManyBody().strength(-400))
            .force("collide", d3.forceCollide().radius(d => d.radius + 20).strength(1))
            .force("outward", outwardForce);

        const masterGroup = svg.append("g");
        let linkGroup = masterGroup.append("g");
        let nodeGroup = masterGroup.append("g");
        
        const zoom = d3.zoom().scaleExtent([0.1, 2]).on("zoom", (event) => {
            masterGroup.attr("transform", event.transform);
        });
        svg.call(zoom);

        d3.select(container).on('click', handleBackgroundClick);

        // --- Core Functions ---
        function updateGraph() {
            linkGroup.selectAll(".link")
                .data(links, d => `${d.source.id}-${d.target.id}`)
                .join("path")
                .attr("class", "link")
                .attr("stroke", d => d.source.color) 
                .style("stroke-opacity", 0.5);

            const node = nodeGroup.selectAll(".node")
                .data(nodes, d => d.id);
            
            node.exit().transition().duration(750).attr("transform", "scale(0)").remove();
            
            const nodeEnter = node.enter().append("g")
                .attr("class", "node")
                .on("click", handleNodeClick)
                .on("dblclick", handleNodeDoubleClick)
                .call(d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended));

            nodeEnter.append("circle");
            nodeEnter.append("text");

            const nodeUpdate = nodeEnter.merge(node);
            
            nodeUpdate.each(function(d) {
                const el = d3.select(this);
                const nodeColor = d.color;

                // Clean up elements from other states
                el.selectAll('text, foreignObject').remove();

                if (d.isExpanded) {
                    el.raise();
                    const foWidth = 300;
                    const foHeight = 200;

                    // Hide the original circle and text
                    el.select('circle').transition().duration(300).attr('r', 0);
                    
                    const fo = el.append('foreignObject')
                        .attr('x', -d.radius)
                        .attr('y', -d.radius)
                        .attr('width', d.radius * 2)
                        .attr('height', d.radius * 2)
                        .style('opacity', 0)
                        .style('pointer-events', 'all')
                        .on('click', event => event.stopPropagation());

                    fo.transition().duration(800).ease(d3.easeCubicInOut)
                        .attr('x', -foWidth / 2)
                        .attr('y', -foHeight / 2)
                        .attr('width', foWidth)
                        .attr('height', foHeight)
                        .style('opacity', 1);

                    const baseColor = d.color === '#FFFFFF' ? '#EAEAEA' : d.color;
                    const bgColor = d3.color(baseColor);
                    bgColor.opacity = 0.95;
                    const textColor = isColorTooBright(baseColor) ? '#000000' : '#FFFFFF';
                    const h2Color = isColorTooBright(baseColor) ? d3.color(baseColor).darker(1.5) : d3.color(baseColor).brighter(1.5);

                    const div = fo.append('xhtml:div')
                        .attr('class', 'expanded-node-container')
                        .style('width', '100%')
                        .style('height', '100%')
                        .style('background-color', bgColor)
                        .style('color', textColor);
                    
                    div.append('xhtml:h2')
                        .style('font-weight', 400)
                        .style('color', h2Color)
                        .attr('contenteditable', true)
                        .text(d.name)
                        .on('mousedown', event => event.stopPropagation())
                        .on('keydown', function(event) {
                            event.stopPropagation();
                            if (event.key === 'Enter') {
                                event.preventDefault();
                                this.blur();
                            }
                        })
                        .on('blur', function() {
                            d.name = this.innerText;
                            updateGraph();
                        });

                    const notesEditor = div.append('xhtml:div')
                        .attr('class', 'notes-editor')
                        .attr('contenteditable', true)
                        .style('color', textColor)
                        .on('mousedown', event => event.stopPropagation())
                        .on('keydown', event => {
                            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
                                event.stopPropagation();
                            }
                        })
                        .on('blur', function() {
                             d.notes = this.innerHTML;
                        });
                    
                    notesEditor.html(d.notes || '');

                } else if (d.depth === 0) {
                    d.radius = 70;
                    
                    const maxFontSize = 36;
                    const minFontSize = 12;
                    const padding = 10;
                    const availableWidth = d.radius * 2 - (padding * 2);

                    const text = el.append('text')
                        .attr('dy', '.35em');
                    
                    let fontSize = Math.min(maxFontSize, availableWidth / (d.name.length * 0.6));
                    fontSize = Math.max(minFontSize, fontSize);
                    
                    text.style('font-size', `${fontSize}px`)
                        .style('letter-spacing', '-1px');
                    text.text(d.name);

                } else { // Handles d.depth > 0
                    d.radius = d.depth === 1 ? 40 : 25;

                    const text = el.append('text')
                        .text(d.name);
                    
                    const baseSizePt = 24;
                    const decreasePt = 6;
                    const minSizePt = 9;
                    
                    const fontSizePt = Math.max(minSizePt, baseSizePt - ((d.depth - 1) * decreasePt));
                    
                    text.style('font-size', `${fontSizePt}pt`);

                    if (d.depth === 1) {
                        text.attr('dy', '.35em')
                            .style('letter-spacing', '2px');
                    } else {
                        const fontSizePx = fontSizePt * 4/3;
                        text.attr('dy', d.radius + fontSizePx * 0.7)
                            .style('letter-spacing', 'normal');
                    }
                }
                
                const circle = el.select('circle')
                    .attr('fill', nodeColor)
                    .attr('stroke', isColorTooBright(nodeColor) ? d3.color(nodeColor).darker(1.5) : d3.color(nodeColor).brighter(1.5));

                if (d.isClosing) {
                    // Animate the circle shrinking in
                    circle.attr('r', d.radius * 1.5).style('opacity', 0)
                        .transition()
                        .duration(300) // fast
                        .ease(d3.easeCubicOut)
                        .attr('r', d.radius)
                        .style('opacity', 1);
                    delete d.isClosing;
                } else {
                    // Set radius normally and ensure opacity is correct for non-animating nodes
                    circle.attr('r', d.radius);
                    if (!d.isExpanded) {
                        circle.style('opacity', 1);
                    }
                }

                if (!d.isExpanded) {
                    el.select('text').style('fill', isColorTooBright(nodeColor) ? '#000000' : '#FFFFFF');
                }
            });
            
            simulation.nodes(nodes);
            simulation.force("link").links(links);
            simulation.alpha(1).restart();
            
            optimizeView();
        }

        function generateBranchPath(d) {
            const path = d3.path();
            path.moveTo(d.source.x, d.source.y);
            const midX = d.source.x + (d.target.x - d.source.x) * 0.5 - (d.target.y - d.source.y) * d.cp_dx_factor;
            const midY = d.source.y + (d.target.y - d.source.y) * 0.5 + (d.target.x - d.source.x) * d.cp_dy_factor;
            path.quadraticCurveTo(midX, midY, d.target.x, d.target.y);
            return path.toString();
        }
        
        simulation.on("tick", () => {
            linkGroup.selectAll(".link").attr("d", generateBranchPath);
            nodeGroup.selectAll(".node").attr("transform", d => `translate(${d.x},${d.y})`);
        });
        
        function optimizeView() {
            if (nodes.length === 0) return;
            const padding = 150;
            const xExtent = d3.extent(nodes, d => d.x);
            const yExtent = d3.extent(nodes, d => d.y);
            if (xExtent[0] === undefined) return;
            const [x0, x1] = xExtent;
            const [y0, y1] = yExtent;
            const fullWidth = x1 - x0;
            const fullHeight = y1 - y0;
            if (fullWidth === 0 || fullHeight === 0) return;
            const midX = x0 + fullWidth / 2;
            const midY = y0 + fullHeight / 2;
            const scale = Math.min(1.2, 0.9 / Math.max((fullWidth + padding) / container.clientWidth, (fullHeight + padding) / container.clientHeight));
            const transform = d3.zoomIdentity.translate(container.clientWidth / 2 - scale * midX, container.clientHeight / 2 - scale * midY).scale(scale);
            svg.transition().duration(900).call(zoom.transform, transform);
        }

        // --- Interaction Logic ---
        function addNode(name, parent = null) {
            if (!name.trim()) return null;
            let newNode;
            if (nodes.length === 0) {
                // Root node gets white color
                const color = "#FFFFFF";
                newNode = {id: nextId++, name, depth: 0, children:[], x: container.clientWidth / 2, y: container.clientHeight / 2, fx: container.clientWidth / 2, fy: container.clientHeight / 2, color: color };
                nodes.push(newNode);
            } else {
                if(!parent) return null;
                const depth = parent.depth + 1;
                const targetDistance = 90 * Math.pow(1.1, depth);
                
                // Ensure parent.children array exists before using it.
                if (!parent.children) parent.children = [];

                let finalColor;
                if (depth === 1) {
                    // First generation: each child gets a unique palette
                    const availablePalettes = dynastyPalettes.filter((_, idx) => {
                        // Check if this palette is already used by a sibling
                        return !Array.from(firstGenPaletteAssignment.values()).includes(idx);
                    });
                    
                    // If all palettes are used, cycle back
                    const paletteIdx = availablePalettes.length > 0 
                        ? dynastyPalettes.indexOf(availablePalettes[0])
                        : parent.children.length % dynastyPalettes.length;
                    
                    firstGenPaletteAssignment.set(nextId, paletteIdx);
                    // Use the first (darkest) color from the palette
                    finalColor = ensureTextVisible(dynastyPalettes[paletteIdx][0]);
                } else {
                    // Deeper generations: inherit from their dynasty's palette
                    let firstGenAncestor = parent;
                    while (firstGenAncestor.depth > 1) {
                        const parentLink = links.find(l => l.target.id === firstGenAncestor.id);
                        firstGenAncestor = parentLink ? parentLink.source : null;
                    }
                    
                    const dynastyPaletteIdx = firstGenPaletteAssignment.get(firstGenAncestor.id);
                    if (dynastyPaletteIdx !== undefined) {
                        const palette = dynastyPalettes[dynastyPaletteIdx];
                        // Use deeper colors in the palette for deeper generations
                        const colorIndex = Math.min(depth - 2, palette.length - 1);
                        finalColor = ensureTextVisible(palette[colorIndex]);
                    } else {
                        // Fallback: just brighten parent color
                        finalColor = ensureTextVisible(d3.color(parent.color).brighter(0.3).toString());
                    }
                }

                const rootNode = nodes[0];
                const parentAngle = Math.atan2(parent.y - rootNode.y, parent.x - rootNode.x);
                const coneWidth = (160 * Math.PI) / 180;
                const coneStart = parentAngle - coneWidth / 2;
                const siblingAngles = (parent.children || []).map(child => Math.atan2(child.y - parent.y, child.x - parent.x)).sort((a,b) => a - b);
                let bestAngle = parentAngle; 

                if (siblingAngles.length > 0) {
                    let maxGap = 0;
                    let angleAtMaxGap = -1;
                    let normalizedSiblings = siblingAngles.map(a => {
                        let norm = a - coneStart;
                        while(norm < 0) norm += 2 * Math.PI;
                        return norm % (2 * Math.PI);
                    }).filter(a => a <= coneWidth + 0.001).sort((a,b)=>a-b);
                    if (normalizedSiblings.length === 0) {
                        bestAngle = parentAngle;
                    } else {
                        maxGap = normalizedSiblings[0];
                        angleAtMaxGap = coneStart + maxGap / 2;
                        for(let i=0; i < normalizedSiblings.length; i++){
                            const nextSiblingAngle = i === normalizedSiblings.length - 1 ? coneWidth : normalizedSiblings[i+1];
                            let gap = nextSiblingAngle - normalizedSiblings[i];
                            if (gap > maxGap) {
                                maxGap = gap;
                                angleAtMaxGap = coneStart + normalizedSiblings[i] + gap / 2;
                            }
                        }
                        bestAngle = angleAtMaxGap;
                    }
                }
                
                const initialPlacementRadius = 20;
                const initialX = parent.x + initialPlacementRadius * Math.cos(bestAngle);
                const initialY = parent.y + initialPlacementRadius * Math.sin(bestAngle);

                newNode = {id: nextId++, name, depth, children: [], x: initialX, y: initialY, color: finalColor };
                nodes.push(newNode);

                links.push({ 
                    source: parent, target: newNode, 
                    targetDistance: targetDistance,
                    cp_dx_factor: (Math.random() - 0.5) * 0.4, cp_dy_factor: (Math.random() - 0.5) * 0.4
                });
                if(!parent.children) parent.children = [];
                parent.children.push(newNode);
            }
            historyStack.push(newNode);
            updateGraph();
            triggerProactiveSuggestions(newNode);
            return newNode;
        }

        function removeNode(nodeToRemove) {
            if (!nodeToRemove) return;
            const nodesToDelete = new Set([nodeToRemove.id]);
            const findDescendants = (nodeId) => links.filter(l => l.source.id === nodeId).forEach(l => {
                nodesToDelete.add(l.target.id);
                findDescendants(l.target.id);
            });
            findDescendants(nodeToRemove.id);
            nodes = nodes.filter(n => !nodesToDelete.has(n.id));
            links = links.filter(l => !nodesToDelete.has(l.source.id) && !nodesToDelete.has(l.target.id));
            if (selectedNode && nodesToDelete.has(selectedNode.id)) {
                selectedNode = null;
                summarizeBtn.style.display = 'none';
                elaborateBtn.style.display = 'none';
            }
            updateGraph();
        }

        function selectNode(d) {
            selectedNode = d;
            updateGraph();
            
            if (isPrimedForChild) {
                nodeInput.placeholder = `Add child to "${d.name}" (Press Enter)...`;
            } else {
                nodeInput.placeholder = `Sibling (Enter) or Child (Shift+Enter) of "${d.name}"...`;
            }
        }

        function handleNodeClick(event, d) {
            event.stopPropagation();
            selectNode(d);
            nodeInput.focus();
        }
        
        function handleNodeDoubleClick(event, d) {
            if (event) event.stopPropagation();
            
            // Collapse any other expanded node
            nodes.forEach(n => {
                if (n.isExpanded && n.id !== d.id) {
                    n.isExpanded = false;
                }
            });

            // Toggle the current node's expanded state
            d.isExpanded = !d.isExpanded;

            // Pin the node in place when expanded
            if(d.isExpanded) {
                d.fx = d.x;
                d.fy = d.y;
            } else {
                d.fx = null;
                d.fy = null;
            }

            updateGraph();
            simulation.alpha(1).restart();
            centerOnNode(d);
        }
        
        nodeInput.addEventListener('keydown', (event) => {
            if (event.key !== 'Enter' || !nodeInput.value.trim()) return;
            event.preventDefault();

            saveToHistory();

            // Collapse any expanded node before adding a new one
            let needsUpdate = false;
            nodes.forEach(n => {
                if (n.isExpanded) {
                    n.isExpanded = false;
                    n.fx = null;
                    n.fy = null;
                    needsUpdate = true;
                }
            });

            const text = nodeInput.value.trim();
            let newNode;

            // First node creation
            if (!selectedNode) {
                newNode = addNode(text, null);
            }
            // If a node is selected, handle primed vs. standard mode
            else {
                if (isPrimedForChild) {
                    // In primed state, Enter always adds a child
                    newNode = addNode(text, selectedNode);
                    isPrimedForChild = false; // Exit primed state
                } else {
                    // In standard state, depends on Shift key
                    let parentNode;
                    if (event.shiftKey) {
                        // Shift+Enter = Add Child
                        parentNode = selectedNode;
                    } else {
                        // Enter = Add Sibling
                        const parentLink = links.find(l => l.target.id === selectedNode.id);
                        parentNode = parentLink ? parentLink.source : null;
                    }
                    if (parentNode) {
                        newNode = addNode(text, parentNode);
                    }
                }
            }

            if (newNode) {
                isPrimedForChild = false; // Enter standard mode after any creation
                selectNode(newNode);
                nodeInput.value = '';
                nodeInput.focus();
            } else if (needsUpdate) {
                updateGraph(); // Update if a node was collapsed but no new node was made
            }
        });

        d3.select("body").on("keydown", (event) => {
            if ((event.ctrlKey || event.metaKey) && (event.key === 'z' || event.key === 'Z')) {
                event.preventDefault();
                const lastNodeAdded = historyStack.pop();
                if (lastNodeAdded) {
                    const nodeToRemove = nodes.find(n => n.id === lastNodeAdded.id);
                    if(nodeToRemove) removeNode(nodeToRemove);
                }
                return; 
            }
            if(document.activeElement === nodeInput) return;
            if(selectedNode && (event.key === 'Delete' || event.key === 'Backspace')){
                event.preventDefault();
                removeNode(selectedNode);
            }
        });
        
        // --- LLM and Dragging ---
        async function triggerProactiveSuggestions(newNode) { /* ... same as before ... */ }
        async function callProactiveGemini(context, latestEntry) { /* ... same as before ... */ }
        summarizeBtn.addEventListener('click', async () => { /* ... same as before ... */ });
        elaborateBtn.addEventListener('click', async () => { /* ... same as before ... */ });
        function flashNode(nodeId) { /* ... same as before ... */ }
        function displayAiSuggestions(suggestions) { /* ... same as before ... */ }
        function displayAiResponse(text, title) { /* ... same as before ... */ }
        
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }
        function dragged(event, d) {
            const parentLink = links.find(l => l.target.id === d.id);
            if (parentLink) {
                const parent = parentLink.source;
                const maxDragDistance = parentLink.targetDistance * 1.5; // Can drag 50% further than resting state
                const currentDistance = Math.hypot(event.x - parent.x, event.y - parent.y);
                
                if (currentDistance > maxDragDistance) {
                    // If too far, clamp position to the max radius
                    const angle = Math.atan2(event.y - parent.y, event.x - parent.x);
                    d.fx = parent.x + maxDragDistance * Math.cos(angle);
                    d.fy = parent.y + maxDragDistance * Math.sin(angle);
                } else {
                    // Otherwise, drag freely
                    d.fx = event.x;
                    d.fy = event.y;
                }
            } else { // For the root node, which has no parent link
                 d.fx = event.x;
                 d.fy = event.y;
            }
        }
        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            if(d.depth !== 0) { 
                d.fx = null;
                d.fy = null;
            }
            
            // Find links where the dragged node is either a source or a target
            const connectedLinks = links.filter(l => l.source.id === d.id || l.target.id === d.id);
            
            connectedLinks.forEach(link => {
                const postDragDistance = Math.hypot(link.target.x - link.source.x, link.target.y - link.source.y);
                const originalDistance = link.targetDistance;
                const changeInDist = postDragDistance - originalDistance;

                // The new resting distance will be the original distance plus only 20% of the change.
                // This makes it spring back much more, feeling less stretchy.
                const newTargetDistance = originalDistance + (changeInDist * 0.2);
                
                link.targetDistance = Math.max(40, newTargetDistance); // Ensure a minimum distance
            });

            if (connectedLinks.length > 0) {
                // The simulation needs to be told to use the new distances
                simulation.force("link").distance(l => l.targetDistance);
                simulation.alpha(0.5).restart();
            }
        }
        
        // --- Initial State ---
        window.addEventListener('resize', optimizeView);
        applyTheme();
        nodeInput.focus(); // Set focus on the input field on load
        d3.timer(() => simulation.alpha(0.01));

        svg.on('click', (event) => {
            // Check if we clicked on the background, not a node
            if (event.target === svg.node()) {
                let needsUpdate = false;
                nodes.forEach(n => {
                    if (n.isExpanded) {
                        n.isExpanded = false;
                        n.fx = null; // Unpin
                        n.fy = null;
                        needsUpdate = true;
                    }
                });
                if (needsUpdate) updateGraph();
            }
        });

        nodeInput.addEventListener('focus', () => {
            isPrimedForChild = false;
        });

        function saveToHistory() {
            // TODO: In-depth history implementation for undo/redo
        }

        function handleBackgroundClick(event) {
            if ((event.target !== container && event.target !== svg.node()) || isAnimatingExit) return;

            const expandedNode = nodes.find(d => d.isExpanded);
            if (expandedNode) {
                isAnimatingExit = true;

                const nodeElement = nodeGroup.selectAll('.node').filter(n => n === expandedNode);

                if (nodeElement.empty() || nodeElement.select('foreignObject').empty()) {
                    isAnimatingExit = false;
                    expandedNode.isExpanded = false;
                    expandedNode.fx = null;
                    expandedNode.fy = null;
                    updateGraph();
                    simulation.alpha(1).restart();
                    centerOnNode(expandedNode);
                    return;
                }

                // Calculate the target radius based on node depth
                const targetRadius = expandedNode.depth === 0 ? 70 : (expandedNode.depth === 1 ? 40 : 25);
                
                // First, make the circle visible again but still at radius 0
                nodeElement.select('circle')
                    .style('opacity', 1)
                    .attr('r', 0);
                
                // Animate the foreignObject shrinking
                nodeElement.select('foreignObject')
                    .transition()
                    .duration(400)
                    .ease(d3.easeCubicOut)
                    .attr('x', -targetRadius)
                    .attr('y', -targetRadius)
                    .attr('width', targetRadius * 2)
                    .attr('height', targetRadius * 2)
                    .style('opacity', 0)
                    .on('end', () => {
                        expandedNode.isExpanded = false;
                        expandedNode.isClosing = true;
                        expandedNode.fx = null;
                        expandedNode.fy = null;
                        updateGraph();
                        simulation.alpha(1).restart();
                        centerOnNode(expandedNode);
                        isAnimatingExit = false;
                    });
            }
        }

        function centerOnNode(d) {
            const foWidth = 300;
            const foHeight = 200;

            const width = svg.node().clientWidth;
            const height = svg.node().clientHeight;
            
            // For expanded nodes, calculate scale to make it fill 1/3 of the screen
            const scale = d.isExpanded ? 
                Math.min(width / (foWidth * 3), height / (foHeight * 3)) : 
                1.0; // Default scale when not expanded

            const transform = d3.zoomIdentity
                .translate(width / 2, height / 2)
                .scale(scale)
                .translate(-d.x, -d.y);

            svg.transition()
                .duration(750)
                .call(zoom.transform, transform);
        }
    </script>
</body>
</html>
