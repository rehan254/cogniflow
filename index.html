<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CogniFlow - The LLM-Powered Idea Synthesizer</title>
    <link rel="icon" href="data:,">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/svg-to-pdfkit@0.1.8/source.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --ui-bg-dark: #0d0d0d;
            --ui-input-bg-dark: #2c2c2c;
            --ui-border-dark: #444444;
            --ui-text-dark: #e0e0e0;
            --ui-focus-dark: #e58d47;
            --ui-focus-glow: rgba(229, 141, 71, 0.65);
        }

        body {
            font-family: 'Roboto', sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            transition: background-color 1.5s ease-in-out;
        }

        #mindmap-container { flex-grow: 1; position: relative; background: transparent; }
        svg { display: block; width: 100%; height: 100%; }
        
        .link {
            fill: none;
            stroke-opacity: 0.6;
            stroke-width: 2.5px;
            stroke-linecap: round;
        }

        .node { cursor: pointer; transition: filter 0.6s ease; }
        .node circle {
            stroke-width: 0;
            stroke: transparent;
            transition: stroke 0.6s, stroke-width 0.6s;
        }
        .node.selected {
            filter: drop-shadow(0 0 12px var(--ui-focus-glow));
        }
        .node.selected circle {
            stroke-width: 3px;
            stroke: var(--ui-focus-dark);
        }
        .node.flashing circle {
            animation: flash 1s ease-out;
        }

        .node text {
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: central;
            font-weight: 500;
            transition: fill 1.5s ease-in-out;
            fill: #FFFFFF;
        }
        
        #bottom-panel {
            height: 20vh;
            min-height: 120px;
            resize: vertical;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            border-top-width: 1px;
            background-color: var(--ui-bg-dark);
            border-color: var(--ui-border-dark);
            color: var(--ui-text-dark);
        }

        #suggestion-panel {
            flex-grow: 1;
            padding: 1rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        #input-container {
            padding: 1rem;
            border-top-width: 1px;
            display: flex;
            gap: 0.5rem;
            align-items: center;
            border-color: var(--ui-border-dark);
        }

        #node-input {
            flex-grow: 1;
            padding: 0.75rem;
            border-radius: 8px;
            border: 1px solid var(--ui-border-dark);
            outline: none;
            background-color: var(--ui-input-bg-dark);
            color: var(--ui-text-dark);
        }
        #node-input:focus {
            border-color: var(--ui-focus-dark);
        }

        .ai-button {
            padding: 0.75rem 1rem;
            border-radius: 8px;
            border: 1px solid var(--ui-border-dark);
            background-color: var(--ui-input-bg-dark);
            color: var(--ui-text-dark);
            cursor: pointer;
            white-space: nowrap;
            transition: background-color 0.2s, border-color 0.2s;
            display: none;
        }
        .ai-button:hover {
            border-color: var(--ui-focus-dark);
        }
        
        .suggestion-container {
            align-self: flex-start;
            width: 100%;
            padding: 0.5rem;
            border: 1px dashed var(--ui-border-dark);
            border-radius: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .suggestion-node {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            border-radius: 20px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .suggestion-node:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        .suggestion-node .plus-icon {
            font-weight: bold;
        }
        
         .ai-response-bubble {
            align-self: flex-start;
            max-width: 80%;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            background-color: var(--ui-input-bg-dark);
            border: 1px solid var(--ui-border-dark);
        }
        .ai-response-bubble h3 {
            font-weight: bold;
            margin-bottom: 0.25rem;
            color: var(--ui-focus-dark);
        }

        .loading-indicator {
            position: absolute;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            display: none;
            z-index: 1000;
        }

        .expanded-node-container {
            border-radius: 16px;
            padding: 1rem;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            backdrop-filter: blur(5px);
        }

        .expanded-node-container h2 {
            font-size: 1.2rem;
            font-weight: bold;
            margin: 0;
            padding: 0;
            text-align: center;
            cursor: text;
        }
        
        .expanded-node-container textarea {
            flex-grow: 1;
            border: 1px solid transparent;
            border-radius: 8px;
            padding: 0.5rem;
            resize: none;
            outline: none;
            transition: border-color 0.6s ease;
        }

        .notes-editor {
            flex-grow: 1;
            overflow-y: auto;
            outline: none;
            padding: 0.5rem;
            border-radius: 8px;
        }

        .ai-actions-container {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            align-items: center;
            flex-grow: 1;
            width: 100%;
        }

        .ai-action-btn {
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid var(--ui-border-dark);
            background-color: var(--ui-input-bg-dark);
            color: var(--ui-text-dark);
            cursor: pointer;
            width: 90%;
            text-align: center;
            font-size: 11pt;
            transition: all 0.2s ease;
        }

        .ai-action-btn:hover {
            border-color: var(--ui-focus-dark);
            background-color: #3c3c3c;
        }

        @keyframes flash {
            0% { filter: drop-shadow(0 0 0px #ffffff); }
            50% { filter: drop-shadow(0 0 12px #ffffff); }
            100% { filter: drop-shadow(0 0 0px #ffffff); }
        }
    </style>
</head>
<body>

    <div id="mindmap-container">
        <svg id="mindmap-svg"></svg>
        <div id="loading-indicator" class="loading-indicator">CogniFlow is thinking...</div>
    </div>
    
    <div id="bottom-panel" id="bottom-panel">
        <div id="suggestion-panel">
            <div id="initial-help-text" class="text-center text-gray-500">
                Enter your central idea to begin.
            </div>
        </div>
        <div id="input-container">
            <input type="text" id="node-input" placeholder="Enter your central idea...">
            <button id="summarize-btn" class="ai-button">✨ Summarize</button>
            <button id="elaborate-btn" class="ai-button">✨ Elaborate</button>
        </div>
    </div>

    <script type="module">
        // --- Setup ---
        const svg = d3.select("#mindmap-svg");
        const suggestionPanel = document.getElementById('suggestion-panel');
        const nodeInput = document.getElementById('node-input');
        const summarizeBtn = document.getElementById('summarize-btn');
        const elaborateBtn = document.getElementById('elaborate-btn');
        const loadingIndicator = document.getElementById('loading-indicator');
        const container = document.getElementById('mindmap-container');
        
        let nodes = [];
        let links = [];
        let nextId = 0;
        let selectedNode = null;
        let isPrimedForChild = false;
        let activeExpandedNode = null;
        let historyStack = [];
        let isDragging = false;
        let isListEntryMode = false;
        let activeListNode = null;

        // --- New Color & Theme Engine ---
        const dynastyPalettes = [
            // Palette 1: Deep Blues & Teals (Rich & Muted)
            ["#2a4d69", "#4b6f8e", "#6e91b2", "#92b3d6"],
            // Palette 3: Muted Reds & Burgundies (Rich & Muted)
            ["#7c3c3c", "#9a5b5b", "#b87a7a", "#d69999"],
            // Palette 4: Soft Purples & Mauves (Muted)
            ["#6a4f6d", "#87728b", "#a495a9", "#c1b8c7"],
            // Palette 6: Warm Grays & Stone (Muted)
            ["#5a5a5a", "#787878", "#969696", "#b4b4b4"],
            // Palette 8: Slate Blues & Grays (Muted)
            ["#485b6e", "#6a7e93", "#8c9faa", "#aebfcb"]
        ];
        
        const paletteIndex = Math.floor(Math.random() * dynastyPalettes.length);
        
        // Track which palette each first-gen node gets
        let firstGenPaletteAssignment = new Map();
        
        const defs = svg.append("defs");

        function applyTheme() {
            // Set the focus color for UI elements
            const focusColorHex = dynastyPalettes[paletteIndex][0];
            document.querySelector(':root').style.setProperty('--ui-focus-dark', focusColorHex);

            const focusColor = d3.color(focusColorHex);
            if (focusColor) {
                 document.querySelector(':root').style.setProperty('--ui-focus-glow', `rgba(${focusColor.r}, ${focusColor.g}, ${focusColor.b}, 0.65)`);
            }
            
            // Create a very dark, desaturated background gradient
            const paletteColor = dynastyPalettes[paletteIndex][2] || '#888888';
            const baseColor = d3.hsl(paletteColor);
            baseColor.s *= 0.3; // Reduce saturation significantly
            
            const centerColor = d3.color(baseColor).darker(4).toString();
            const edgeColor = d3.color(baseColor).darker(6).toString();

            document.body.style.background = `radial-gradient(ellipse at center, ${centerColor} 0%, ${edgeColor} 100%)`;
        }
        
        // Helper function to check if a color is too bright for white text
        function isColorTooBright(color) {
            const d3Color = d3.color(color);
            if (!d3Color) return false;
            // Standard luminance calculation
            const luminance = (0.299 * d3Color.r + 0.587 * d3Color.g + 0.114 * d3Color.b) / 255;
            return luminance > 0.6;
        }

        function ensureTextVisible(color) {
            return isColorTooBright(color) ? d3.color(color).darker(1.5).toString() : color;
        }

        // Dynamic font sizing based on zoom level and hierarchy
        function updateDynamicFontSizes(specificNode = null) {
            const currentScale = d3.zoomTransform(svg.node()).k;
            const targetNodes = specificNode ? [specificNode] : nodeGroup.selectAll('.node').data();

            nodeGroup.selectAll('.node').each(function(d) {
                if (specificNode && d.id !== specificNode.id) return;

                const text = d3.select(this).select('text');
                if (d.isExpanded || d.isListNode) {
                    text.style('font-size', '0pt');
                    return;
                }

                const baseSize = 12; // Base font size in points
                const zoomMultiplier = 1 / Math.sqrt(currentScale);
                const depthMultiplier = 1 / (1 + (d.depth * 0.15)); // Reduce size more gently with depth
                const finalSize = Math.max(4, baseSize * zoomMultiplier * depthMultiplier);
                
                text.style('font-size', `${finalSize}pt`);

                const opacity = currentScale < 0.2 && d.depth > 3 ? Math.max(0, (currentScale - 0.1) * 10) : 1;
                text.style('opacity', opacity);
            });
        }
        
        function forceLinkRepel() {
            const repulsionStrength = 0.5; // Tweak this value to change force strength
            const repulsionDistance = 30;  // The radius around a link to repel nodes

            return function(alpha) {
                for (const node of nodes) {
                    for (const link of links) {
                        // Skip if the node is one of the link's endpoints
                        if (link.source === node || link.target === node) continue;

                        const x1 = link.source.x;
                        const y1 = link.source.y;
                        const x2 = link.target.x;
                        const y2 = link.target.y;
                        const x0 = node.x;
                        const y0 = node.y;

                        // Find the closest point on the link segment to the node
                        const l2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
                        if (l2 === 0) continue; // Skip if link has zero length

                        let t = ((x0 - x1) * (x2 - x1) + (y0 - y1) * (y2 - y1)) / l2;
                        t = Math.max(0, Math.min(1, t)); // Clamp t to the [0, 1] range

                        const closestX = x1 + t * (x2 - x1);
                        const closestY = y1 + t * (y2 - y1);

                        const dx = x0 - closestX;
                        const dy = y0 - closestY;
                        const d = Math.sqrt(dx * dx + dy * dy);

                        // If the node is within the repulsion distance, apply a force
                        if (d < repulsionDistance) {
                            const force = repulsionStrength * (1 - d / repulsionDistance) * alpha;
                            const forceX = (dx / d) * force;
                            const forceY = (dy / d) * force;

                            // Apply repulsion force to the node
                            node.vx += forceX;
                            node.vy += forceY;
                            
                            // Apply a counter-force to the link's endpoints to maintain stability
                            const tInv = 1 - t;
                            link.source.vx -= forceX * tInv;
                            link.source.vy -= forceY * tInv;
                            link.target.vx -= forceX * t;
                            link.target.vy -= forceY * t;
                        }
                    }
                }
            };
        }

        const simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).id(d => d.id).distance(d => d.targetDistance).strength(0.1)) 
            .force("charge", d3.forceManyBody().strength(d => d.depth === 0 ? -1000 : -450)) // Reduced central charge, slightly more repulsion for children
            .force("y", d3.forceY(container.clientHeight / 2).strength(0.04)) // Pulls nodes towards the horizontal centerline
            .force("collide", d3.forceCollide().radius(d => d.radius + 15).strength(0.8))
            .force("linkRepel", forceLinkRepel()) // The new custom force
            .velocityDecay(0.5) // More friction to reduce floating
            .alphaDecay(0.03) // Faster cooldown
            .alphaMin(0.001);

        const masterGroup = svg.append("g");
        let linkGroup = masterGroup.append("g").attr("class", "link-layer");
        let nodeGroup = masterGroup.append("g");
        
        const zoom = d3.zoom().scaleExtent([0.1, 2]).on("zoom", (event) => {
            masterGroup.attr("transform", event.transform);
            updateDynamicFontSizes(); // Update font sizes on zoom
        });
        svg.call(zoom);

        d3.select(container).on('click', handleBackgroundClick);

        // --- Core Functions ---
        function updateGraph() {
            // --- LINKS ---
            linkGroup.selectAll(".link")
                .data(links, d => `${d.source.id}-${d.target.id}`)
                .join("path")
                .attr("class", "link")
                .attr("stroke", d => d.source.color)
                .style("stroke-opacity", 0.5);

            // --- NODES (The General Update Pattern) ---
            const node = nodeGroup.selectAll(".node")
                .data(nodes, d => d.id);

            // Exit
            node.exit().transition().duration(800).attr("transform", "scale(0)").remove();

            // Enter
            const nodeEnter = node.enter().append("g")
                .attr("class", "node")
                .attr("transform", d => `translate(${d.x},${d.y})`)
                .on("dblclick", handleNodeDoubleClick)
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            nodeEnter.append("circle");
            
            nodeEnter.append("text");

            nodeEnter.append('foreignObject')
                .style('opacity', 0)
                .style('pointer-events', 'none');

            // Update
            const nodeUpdate = nodeEnter.merge(node)
                .classed('selected', d => d.id === selectedNode?.id);

            nodeUpdate.each(function(d) {
                const el = d3.select(this);
                const circle = el.select('circle');
                const text = el.select('text');
                const fo = el.select('foreignObject');

                // Data-join for the notes indicator
                const indicator = el.selectAll('.notes-indicator-icon')
                    .data((!d.isExpanded && d.notes && d.notes.trim() !== '') ? [d] : []);

                indicator.exit()
                    .transition().duration(600)
                    .style('opacity', 0)
                    .remove();
                
                const indicatorEnter = indicator.enter().append('text')
                    .attr('class', 'notes-indicator-icon')
                    .attr('text-anchor', 'middle')
                    .attr('dominant-baseline', 'central')
                    .text('≡') // Clearer "list" icon
                    .style('font-size', '12pt')
                    .style('opacity', 0)
                    .style('pointer-events', 'none');

                indicator.merge(indicatorEnter)
                    .style('fill', isColorTooBright(d.color) ? '#000000' : '#FFFFFF')
                    .transition().duration(600)
                    .style('opacity', 0.5); // Increased opacity for visibility

                // Calculate dimensions based on state - responsive sizing
                const foWidth = Math.min(280, container.clientWidth * 0.25); // Responsive width, max 25% of screen
                const foHeight = Math.min(180, container.clientHeight * 0.3); // Responsive height, max 30% of screen
                
                // Logic for Expanded View
                if (d.isExpanded) {
                    el.raise();
                    
                    // Smoothly morph the circle to a rounded rectangle
                    circle.transition()
                        .duration(600)
                        .ease(d3.easeCubicInOut)
                        .attr('r', 0)
                        .style('opacity', 0);
                    
                    // Fade out text
                    text.transition()
                        .duration(300)
                        .style('opacity', 0);
                    
                    // Expand and fade in the foreignObject
                    fo.transition()
                        .duration(600)
                        .ease(d3.easeCubicInOut)
                        .attr('x', -foWidth / 2)
                        .attr('y', -foHeight / 2)
                        .attr('width', foWidth)
                        .attr('height', foHeight)
                        .style('opacity', 1)
                        .on('end', () => {
                            fo.style('pointer-events', 'all')
                              .on('click', event => event.stopPropagation());
                        });

                    if (fo.select('.expanded-node-container').empty()) {
                        fo.html(''); // Clear previous content before rebuilding
                        const baseColor = d.color === '#FFFFFF' ? '#EAEAEA' : d.color;
                        const bgColor = d3.color(baseColor);
                        bgColor.opacity = 0.85;
                        const textColor = isColorTooBright(baseColor) ? '#000000' : '#FFFFFF';
                        const h2Color = isColorTooBright(baseColor) ? d3.color(baseColor).darker(1.5) : d3.color(baseColor).brighter(1.5);

                        const div = fo.append('xhtml:div')
                            .attr('class', 'expanded-node-container')
                            .style('width', '100%').style('height', '100%')
                            .style('background-color', bgColor.toString())
                            .style('color', textColor)
                            .style('opacity', 0)
                            .style('border-radius', '12px')
                            .style('padding', '12px')
                            .style('box-sizing', 'border-box')
                            .style('display', 'flex')
                            .style('flex-direction', 'column')
                            .style('gap', '8px');
                        
                        // Fade in the content after a delay
                        div.transition()
                            .delay(300)
                            .duration(300)
                            .style('opacity', 1);
                        
                        div.append('xhtml:h2')
                            .style('font-weight', '500')
                            .style('color', h2Color.toString())
                            .style('font-size', '14pt')
                            .style('margin', '0')
                            .style('padding', '0')
                            .style('text-align', 'center')
                            .style('flex-shrink', '0')
                            .text(d.name);

                        const actionsContainer = div.append('xhtml:div')
                            .attr('class', 'ai-actions-container');
                        
                        const actions = ['Define', 'Expand On', 'Solutions'];
                        actions.forEach(action => {
                            actionsContainer.append('xhtml:button')
                                .attr('class', 'ai-action-btn')
                                .text(action)
                                .on('click', event => {
                                    event.stopPropagation();
                                    console.log(`AI Action: ${action} for node ${d.name}`);
                                    // AI functionality will be added here later
                                });
                        });
                    }
                } else if (d.isListNode) { // Logic for List Node View
                    // Calculate the height based on number of list items with better sizing
                    const itemHeight = 35; // Better spacing for readability
                    const headerHeight = 40; // Was 45, reduced by 5
                    const bottomPadding = 40; // Was 20, made same as header
                    const sidePadding = 20; // More side padding
                    const minListItems = Math.max(3, d.listItems.length); // Minimum space for 3 items
                    const listHeight = headerHeight + (minListItems * itemHeight) + bottomPadding;
                    const maxItemTextLength = Math.max(d.name.length, ...d.listItems.map(item => item.text.length));
                    const listWidth = Math.max(280, Math.min(400, maxItemTextLength * 8 + 80)); // Dynamic width based on content
                    
                    // Set collision radius for the list node to approximate its bounding box
                    d.radius = Math.hypot(listWidth, listHeight) / 2;
                    
                    // Hide the circle and text for list nodes
                    circle.style('opacity', 0).attr('r', 0);
                    text.style('opacity', 0);
                    
                    // Show the foreignObject for the list with smooth transition
                    fo.transition()
                      .duration(400)
                      .ease(d3.easeCubicInOut)
                      .attr('x', -listWidth / 2)
                      .attr('y', -listHeight / 2)
                      .attr('width', listWidth)
                      .attr('height', listHeight)
                      .style('opacity', 1)
                      .on('end', () => {
                          fo.style('pointer-events', 'all')
                            .on('click', event => event.stopPropagation());
                      });
                    
                    if (fo.select('.list-node-container').empty()) {
                        fo.html(''); // Clear previous content
                        const baseColor = d.color === '#FFFFFF' ? '#EAEAEA' : d.color;
                        const bgColor = d3.color(baseColor);
                        bgColor.opacity = 0.9; // Slightly more opaque
                        const textColor = isColorTooBright(baseColor) ? '#000000' : '#FFFFFF';
                        const headerColor = isColorTooBright(baseColor) ? d3.color(baseColor).darker(1.5) : d3.color(baseColor).brighter(1.5);
                        
                        const div = fo.append('xhtml:div')
                            .attr('class', 'list-node-container')
                            .style('width', '100%')
                            .style('height', '100%')
                            .style('background-color', bgColor.toString())
                            .style('color', textColor)
                            .style('border-radius', '12px')
                            .style('padding', `${sidePadding}px`)
                            .style('box-sizing', 'border-box')
                            .style('backdrop-filter', 'blur(5px)')
                            .style('display', 'flex')
                            .style('flex-direction', 'column')
                            .style('transition', 'background-color 0.3s ease'); // Smooth background transitions
                        
                        // List header
                        const header = div.append('xhtml:h3')
                            .style('margin', '0 0 12px 0')
                            .style('font-size', '16pt')
                            .style('font-weight', '600')
                            .style('color', headerColor.toString())
                            .style('text-align', 'center')
                            .style('flex-shrink', '0')
                            .attr('contenteditable', true)
                            .text(d.name)
                            .on('mousedown', event => event.stopPropagation())
                            .on('keydown', function(event) {
                                if (event.key === 'Enter') { event.preventDefault(); this.blur(); }
                                event.stopPropagation();
                            })
                            .on('blur', function() { d.name = this.innerText; updateGraph(); });
                        
                        // List items container with smooth transitions
                        const listContainer = div.append('xhtml:div')
                            .style('flex-grow', '1')
                            .style('display', 'flex')
                            .style('flex-direction', 'column')
                            .style('gap', '10px') // Better spacing between items
                            .style('transition', 'all 0.3s ease');
                        
                        // Render list items
                        d.listItems.forEach((item, index) => {
                            const itemDiv = listContainer.append('xhtml:div')
                                .style('display', 'flex')
                                .style('align-items', 'flex-start')
                                .style('font-size', '13pt')
                                .style('line-height', '1.4')
                                .style('min-height', '20px');
                            
                            if (d.listType === 'bullet') {
                                itemDiv.append('xhtml:span')
                                    .style('margin-right', '10px')
                                    .style('margin-top', '2px')
                                    .style('color', textColor)
                                    .style('font-weight', 'bold')
                                    .style('flex-shrink', '0')
                                    .text('•');
                            } else if (d.listType === 'numbered') {
                                itemDiv.append('xhtml:span')
                                    .style('margin-right', '10px')
                                    .style('margin-top', '2px')
                                    .style('color', textColor)
                                    .style('font-weight', '500')
                                    .style('flex-shrink', '0')
                                    .style('min-width', '20px')
                                    .text((index + 1) + '.');
                            } else if (d.listType === 'task') {
                                const checkbox = itemDiv.append('xhtml:input')
                                    .attr('type', 'checkbox')
                                    .style('margin-right', '10px')
                                    .style('margin-top', '3px')
                                    .style('flex-shrink', '0')
                                    .style('width', '16px')
                                    .style('height', '16px')
                                    .property('checked', item.checked)
                                    .on('change', function() {
                                        item.checked = this.checked;
                                    })
                                    .on('click', event => event.stopPropagation());
                            }
                            
                            itemDiv.append('xhtml:span')
                                .style('flex-grow', '1')
                                .style('color', textColor)
                                .style('word-wrap', 'break-word')
                                .text(item.text);
                        });
                    } else {
                        // Update existing list - recalculate dimensions with smooth animation
                        const newItemHeight = 35;
                        const newHeaderHeight = 40; // Was 45, reduced by 5
                        const newBottomPadding = 40; // Was 20, made same as header
                        const newMinListItems = Math.max(3, d.listItems.length);
                        const newListHeight = newHeaderHeight + (newMinListItems * newItemHeight) + newBottomPadding;
                        const newMaxItemTextLength = Math.max(d.name.length, ...d.listItems.map(item => item.text.length));
                        const newListWidth = Math.max(280, Math.min(400, newMaxItemTextLength * 8 + 80));
                        
                        // Update foreignObject dimensions with smooth animation
                        fo.transition()
                            .duration(500)
                            .ease(d3.easeCubicInOut)
                            .attr('x', -newListWidth / 2)
                            .attr('y', -newListHeight / 2)
                            .attr('width', newListWidth)
                            .attr('height', newListHeight);
                        
                        // Rebuild the content
                        const container = fo.select('.list-node-container');
                        container.selectAll('*').remove(); // Clear all content
                        
                        // Ensure the container has transition for smooth background changes
                        container.style('transition', 'background-color 0.3s ease');
                        
                        const baseColor = d.color === '#FFFFFF' ? '#EAEAEA' : d.color;
                        const textColor = isColorTooBright(baseColor) ? '#000000' : '#FFFFFF';
                        const headerColor = isColorTooBright(baseColor) ? d3.color(baseColor).darker(1.5) : d3.color(baseColor).brighter(1.5);
                        
                        // Rebuild header
                        const header = container.append('xhtml:h3')
                            .style('margin', '0 0 12px 0')
                            .style('font-size', '16pt')
                            .style('font-weight', '600')
                            .style('color', headerColor.toString())
                            .style('text-align', 'center')
                            .style('flex-shrink', '0')
                            .attr('contenteditable', true)
                            .text(d.name)
                            .on('mousedown', event => event.stopPropagation())
                            .on('keydown', function(event) {
                                if (event.key === 'Enter') { event.preventDefault(); this.blur(); }
                                event.stopPropagation();
                            })
                            .on('blur', function() { d.name = this.innerText; updateGraph(); });
                        
                        // Rebuild items container with smooth transitions
                        const listContainer = container.append('xhtml:div')
                            .style('flex-grow', '1')
                            .style('display', 'flex')
                            .style('flex-direction', 'column')
                            .style('gap', '10px')
                            .style('transition', 'all 0.3s ease');
                        
                        // Rebuild items
                        d.listItems.forEach((item, index) => {
                            const itemDiv = listContainer.append('xhtml:div')
                                .style('display', 'flex')
                                .style('align-items', 'flex-start')
                                .style('font-size', '13pt')
                                .style('line-height', '1.4')
                                .style('min-height', '20px');
                            
                            if (d.listType === 'bullet') {
                                itemDiv.append('xhtml:span')
                                    .style('margin-right', '10px')
                                    .style('margin-top', '2px')
                                    .style('color', textColor)
                                    .style('font-weight', 'bold')
                                    .style('flex-shrink', '0')
                                    .text('•');
                            } else if (d.listType === 'numbered') {
                                itemDiv.append('xhtml:span')
                                    .style('margin-right', '10px')
                                    .style('margin-top', '2px')
                                    .style('color', textColor)
                                    .style('font-weight', '500')
                                    .style('flex-shrink', '0')
                                    .style('min-width', '20px')
                                    .text((index + 1) + '.');
                            } else if (d.listType === 'task') {
                                const checkbox = itemDiv.append('xhtml:input')
                                    .attr('type', 'checkbox')
                                    .style('margin-right', '10px')
                                    .style('margin-top', '3px')
                                    .style('flex-shrink', '0')
                                    .style('width', '16px')
                                    .style('height', '16px')
                                    .property('checked', item.checked)
                                    .on('change', function() {
                                        item.checked = this.checked;
                                    })
                                    .on('click', event => event.stopPropagation());
                            }
                            
                            itemDiv.append('xhtml:span')
                                .style('flex-grow', '1')
                                .style('color', textColor)
                                .style('word-wrap', 'break-word')
                                .text(item.text);
                        });
                    }
                } else { // Logic for Standard (Circle) View
                    // Set proper dimensions for the circle based on depth
                    if (d.depth === 0) {
                        d.radius = 70;
                        
                        // Text positioning for central node - below the circle, capitalized
                        const words = d.name.toUpperCase().split(/\s+/); // Convert to uppercase
                        const lineHeight = 22; // Line height for below-circle text
                        const maxWidth = d.radius * 3; // Wider text area since it's below the circle
                        const textOffsetY = d.radius + 25; // Position text closer to the circle
                        
                        // Clear existing text
                        text.text('');
                        
                        let line = [];
                        let lineNumber = 0;
                        let tspan = text.append('tspan').attr('x', 0).attr('dy', 0);
                        
                        // Create wrapped text
                        words.forEach((word, i) => {
                            line.push(word);
                            tspan.text(line.join(' '));
                            
                            // Check if line is too long
                            if (tspan.node().getComputedTextLength() > maxWidth && line.length > 1) {
                                line.pop();
                                tspan.text(line.join(' '));
                                line = [word];
                                lineNumber++;
                                tspan = text.append('tspan')
                                    .attr('x', 0)
                                    .attr('dy', lineHeight)
                                    .text(word);
                            }
                        });
                        
                        // Position the text below the circle
                        const totalLines = text.selectAll('tspan').size();
                        text.attr('transform', `translate(0, ${textOffsetY})`);
                        
                        // Style the text - smaller and less bold for a softer look
                        text.style('font-size', '18pt')
                            .style('letter-spacing', '0px')
                            .style('fill', '#E0E0E0')
                            .style('font-weight', '500');
                        
                        // Remove fisheye effect handlers
                        el.on('mouseenter', null).on('mouseleave', null);
                    } else {
                        // Dynamic font sizing will be handled by updateDynamicFontSizes()
                        // Set base radius
                        d.radius = d.depth === 1 ? 35 : 25;
                        
                        // For non-central nodes, ensure single line text and proper color
                        let textColor;
                        if (d.depth === 1) {
                            // First generation: use a softer, lighter version of the background color
                            textColor = d3.color(d.color).brighter(1.8).toString();
                        } else {
                            // Other depths: use a soft light gray or black
                            textColor = isColorTooBright(d.color) ? '#000000' : '#E0E0E0';
                        }
                        
                        text.text(d.name)
                            .attr('transform', null)
                            .style('fill', textColor)
                            .style('font-weight', '500');
                        
                        // Initial text positioning (will be updated by updateDynamicFontSizes)
                        if (d.depth === 1) {
                            text.attr('dy', '0').attr('dominant-baseline', 'middle');
                        } else {
                            text.attr('dy', d.radius + 12).attr('dominant-baseline', 'middle');
                        }
                    }
                    
                    // If we're transitioning back from expanded, animate it
                    if (d.wasExpanded) {
                        d.wasExpanded = false; // Consume the flag immediately

                        fo.style('pointer-events', 'none');
                        
                        // All animations happen simultaneously
                        // Fade out the content
                        fo.select('.expanded-node-container')
                            .transition()
                            .duration(300)
                            .style('opacity', 0);
                        
                        // Shrink the foreignObject
                        fo.transition()
                            .duration(600)
                            .ease(d3.easeCubicInOut)
                            .attr('x', 0)
                            .attr('y', 0)
                            .attr('width', 0)
                            .attr('height', 0)
                            .style('opacity', 0)
                            .on('end', function() {
                                d3.select(this).html(''); // Clean up content after transition
                            });
                        
                        // Simultaneously morph back to circle
                        circle.transition()
                            .duration(600)
                            .ease(d3.easeCubicInOut)
                            .attr('r', d.radius)
                            .style('opacity', 1);
                        
                        // And fade text back in
                        text.transition()
                            .duration(600)
                            .ease(d3.easeCubicInOut)
                            .style('opacity', 1);
                    } else {
                        // Normal rendering (no transition needed)
                        fo.style('opacity', 0).style('pointer-events', 'none');
                        circle.style('opacity', 1).attr('r', d.radius);
                        text.style('opacity', 1);
                    }
                    
                    circle.attr('fill', d.color);
                }
            });

            simulation.nodes(nodes);
            simulation.force("link").links(links);
            
            // Apply dynamic font sizing after node updates
            setTimeout(() => updateDynamicFontSizes(), 50);
        }

        function generateBranchPath(d) {
            const path = d3.path();
            path.moveTo(d.source.x, d.source.y);
            path.lineTo(d.target.x, d.target.y);
            return path.toString();
        }
        
        simulation.on("tick", () => {
            linkGroup.selectAll(".link").attr("d", generateBranchPath);
            nodeGroup.selectAll(".node").attr("transform", d => `translate(${d.x},${d.y})`);
            updateDynamicFontSizes(); // Update font sizes on every tick
        });
        
        function optimizeView() {
            if (nodes.length === 0) return;
            const padding = 150;
            const xExtent = d3.extent(nodes, d => d.x);
            const yExtent = d3.extent(nodes, d => d.y);
            if (xExtent[0] === undefined) return;
            const [x0, x1] = xExtent;
            const [y0, y1] = yExtent;
            const fullWidth = x1 - x0;
            const fullHeight = y1 - y0;
            if (fullWidth === 0 || fullHeight === 0) return;
            const midX = x0 + fullWidth / 2;
            const midY = y0 + fullHeight / 2;
            const scale = Math.min(1.2, 0.9 / Math.max((fullWidth + padding) / container.clientWidth, (fullHeight + padding) / container.clientHeight));
            const transform = d3.zoomIdentity.translate(container.clientWidth / 2 - scale * midX, container.clientHeight / 2 - scale * midY).scale(scale);
            svg.transition().duration(600).call(zoom.transform, transform) // Reduced transition duration
                .on('end', updateDynamicFontSizes); // Update font sizes after zoom transition
        }

        // --- State Management ---
        // Removed setMode and selectNode functions, reverting to older, direct logic.

        // --- Interaction Logic ---
        function addNode(name, parent = null) {
            if (!name.trim()) return null;
            let newNode;

            // Check if this is a list type entry
            const listTypeMatch = name.match(/^(- |1\. |\[\] )(.*)/);
            const isListType = listTypeMatch !== null;
            let listType = null;
            let listContent = name;
            
            if (isListType) {
                if (listTypeMatch[1] === '- ') listType = 'bullet';
                else if (listTypeMatch[1] === '1. ') listType = 'numbered';
                else if (listTypeMatch[1] === '[] ') listType = 'task';
                listContent = listTypeMatch[2];
            }

            if (parent === null) {
                // This block should only ever create the VERY FIRST node.
                if (nodes.length > 0) {
                    console.error("Attempted to create a second central node. Action blocked.");
                    return null; // Prevent creating more than one root.
                }
                const color = "#FFFFFF"; // Central nodes are always white
                let x, y;
                x = container.clientWidth / 2;
                y = container.clientHeight / 2;
                newNode = { 
                    id: nextId++, 
                    name: isListType ? (listContent || 'New List') : name, 
                    depth: 0, 
                    children:[], 
                    x, y, fx: x, fy: y, 
                    color: color,
                    isListNode: false, // Central node cannot be a list
                    listType: undefined,
                    listItems: undefined
                };
                nodes.push(newNode);
            } else {
                // If this is a list type entry, transform the parent into a list node
                if (isListType && parent && !parent.isListNode) {
                    // Transform the parent into a list node
                    parent.isListNode = true;
                    parent.listType = listType;
                    parent.listItems = [];
                    
                    // Add the first item if there's content
                    if (listContent) {
                        parent.listItems.push({
                            text: listContent,
                            checked: listType === 'task' ? false : undefined,
                            id: Date.now()
                        });
                    }
                    
                    // Enter list entry mode for this node
                    isListEntryMode = true;
                    activeListNode = parent;
                    
                    updateGraph();
                    // Use a much gentler alpha to avoid violent-looking node readjustment
                    simulation.alpha(0.08).restart();
                    return parent; // Return the transformed parent
                }
                
                // Regular node creation
                const depth = parent.depth + 1;
                // New distance logic for the more stable, horizontal layout
                const targetDistance = Math.max(40, 150 - depth * 35); // e.g., 115, 80, 45...

                if (!parent.children) parent.children = [];

                let finalColor;
                if (depth === 1) {
                    // First generation: each child gets a unique palette
                    const availablePalettes = dynastyPalettes.filter((_, idx) => !Array.from(firstGenPaletteAssignment.values()).includes(idx));
                    const paletteIdx = availablePalettes.length > 0 ? dynastyPalettes.indexOf(availablePalettes[0]) : parent.children.length % dynastyPalettes.length;
                    firstGenPaletteAssignment.set(nextId, paletteIdx);
                    finalColor = ensureTextVisible(dynastyPalettes[paletteIdx][0]);
                } else {
                    // Deeper generations: inherit from their dynasty's palette
                    let firstGenAncestor = parent;
                    while (firstGenAncestor.depth > 1) {
                        const parentLink = links.find(l => l.target.id === firstGenAncestor.id);
                        firstGenAncestor = parentLink ? parentLink.source : null;
                    }
                    const dynastyPaletteIdx = firstGenPaletteAssignment.get(firstGenAncestor.id);
                    if (dynastyPaletteIdx !== undefined) {
                        const palette = dynastyPalettes[dynastyPaletteIdx];
                        const colorIndex = Math.min(depth - 2, palette.length - 1);
                        finalColor = ensureTextVisible(palette[colorIndex]);
                    } else {
                        finalColor = ensureTextVisible(d3.color(parent.color).brighter(0.3).toString());
                    }
                }

                // Restore cone-based placement logic
                const rootNode = nodes[0];
                if (!rootNode) return null; // Should not happen if we have a parent

                let parentAngle, coneWidth;
                if (parent.depth === 0) {
                    // For the central node, allow children to be placed radially (full 360 degrees)
                    parentAngle = 0; // No preferred direction, start from 0 rad
                    coneWidth = 2 * Math.PI;
                } else {
                    // For other nodes, use a 160-degree cone based on their own angle from the center
                    parentAngle = Math.atan2(parent.y - rootNode.y, parent.x - rootNode.x);
                    coneWidth = (160 * Math.PI) / 180;
                }
                const coneStart = parentAngle - coneWidth / 2;

                const siblingAngles = parent.children.map(child => Math.atan2(child.y - parent.y, child.x - parent.x));
                let bestAngle = parentAngle; // Default to center

                if (siblingAngles.length > 0) {
                    let normalizedSiblings = siblingAngles.map(a => {
                        let norm = a - coneStart;
                        while(norm < 0) norm += 2 * Math.PI;
                        return norm % (2 * Math.PI);
                    }).filter(a => a <= coneWidth + 0.001).sort((a,b)=>a-b);

                    if (normalizedSiblings.length > 0) {
                        let maxGap = 0;
                        let angleAtMaxGap = -1;

                        maxGap = normalizedSiblings[0];
                        angleAtMaxGap = coneStart + maxGap / 2;

                        for(let i = 0; i < normalizedSiblings.length - 1; i++){
                            let gap = normalizedSiblings[i+1] - normalizedSiblings[i];
                            if (gap > maxGap) {
                                maxGap = gap;
                                angleAtMaxGap = coneStart + normalizedSiblings[i] + gap / 2;
                            }
                        }

                        let lastGap = coneWidth - normalizedSiblings[normalizedSiblings.length - 1];
                        if (lastGap > maxGap){
                            angleAtMaxGap = coneStart + normalizedSiblings[normalizedSiblings.length - 1] + lastGap / 2;
                        }
                        bestAngle = angleAtMaxGap;
                    }
                }
                
                const initialPlacementRadius = 20;
                const initialX = parent.x + initialPlacementRadius * Math.cos(bestAngle);
                const initialY = parent.y + initialPlacementRadius * Math.sin(bestAngle);

                newNode = {
                    id: nextId++, 
                    name: isListType ? (listContent || 'New List') : name, 
                    depth, 
                    children: [], 
                    x: initialX, 
                    y: initialY, 
                    color: finalColor,
                    isListNode: false,
                    listType: undefined,
                    listItems: undefined
                };
                nodes.push(newNode);

                links.push({ 
                    source: parent, target: newNode, 
                    targetDistance: targetDistance,
                    cp_dx_factor: (Math.random() - 0.5) * 0.4, cp_dy_factor: (Math.random() - 0.5) * 0.4
                });
                parent.children.push(newNode);
            }

            if (newNode) {
                historyStack.push(newNode);
            }
            
            updateGraph();
            simulation.alpha(0.15).restart(); // Gentler restart for less float
            optimizeView();
            return newNode;
        }

        function removeNode(nodeToRemove) {
            if (!nodeToRemove) return;

            // Find parent before links are filtered, so we can update its children array
            const parentLink = links.find(l => l.target.id === nodeToRemove.id);
            const parentNode = parentLink ? parentLink.source : null;

            const nodesToDelete = new Set([nodeToRemove.id]);
            const findDescendants = (nodeId) => {
                links.filter(l => l.source.id === nodeId).forEach(l => {
                    nodesToDelete.add(l.target.id);
                    findDescendants(l.target.id);
                });
            };
            findDescendants(nodeToRemove.id);

            nodes = nodes.filter(n => !nodesToDelete.has(n.id));
            links = links.filter(l => !nodesToDelete.has(l.source.id) && !nodesToDelete.has(l.target.id));

            // *** FIX ***: Correctly remove the node from its parent's children array
            if (parentNode && parentNode.children) {
                parentNode.children = parentNode.children.filter(child => child.id !== nodeToRemove.id);
            }

            if (selectedNode && nodesToDelete.has(selectedNode.id)) {
                selectedNode = null;
                nodeInput.placeholder = nodes.length > 0 ? 'Select a node to continue.' : 'Enter your central idea...';
                summarizeBtn.style.display = 'none';
                elaborateBtn.style.display = 'none';
            }
            
            updateGraph();
            simulation.alpha(0.15).restart(); // Gentler restart for less float
            optimizeView();
        }

        function handleNodeClick(event, d) {
            if (event && event.sourceEvent) event.sourceEvent.stopPropagation();
            else if (event) event.stopPropagation();
            
            if (activeExpandedNode) closeExpandedView(activeExpandedNode);

            // Exit list entry mode if clicking a different node
            if (isListEntryMode && activeListNode && activeListNode.id !== d.id) {
                exitListEntryMode();
            }

            // Only update selection and UI, do not call updateGraph or restart simulation
            if (selectedNode) {
                nodeGroup.selectAll('.node').filter(n => n.id === selectedNode.id).classed('selected', false);
            }
            selectedNode = d;
            isPrimedForChild = true;

            if (selectedNode) {
                nodeGroup.selectAll('.node').filter(n => n.id === selectedNode.id).classed('selected', true);
                summarizeBtn.style.display = 'inline-block';
                elaborateBtn.style.display = 'inline-block';
                
                // Update placeholder based on whether we're in list entry mode
                if (isListEntryMode && activeListNode && activeListNode.id === d.id) {
                    nodeInput.placeholder = `Add list item to "${d.name}"...`;
                } else {
                    nodeInput.placeholder = `Add a child to "${d.name}"...`;
                }
            }
            nodeInput.focus();
        }
        
        function handleNodeDoubleClick(event, d) {
            if (event) event.stopPropagation();
            
            // Don't allow expanding list nodes or the central node
            if (d.isListNode || d.depth === 0) return;

            if (activeExpandedNode && activeExpandedNode.id !== d.id) {
                closeExpandedView(activeExpandedNode, () => openExpandedView(d));
            } else if (d.isExpanded) {
                closeExpandedView(d);
            } else {
                openExpandedView(d);
            }
        }
        
        // --- Event Listeners ---
        nodeInput.addEventListener('keydown', (event) => {
            if (event.key !== 'Enter') return;
            event.preventDefault();
            const text = nodeInput.value.trim();
            if (!text) return;

            let newNode;

            // Handle list entry mode
            if (isListEntryMode && activeListNode) {
                // Add item to the active list node
                activeListNode.listItems.push({
                    text: text,
                    checked: activeListNode.listType === 'task' ? false : undefined,
                    id: Date.now() // Simple ID for tracking
                });
                nodeInput.value = '';
                
                // Trigger smooth resize animation by updating the graph
                updateGraph();
                
                // Optional: Add a subtle flash effect to indicate the new item was added
                setTimeout(() => {
                    const listContainer = nodeGroup.selectAll(".node")
                        .filter(d => d.id === activeListNode.id)
                        .select('foreignObject')
                        .select('.list-node-container');
                    
                    if (!listContainer.empty()) {
                        listContainer.style('background-color', d3.color(activeListNode.color).brighter(0.3).toString())
                            .transition()
                            .duration(300)
                            .style('background-color', d3.color(activeListNode.color).copy({opacity: 0.9}).toString());
                    }
                }, 50);
                
                return;
            }

            // Check if this is a list type entry
            const listTypeMatch = text.match(/^(- |1\. |\[\] )(.*)/);
            const isListType = listTypeMatch !== null;
            
            // If trying to create a list and a node is selected, transform it
            if (isListType && selectedNode && !selectedNode.isListNode && selectedNode.depth > 0) {
                // Transform the selected node into a list node (but not the central node)
                let listType = null;
                let listContent = listTypeMatch[2];
                
                if (listTypeMatch[1] === '- ') listType = 'bullet';
                else if (listTypeMatch[1] === '1. ') listType = 'numbered';
                else if (listTypeMatch[1] === '[] ') listType = 'task';
                
                selectedNode.isListNode = true;
                selectedNode.listType = listType;
                selectedNode.listItems = [];
                
                // Add the first item if there's content
                if (listContent) {
                    selectedNode.listItems.push({
                        text: listContent,
                        checked: listType === 'task' ? false : undefined,
                        id: Date.now()
                    });
                }
                
                // Enter list entry mode
                isListEntryMode = true;
                activeListNode = selectedNode;
                nodeInput.value = '';
                nodeInput.placeholder = `Add list item to "${selectedNode.name}"...`;
                
                updateGraph();
                // Also apply a gentle restart here for consistency
                simulation.alpha(0.08).restart();
                return;
            }

            if (nodes.length === 0) {
                // Case 1: Create the first node
                newNode = addNode(text, null);
                if (newNode) {
                    handleNodeClick(null, newNode); // Select it and prime it for a child
                    nodeInput.value = '';
                }
            } else if (selectedNode) {
                // Case 2: A node is selected, decide what to create
                if (isPrimedForChild) {
                    // It was primed, so Enter creates a child.
                    newNode = addNode(text, selectedNode);
                } else {
                    // Standard mode: Shift+Enter for child, Enter for sibling.
                    if (event.shiftKey) {
                        newNode = addNode(text, selectedNode); 
                    } else {
                        const parentLink = links.find(l => l.target.id === selectedNode.id);
                        // If root is selected, create a child. Otherwise, create a sibling.
                        const parent = parentLink ? parentLink.source : selectedNode;
                        newNode = addNode(text, parent);
                    }
                }

                if (newNode) {
                    // Clear input first
                    nodeInput.value = '';
                    
                    // Select the new node. This will correctly prime it for the moment.
                    handleNodeClick(null, newNode);
                    
                    // For the next interaction, we always want to be in standard mode
                    // after any key-based creation (unless we entered list mode).
                    if (!isListEntryMode) {
                        isPrimedForChild = false;
                        nodeInput.placeholder = `Add sibling (Enter), or child (Shift+Enter)...`;
                    }
                }
            }
        });

        d3.select("body").on("keydown", (event) => {
            if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
                // Exit list entry mode on navigation
                if (isListEntryMode) {
                    exitListEntryMode();
                }
                
                if (!selectedNode) {
                    return;
                }
                event.preventDefault();

                let newSelection = null;
                const parentLink = links.find(l => l.target.id === selectedNode.id);
                const parent = parentLink ? parentLink.source : null;

                if (event.key === 'ArrowLeft') {
                    if (parent) newSelection = parent;
                } 
                else if (event.key === 'ArrowRight') {
                    if (selectedNode.children && selectedNode.children.length > 0) {
                        newSelection = selectedNode.children[0];
                    }
                } 
                else if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
                    if (parent && parent.children && parent.children.length > 1) {
                        const siblings = parent.children;
                        const currentIndex = siblings.findIndex(s => s.id === selectedNode.id);
                        const numSiblings = siblings.length;
                        let nextIndex;

                        if (event.key === 'ArrowUp') {
                            nextIndex = (currentIndex - 1 + numSiblings) % numSiblings;
                        } else { // ArrowDown
                            nextIndex = (currentIndex + 1) % numSiblings;
                        }
                        newSelection = siblings[nextIndex];
                    }
                }

                if (newSelection) {
                    handleNodeClick(null, newSelection);
                    // Removed nodeInput.focus() here to prevent potential twitching on navigation
                }
                return; // Navigation was handled, stop further processing
            }

            // --- Prevent other actions if input is focused ---
            if(document.activeElement === nodeInput) return;

            // --- Undo Logic (Ctrl+Z / Cmd+Z) ---
            if ((event.ctrlKey || event.metaKey) && (event.key === 'z' || event.key === 'Z')) {
                event.preventDefault();
                const lastNodeAdded = historyStack.pop();
                if (lastNodeAdded) {
                    const nodeToRemove = nodes.find(n => n.id === lastNodeAdded.id);
                    if(nodeToRemove) removeNode(nodeToRemove);
                }
                return; 
            }
            
            // --- Delete Node Logic (Delete / Backspace) ---
            if(selectedNode && (event.key === 'Delete' || event.key === 'Backspace')){
                event.preventDefault();
                removeNode(selectedNode);
            }
        });
        
        // --- LLM and Dragging ---
        async function triggerProactiveSuggestions(newNode) { /* ... same as before ... */ }
        async function callProactiveGemini(context, latestEntry) { /* ... same as before ... */ }
        summarizeBtn.addEventListener('click', async () => { /* ... same as before ... */ });
        elaborateBtn.addEventListener('click', async () => { /* ... same as before ... */ });
        function flashNode(nodeId) {
            const nodeToFlash = node.filter(d => d.id === nodeId);
            // ... existing code ...
        }
        function displayAiSuggestions(suggestions) { /* ... same as before ... */ }
        function displayAiResponse(text, title) { /* ... same as before ... */ }
        
        function dragstarted(event, d) {
            // Store starting position to distinguish clicks from drags
            d.startX = event.x;
            d.startY = event.y;
            isDragging = false; // Reset flag
            
            // Store initial distances for all connected links
            const connectedLinks = links.filter(l => l.source.id === d.id || l.target.id === d.id);
            connectedLinks.forEach(link => {
                link.initialDistance = Math.hypot(link.target.x - link.source.x, link.target.y - link.source.y);
            });
        }
        function dragged(event, d) {
            if (!isDragging) {
                const dx = event.x - d.startX;
                const dy = event.y - d.startY;
                // Only start a "real" drag if the mouse moves more than 3px
                if (dx * dx + dy * dy > 9) {
                    isDragging = true;
                    // Gentle simulation heating for space-like feel
                    if (!event.active) simulation.alphaTarget(0.1).restart(); // Much gentler alpha target
                    simulation.force("link").strength(0.2); // Weaker link stiffening during drag
                }
            }
            
            if (isDragging) {
                // Pin node position during drag
                d.fx = event.x;
                d.fy = event.y;
            }
        }
        function dragended(event, d) {
            if (!isDragging) {
                // --- THIS IS A CLICK ---
                handleNodeClick(event, d);
            } else {
                // --- THIS WAS A DRAG ---
                if (!event.active) {
                    simulation.alphaTarget(0.02); // Gentle cooldown instead of stopping completely
                }
                simulation.force("link").strength(0.08); // Return to the new, weaker base strength
                
                // Un-pin the node to let the simulation place it, respecting the new link distance
                if (d.depth !== 0) {
                    d.fx = null;
                    d.fy = null;
                }
                
                const connectedLinks = links.filter(l => l.source.id === d.id || l.target.id === d.id);
                connectedLinks.forEach(link => {
                    const postDragDistance = Math.hypot(link.target.x - link.source.x, link.target.y - link.source.y);
                    const initialDistance = link.initialDistance || link.targetDistance;
                    const distanceChange = postDragDistance - initialDistance;
                    
                    if (distanceChange > 0) {
                        // Stretched: learn 60% of the new distance for a looser feel
                        link.targetDistance = Math.max(40, link.targetDistance + (distanceChange * 0.6));
                    } else if (distanceChange < 0) {
                        // Contracted: learn only 30% of the contracted distance
                        const contractionAmount = Math.abs(distanceChange);
                        link.targetDistance = Math.max(40, link.targetDistance - (contractionAmount * 0.3));
                    }
                    
                    // Clean up the initial distance tracking
                    delete link.initialDistance;
                });
                simulation.force("link").distance(l => l.targetDistance);
            }
            // Clean up start positions
            delete d.startX;
            delete d.startY;
        }
        
        // --- Initial State ---
        window.addEventListener('resize', optimizeView);
        applyTheme();
        nodeInput.focus(); // Set focus on the input field on load
        d3.timer(() => simulation.alpha(0.008)); // Even gentler baseline alpha for floating feel
        
        // Initialize dynamic font sizes
        setTimeout(() => updateDynamicFontSizes(), 100);

        svg.on('click', (event) => {
            // Check if we clicked on the background, not a node
            if (event.target !== container && event.target !== svg.node()) return;
            
            if (activeExpandedNode) {
                closeExpandedView(activeExpandedNode);
            }

            if (selectedNode) {
                nodeGroup.selectAll('.node').filter(n => n.id === selectedNode.id).classed('selected', false);
                selectedNode = null;
                isPrimedForChild = false;
                nodeInput.placeholder = nodes.length > 0 ? 'Select a node to continue.' : 'Enter your central idea...';
                summarizeBtn.style.display = 'none';
                elaborateBtn.style.display = 'none';
            }
        });

        nodeInput.addEventListener('focus', () => {
            if (activeExpandedNode) {
                closeExpandedView(activeExpandedNode);
            }
        });

        function saveToHistory() {
            // TODO: In-depth history implementation for undo/redo
        }

        function openExpandedView(d) {
            activeExpandedNode = d;
            d.isExpanded = true;
            d.fx = d.x;
            d.fy = d.y;
            updateGraph();
            centerOnNode(d);
        }

        function closeExpandedView(d, callback) {
            if (!d || !d.isExpanded) {
                if(callback) callback();
                return;
            }
            activeExpandedNode = null;
            d.isExpanded = false;
            d.wasExpanded = true;
            d.fx = null;
            d.fy = null;

            // The actual animation is handled in updateGraph now
            updateGraph();
            
            // Zoom out camera during the transition
            optimizeView();
            
            // Wait for the animation to complete before calling callback
            if (callback) {
                setTimeout(callback, 600);
            }
        }

        function handleBackgroundClick(event) {
            if (event.target !== container && event.target !== svg.node()) return;
            
            if (activeExpandedNode) {
                closeExpandedView(activeExpandedNode);
            }

            // Exit list entry mode
            if (isListEntryMode) {
                exitListEntryMode();
            }

            if (selectedNode) {
                nodeGroup.selectAll('.node').filter(n => n.id === selectedNode.id).classed('selected', false);
                selectedNode = null;
                isPrimedForChild = false;
                nodeInput.placeholder = nodes.length > 0 ? 'Select a node to continue.' : 'Enter your central idea...';
                summarizeBtn.style.display = 'none';
                elaborateBtn.style.display = 'none';
            }
        }

        function centerOnNode(d) {
            const foWidth = Math.min(280, container.clientWidth * 0.25);
            const foHeight = Math.min(180, container.clientHeight * 0.3);

            const width = svg.node().clientWidth;
            const height = svg.node().clientHeight;
            
            // For expanded nodes, calculate scale to ensure it fits comfortably on screen
            const scale = d.isExpanded ? 
                Math.min(
                    width / (foWidth * 2.5), 
                    height / (foHeight * 2.5),
                    1.2 // Max scale to prevent too much zoom
                ) : 
                1.0; // Default scale when not expanded

            const transform = d3.zoomIdentity
                .translate(width / 2, height / 2)
                .scale(scale)
                .translate(-d.x, -d.y);

            svg.transition()
                .duration(600) // Reduced transition duration
                .call(zoom.transform, transform)
                .on('end', updateDynamicFontSizes);
        }

        function exitListEntryMode() {
            isListEntryMode = false;
            activeListNode = null;
            if (selectedNode) {
                nodeInput.placeholder = `Add a child to "${selectedNode.name}"...`;
            }
        }
    </script>
</body>
</html>
