/* Version: 1751007550 */
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CogniFlow - The LLM-Powered Idea Synthesizer</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/svg-to-pdfkit@0.1.8/source.min.js"></script>
    <style>
        :root {
            --ui-bg-dark: #0d0d0d;
            --ui-input-bg-dark: #2c2c2c;
            --ui-border-dark: #444444;
            --ui-text-dark: #e0e0e0;
            --ui-focus-dark: #e58d47;
            --ui-focus-glow: rgba(229, 141, 71, 0.7);
        }

        body {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            transition: background-color 1.5s ease-in-out;
        }

        #mindmap-container { 
            flex-grow: 1; 
            position: relative; 
            background: transparent; 
            margin-top: 60px; /* Account for top bar height */
        }
        svg { display: block; width: 100%; height: 100%; }
        
        .link {
            fill: none;
            stroke-opacity: 0.6;
            stroke-width: 2.5px;
            stroke-linecap: round;
        }

        .node { cursor: pointer; }
        .node circle {
            stroke-width: 0;
            stroke: transparent;
            transition: stroke 0.6s, stroke-width 0.6s, filter 0.6s ease;
        }
        .node.selected circle {
            filter: drop-shadow(0 0 12px rgba(255, 255, 255, 0.4)) !important;
        }
        .node.drop-target circle {
            stroke-width: 4px;
            stroke: #66ff77; /* A bright green to indicate a valid drop target */
            stroke-dasharray: 4;
            animation: drop-target-dash 1s linear infinite;
        }
        .node.flashing circle {
            animation: flash 1s ease-out;
        }

        .node text {
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: central;
            font-weight: 500;
            transition: fill 1.5s ease-in-out;
            fill: #FFFFFF;
        }
        
        #bottom-panel {
            height: auto;
            max-height: 35vh;
            min-height: 80px;
            resize: vertical;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            background-color: var(--ui-bg-dark);
            color: var(--ui-text-dark);
            transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            position: relative;
            will-change: border-top, box-shadow;
        }

        #bottom-panel:hover #assistant-messages {
            max-height: 70vh; /* expanded height */
            opacity: 1;
            transform: translateY(0);
        }
        
        #bottom-panel:hover {
            border-top: 2px solid rgba(255, 255, 255, 0.1);
        }

        #assistant-messages {
            flex: 1 1 auto;
            padding: 0.75rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-height: 48px; /* collapsed height */
            overflow: hidden;
            opacity: 0.95;
            transform: translateY(8px);
            transition: max-height 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.4s, transform 0.4s;
            will-change: max-height, transform, box-shadow, opacity;
        }

        /* #assistant-messages hover behavior is now handled above */

        .assistant-message {
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
            padding: 0.5rem;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.03);
        }

        .assistant-avatar {
            display: none;
        }

        .assistant-content {
            flex-grow: 1;
        }

        .assistant-name {
            font-weight: 600;
            color: var(--ui-focus-dark);
            font-size: 0.8rem;
            margin-bottom: 0.2rem;
        }

        .assistant-text {
            color: var(--ui-text-dark);
            line-height: 1.3;
            font-size: 0.8rem;
        }

        .assistant-suggestions {
            margin-top: 0.3rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.3rem;
        }

        .suggestion-chip {
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            background-color: var(--ui-input-bg-dark);
            border: none;
            color: var(--ui-text-dark);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .suggestion-chip:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }



        #user-controls {
            flex-shrink: 0;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Integrated Export Buttons in Flow Assistant Cards */
        .insight-actions {
            margin-top: 8px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 8px;
        }

        .insight-export-btn {
            padding: 4px 12px;
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 4px;
            color: var(--ui-text-dark);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .insight-export-btn:hover {
            background-color: var(--ui-focus-dark);
            border-color: var(--ui-focus-dark);
            color: white;
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(229, 141, 71, 0.2);
        }

        .insight-export-btn.success {
            background-color: #28a745;
            border-color: #28a745;
            color: white;
        }

        .insight-export-btn.error {
            background-color: #dc3545;
            border-color: #dc3545;
            color: white;
        }

        /* Live Suggestions Card Styling */
        .flow-insight.live-suggestions {
            background: linear-gradient(135deg, rgba(230, 126, 34, 0.1), rgba(241, 196, 15, 0.1));
            border-left: 4px solid #f39c12;
        }

        .flow-insight.live-suggestions:hover {
            background: linear-gradient(135deg, rgba(230, 126, 34, 0.15), rgba(241, 196, 15, 0.15));
            transform: translateY(-2px);
        }

        /* Flow Assistant Insights Styling */
        .flow-insights {
            margin-top: 0.75rem;
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
        }

        .flow-insight {
            background-color: #2c2c2c;
            border-radius: 8px;
            padding: 0.75rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .flow-insight:hover {
            background-color: #363636;
            transform: translateY(-1px);
        }

        .flow-insight.expanded {
            background-color: #404040;
        }
        
        /* Integrated Suggestion Pills in Cards */
        .suggestion-pills-container, .area-suggestions {
            margin: 12px 0 8px 0;
            padding: 8px 0;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        
        .suggestion-pills {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 6px;
        }
        
        .suggestion-pill {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: white;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            border: none;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(99, 102, 241, 0.2);
        }
        
        .suggestion-pill:hover {
            background: linear-gradient(135deg, #4f46e5, #7c3aed);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
        }
        
        .suggestion-pill:active {
            transform: scale(0.95);
        }
        
        .suggestion-pill.secondary {
            background: linear-gradient(135deg, #10b981, #059669);
        }
        
        .suggestion-pill.secondary:hover {
            background: linear-gradient(135deg, #059669, #047857);
        }
        
        /* Removed typing overlay styles - Live Suggestions now integrated as Flow Assistant cards */
        
        .suggestion-pill.live-suggestion {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            animation: fadeInUp 0.3s ease;
        }
        
        .suggestion-pill.live-suggestion:hover {
            background: linear-gradient(135deg, #e67e22, #d35400);
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Legacy support for old clickable suggestions */
        .clickable-suggestion {
            display: inline-block;
            background: linear-gradient(135deg, #4a7aa2, #6a9fdf);
            color: white;
            padding: 4px 8px;
            margin: 2px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .clickable-suggestion:hover {
            background: linear-gradient(135deg, #6a9fdf, #8abfff);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(74, 122, 162, 0.3);
        }
        
        .clickable-suggestion:active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(74, 122, 162, 0.4);
        }

        /* Enhanced styling for different insight types */
        .flow-insight.keyword-suggestion {
            border-left: 4px solid #e58d47;
        }

        .flow-insight.keyword-suggestion:hover {
            border-left-color: #ff9d57;
        }

        .flow-insight.probing-question {
            border-left: 4px solid #6a9fdf;
        }

        .flow-insight.probing-question:hover {
            border-left-color: #7aafef;
        }

        .flow-insight.overview-card {
            border-left: 4px solid #8abfff;
        }

        .flow-insight.overview-card:hover {
            border-left-color: #9acfff;
        }

        .flow-insight.connection-insight {
            border-left: 4px solid #7aa36a;
        }

        .flow-insight.connection-insight:hover {
            border-left-color: #8ab37a;
        }

        .flow-insight.gap-insight {
            border-left: 4px solid #ffaf7a;
        }

        .flow-insight.gap-insight:hover {
            border-left-color: #ffbf8a;
        }

        .flow-insight.structural-suggestion {
            border-left: 4px solid #aa9acd;
        }

        .flow-insight.structural-suggestion:hover {
            border-left-color: #baaadd;
        }

        .insight-title {
            font-weight: 500;
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.8rem;
            margin-bottom: 0.3rem;
            line-height: 1.2;
        }

        .insight-preview {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.75rem;
            line-height: 1.3;
            font-style: italic;
        }

        .insight-full {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.75rem;
            line-height: 1.4;
        }

        .insight-full ul {
            margin: 0.5rem 0;
            padding-left: 1.2rem;
        }

        .insight-full li {
            margin: 0.3rem 0;
            line-height: 1.3;
        }

        .insight-full strong {
            color: rgba(255, 255, 255, 0.9);
        }

        #user-instructions {
            padding: 0.5rem 1rem;
        }

        .instruction-text {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.85rem;
            opacity: 0.8;
            text-align: center;
            font-weight: 400;
            font-style: italic;
        }

        #input-container {
            padding: 1rem;
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        #node-input {
            flex-grow: 1;
            padding: 0.75rem;
            border-radius: 8px;
            border: none;
            outline: none;
            background-color: var(--ui-input-bg-dark);
            color: var(--ui-text-dark);
        }

        .ai-button {
            padding: 0.75rem 1rem;
            border-radius: 8px;
            border: none;
            background-color: var(--ui-input-bg-dark);
            color: var(--ui-text-dark);
            cursor: pointer;
            white-space: nowrap;
            transition: background-color 0.2s;
            display: none;
        }
        .ai-button:hover {
            background-color: var(--ui-focus-dark);
        }
        
        .suggestion-container {
            align-self: flex-start;
            width: 100%;
            padding: 0.5rem;
            border-radius: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .suggestion-node {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            border-radius: 20px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .suggestion-node:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        .suggestion-node .plus-icon {
            font-weight: bold;
        }
        
         .ai-response-bubble {
            align-self: flex-start;
            max-width: 80%;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            background-color: var(--ui-input-bg-dark);
        }
        .ai-response-bubble h3 {
            font-weight: bold;
            margin-bottom: 0.25rem;
            color: var(--ui-focus-dark);
        }

        .loading-indicator {
            position: absolute;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            display: none;
            z-index: 1000;
        }

        /* Modern iOS-like Top Bar */
        .top-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: var(--ui-bg-dark);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 1rem;
            z-index: 1000;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.3);
        }

        .top-bar-left {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .top-bar-right {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .top-bar-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--ui-text-dark);
            transition: all 0.2s ease;
            cursor: pointer;
            backdrop-filter: blur(10px);
        }

        .top-bar-item:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        .top-bar-item.active {
            background: var(--ui-focus-dark);
            border-color: var(--ui-focus-dark);
            color: white;
        }

        .top-bar-select {
            background: transparent;
            border: none;
            color: inherit;
            font-size: inherit;
            font-weight: inherit;
            cursor: pointer;
            outline: none;
            padding: 0;
            min-width: 120px;
        }

        .top-bar-select option {
            background: var(--ui-input-bg-dark);
            color: var(--ui-text-dark);
        }

        .model-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .model-badge {
            background: var(--ui-focus-dark);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 8px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .usage-bar {
            width: 60px;
            height: 3px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            overflow: hidden;
        }

        .usage-bar::after {
            content: '';
            display: block;
            height: 100%;
            background: var(--ui-focus-dark);
            width: var(--usage-percent, 0%);
            transition: width 0.3s ease;
        }

        .control-btn {
            background: transparent;
            border: none;
            color: var(--ui-text-dark);
            padding: 0.5rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 32px;
            height: 32px;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.05);
        }

        .control-btn.active {
            background: var(--ui-focus-dark);
            color: white;
            animation: pulse 2s infinite;
        }

        /* LLM Settings Modal */
        .llm-settings-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .llm-settings-content {
            background: var(--ui-input-bg-dark);
            border-radius: 16px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .llm-settings-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .llm-settings-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--ui-text-dark);
        }

        .close-btn {
            background: transparent;
            border: none;
            color: var(--ui-text-dark);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .close-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .setting-group {
            margin-bottom: 1.5rem;
        }

        .setting-label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--ui-text-dark);
            margin-bottom: 0.5rem;
        }

        .setting-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            color: var(--ui-text-dark);
            font-size: 0.875rem;
            transition: all 0.2s ease;
        }

        .setting-input:focus {
            outline: none;
            border-color: var(--ui-focus-dark);
            box-shadow: 0 0 0 2px rgba(229, 141, 71, 0.3);
        }

        .setting-row {
            display: flex;
            gap: 1rem;
            align-items: end;
        }

        .setting-row .setting-group {
            flex: 1;
            margin-bottom: 0;
        }

        .save-btn {
            background: var(--ui-focus-dark);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 100%;
            margin-top: 1rem;
        }

        .save-btn:hover {
            background: #d17a3a;
            transform: translateY(-1px);
        }

        .test-connection-btn {
            background: rgba(255, 255, 255, 0.1);
            color: var(--ui-text-dark);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .test-connection-btn:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.8rem;
            margin-top: 0.5rem;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4caf50;
        }

        .status-indicator.error {
            background: #f44336;
        }

        .status-indicator.loading {
            background: #ff9800;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .expanded-node-container {
            border-radius: 16px;
            padding: 1rem;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            backdrop-filter: blur(5px);
        }

        .expanded-node-container h2 {
            font-size: 1.2rem;
            font-weight: bold;
            margin: 0;
            padding: 0;
            text-align: center;
            cursor: text;
        }
        
        .expanded-node-container textarea {
            flex-grow: 1;
            border: 1px solid transparent;
            border-radius: 8px;
            padding: 0.5rem;
            resize: none;
            outline: none;
            transition: border-color 0.6s ease;
        }

        .notes-editor {
            flex-grow: 1;
            overflow-y: auto;
            outline: none;
            padding: 0.5rem;
            border-radius: 8px;
            transition: border-color 0.2s, box-shadow 0.2s;
            border: 1px solid transparent;
        }

        .notes-editor:focus {
            border-color: rgba(255, 255, 255, 0.6);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.4);
        }

        .ai-actions-container {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            align-items: center;
            flex-grow: 1;
            width: 100%;
        }

        .ai-action-btn {
            padding: 4px 8px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            width: 80%;
            text-align: center;
            font-size: 9pt;
            font-weight: 500;
            transition: opacity 0.2s ease;
        }

        .ai-action-btn:hover {
            opacity: 0.8;
        }

        @keyframes flash {
            0% { filter: drop-shadow(0 0 0px #ffffff); }
            50% { filter: drop-shadow(0 0 12px #ffffff); }
            100% { filter: drop-shadow(0 0 0px #ffffff); }
        }

        @keyframes drop-target-dash {
            to {
                stroke-dashoffset: -8;
            }
        }

        @keyframes breathe {
            0%, 100% {
                transform: scale(1);
                opacity: 0.85;
            }
            50% {
                transform: scale(1.05);
                opacity: 0.95;
            }
        }

        /* Remove default browser outline on contenteditable elements */
        [contenteditable="true"]:focus {
            outline: none;
        }
    </style>
</head>
<body>

    <div id="mindmap-container">
        <svg id="mindmap-svg"></svg>
        <div id="loading-indicator" class="loading-indicator">CogniFlow is thinking...</div>
        
        <!-- Modern iOS-like Top Bar -->
        <div class="top-bar">
            <div class="top-bar-left">
                <div class="top-bar-item" id="model-status">
                    <span class="model-badge" id="current-model">LLAMA</span>
                    <div class="usage-bar" id="usage-indicator"></div>
                </div>
                <button class="control-btn" id="toggle-background" title="Toggle background AI updates">
                    🔄
                </button>
            </div>
            
            <div class="top-bar-right">
                <button class="top-bar-item" id="llm-settings-trigger" title="LLM Settings">
                    <span style="font-size:1.2em;">🤖</span> LLM Settings
                </button>
                <button class="top-bar-item" id="export-json" title="Export JSON">
                    <span style="font-size:1.2em;">⬇️</span> Export JSON
                </button>
                <button class="top-bar-item" id="import-json" title="Import JSON">
                    <span style="font-size:1.2em;">⬆️</span> Import JSON
                </button>
                <div class="top-bar-item">
                    <span style="font-size:1.2em;">🎨</span>
                    <select class="top-bar-select" id="theme-dropdown">
                        <option value="Crimson Dusk">Crimson Dusk</option>
                        <option value="Midnight Scholar">Midnight Scholar</option>
                        <option value="Autumn Whisper">Autumn Whisper</option>
                        <option value="Ocean Depths">Ocean Depths</option>
                        <option value="Forest Sage">Forest Sage</option>
                        <option value="Arctic Twilight">Arctic Twilight</option>
                        <option value="Neon Pulse">Neon Pulse</option>
                        <option value="Electric Storm">Electric Storm</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- LLM Settings Modal -->
        <div class="llm-settings-modal" id="llm-settings-modal">
            <div class="llm-settings-content">
                <div class="llm-settings-header">
                    <h3 class="llm-settings-title">🤖 LLM Configuration</h3>
                    <button class="close-btn" id="close-llm-settings">×</button>
                </div>
                
                <div class="setting-group">
                    <label class="setting-label">API Endpoint</label>
                    <input type="text" class="setting-input" id="llm-endpoint" placeholder="http://localhost:1234/v1">
                </div>
                
                <div class="setting-row">
                    <div class="setting-group">
                        <label class="setting-label">Model Name</label>
                        <input type="text" class="setting-input" id="llm-model" placeholder="llama-3.2-3b-instruct:2">
                    </div>
                    <div class="setting-group">
                        <label class="setting-label">Max Tokens</label>
                        <input type="number" class="setting-input" id="llm-max-tokens" placeholder="2048" min="100" max="8000">
                    </div>
                </div>
                
                <div class="setting-row">
                    <div class="setting-group">
                        <label class="setting-label">Temperature</label>
                        <input type="number" class="setting-input" id="llm-temperature" placeholder="0.7" min="0" max="2" step="0.1">
                    </div>
                    <div class="setting-group">
                        <label class="setting-label">Rate Limit (ms)</label>
                        <input type="number" class="setting-input" id="llm-rate-limit" placeholder="10" min="0" max="5000">
                    </div>
                </div>
                
                <button class="test-connection-btn" id="test-connection">Test Connection</button>
                <div class="connection-status" id="connection-status" style="display: none;">
                    <div class="status-indicator" id="status-indicator"></div>
                    <span id="status-text">Testing connection...</span>
                </div>
                
                <button class="save-btn" id="save-llm-settings">Save Settings</button>
            </div>
        </div>
    </div>
    
    <div id="bottom-panel">
        <!-- LLM Assistant Messages Area (Top) -->
        <div id="assistant-messages">
            <div id="assistant-welcome" class="assistant-message">
                <div class="assistant-content">
                    <div class="assistant-name">🌊 Flow Assistant</div>
                    <div class="assistant-text">Keeping you in the flow of ideas. I'll provide contextual insights and Google overview results to help expand your thinking without interruption.</div>
            </div>
        </div>
        </div>
        
        <!-- User Instructions & Controls Area (Bottom) -->
        <div id="user-controls">
            <div id="user-instructions">
                <div id="current-instruction" class="instruction-text">Click to create your central idea</div>
            </div>
        <div id="input-container">
                <input type="text" id="node-input" placeholder="">
            <button id="summarize-btn" class="ai-button">✨ Summarize</button>
            <button id="elaborate-btn" class="ai-button">✨ Elaborate</button>
            </div>
        </div>
    </div>

    <script type="module">
        // --- Setup ---
        const svg = d3.select("#mindmap-svg");
        const assistantMessages = document.getElementById('assistant-messages');
        const currentInstruction = document.getElementById('current-instruction');
        const nodeInput = document.getElementById('node-input');
        const summarizeBtn = document.getElementById('summarize-btn');
        const elaborateBtn = document.getElementById('elaborate-btn');
        const loadingIndicator = document.getElementById('loading-indicator');
        const container = document.getElementById('mindmap-container');
        
        let nodes = [];
        let links = [];
        let nextId = 0;
        let selectedNode = null;
        let isPrimedForChild = false;
        let activeExpandedNode = null;
        let historyStack = [];
        let isDragging = false;
        let isListEntryMode = false;
        let activeListNode = null;
        let dropTargetNode = null;

        // --- LM Studio Local API Configuration ---
        // Using Llama 3.2 3B Instruct model via LM Studio
        const LM_STUDIO_BASE_URL = 'http://localhost:1234/v1';
        const LOCAL_MODEL_NAME = 'llama-3.2-3b-instruct';
        
        // Google Search functionality removed - Flow Assistant now uses only local LLM knowledge
        
        // LM Studio model configuration (local, no rate limits needed)
        const LM_STUDIO_MODELS = {
            'llama': {
                url: `${LM_STUDIO_BASE_URL}/chat/completions`,
                model: LOCAL_MODEL_NAME,
                maxTokens: 2048,
                rateLimitDelay: 10, // Minimal delay for local model (10x faster)
                dailyLimit: 999999, // No limits for local model
                priority: 1
            }
        };
        
        // Track usage per model (local model has no limits)
        let modelUsage = {
            'llama': { today: 0, lastReset: new Date().toDateString() }
        };
        
        // Get the best available model (always returns local Llama model)
        function getBestAvailableModel(requestType = 'standard') {
            const today = new Date().toDateString();
            
            // Reset daily counters if new day (not really needed for local model)
            if (modelUsage.llama.lastReset !== today) {
                modelUsage.llama.today = 0;
                modelUsage.llama.lastReset = today;
            }
            
            // Always return the local Llama model
            return { name: 'llama', config: LM_STUDIO_MODELS['llama'] };
        }
        
        // Enhanced rate limiting configuration
        let lastApiCall = {};  // Track per model
        let apiCallQueue = [];
        let isProcessingQueue = false;

        // Enhanced rate-limited API call with queue system for LM Studio
        async function callLocalAPIWithRateLimit(prompt, maxChars = 260, priority = 'low', requestType = 'standard') {
            return new Promise((resolve, reject) => {
                apiCallQueue.push({
                    prompt,
                    maxChars,
                    priority,
                    requestType,
                    resolve,
                    reject,
                    timestamp: Date.now()
                });
                
                // Sort queue by priority (high priority first)
                apiCallQueue.sort((a, b) => {
                    if (a.priority === 'high' && b.priority !== 'high') return -1;
                    if (b.priority === 'high' && a.priority !== 'high') return 1;
                    return a.timestamp - b.timestamp;
                });
                
                processApiQueue();
            });
        }

        // Enhanced API queue processing with multi-model support
        async function processApiQueue() {
            if (isProcessingQueue || apiCallQueue.length === 0) return;
            
            isProcessingQueue = true;
            updateQueueStatus();
            
            while (apiCallQueue.length > 0) {
                const request = apiCallQueue.shift();
                
                try {
                    const result = await makeActualAPICall(request.prompt, request.maxChars, request.requestType || 'standard');
                    request.resolve(result);
                } catch (error) {
                    // For 429 or model unavailable errors, put the request back in queue with delay
                    if (error.message.includes('429') || error.message.includes('unavailable')) {
                        console.log('All models temporarily unavailable, retrying after delay...');
                        setTimeout(() => {
                            apiCallQueue.unshift(request); // Put back at front of queue
                            processApiQueue();
                        }, 10000); // Wait 10 seconds before retry
                        continue;
                    }
                    request.reject(error);
                }
                
                // Dynamic delay based on queue length (10x faster)
                const delay = apiCallQueue.length > 5 ? 20 : 50;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
            
            isProcessingQueue = false;
            updateQueueStatus();
        }

        // Update queue status indicator
        function updateQueueStatus() {
            const queueLength = apiCallQueue.length;
            if (queueLength > 0 || isProcessingQueue) {
                if (queueLength > 0) {
                    console.log(`🤖 Flow Assistant: ${queueLength} request(s) queued...`);
                }
                // Show loading indicator when processing queue
                if (isProcessingQueue) {
                    loadingIndicator.style.display = 'block';
                    loadingIndicator.textContent = queueLength > 0 ? 
                        `Processing ${queueLength + 1} AI requests...` : 
                        'Processing AI request...';
                }
            } else {
                // Hide loading indicator when queue is empty
                loadingIndicator.style.display = 'none';
                loadingIndicator.textContent = 'CogniFlow is thinking...';
            }
        }

        // Helper function for Local LM Studio API calls - non-blocking
        async function callLocalAPI(prompt, maxChars = 260) {
            // Use the rate-limited version for better performance
            return callLocalAPIWithRateLimit(prompt, maxChars, 'low');
        }

        // --- Enhanced Markdown Export Functionality ---
        function exportToMarkdown() {
            if (nodes.length === 0) {
                alert('No mindmap to export. Create some nodes first!');
                return '';
            }

            const rootNode = nodes.find(node => node.depth === 0);
            if (!rootNode) {
                alert('No central node found!');
                return '';
            }

            let markdown = '';
            
            // Enhanced header with metadata
            markdown += `# ${rootNode.name}\n\n`;
            
            // Add comprehensive metadata
            const now = new Date();
            markdown += `## 📋 Mindmap Metadata\n\n`;
            markdown += `- **Export Date**: ${now.toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}\n`;
            markdown += `- **Export Time**: ${now.toLocaleTimeString('en-US', { hour12: false })}\n`;
            markdown += `- **Total Nodes**: ${nodes.length}\n`;
            markdown += `- **Total Connections**: ${links.length}\n`;
            markdown += `- **Max Depth**: ${Math.max(...nodes.map(n => n.depth))}\n`;
            markdown += `- **Node Types**: ${getNodeTypeSummary()}\n\n`;
            
            // Add root node notes if present
            if (rootNode.notes && rootNode.notes.trim()) {
                markdown += `## 📝 Central Idea Notes\n\n${rootNode.notes.trim()}\n\n`;
            }
            
            // Add mindmap structure overview
            markdown += `## 🗺️ Mindmap Structure\n\n`;
            const structure = generateStructureOverview(rootNode);
            if (structure) {
                markdown += structure;
            } else {
                markdown += 'This mindmap contains only the central idea.\n\n';
            }
            
            // Add detailed content
            markdown += `## 📚 Detailed Content\n\n`;
            markdown += processNodeHierarchy(rootNode, 0);
            
            // Add footer with export info
            markdown += `---\n\n`;
            markdown += `*Generated by CogniFlow - A professional mind mapping tool optimized for LLM processing*\n`;
            markdown += `*This markdown is structured for easy parsing by AI models and human readers alike*\n\n`;
            
            return markdown;
        }

        function getNodeTypeSummary() {
            const typeCounts = {
                standard: 0,
                list: 0,
                media: 0,
                expanded: 0
            };
            
            nodes.forEach(node => {
                if (node.isExpanded) typeCounts.expanded++;
                else if (node.isListNode) typeCounts.list++;
                else if (node.isMediaNode) typeCounts.media++;
                else typeCounts.standard++;
            });
            
            const parts = [];
            if (typeCounts.standard > 0) parts.push(`${typeCounts.standard} standard`);
            if (typeCounts.list > 0) parts.push(`${typeCounts.list} list`);
            if (typeCounts.media > 0) parts.push(`${typeCounts.media} media`);
            if (typeCounts.expanded > 0) parts.push(`${typeCounts.expanded} expanded`);
            
            return parts.join(', ');
        }

        function generateStructureOverview(rootNode) {
            const children = getChildrenOfNode(rootNode);
            if (children.length === 0) return null;
            
            let overview = '### Main Branches\n\n';
            
            children.forEach((child, index) => {
                const childCount = countDescendants(child);
                const childTypes = getChildTypeSummary(child);
                overview += `${index + 1}. **${child.name}**`;
                if (childCount > 0) {
                    overview += ` (${childCount} sub-items${childTypes ? `, ${childTypes}` : ''})`;
                }
                if (child.notes && child.notes.trim()) {
                    overview += ` - ${child.notes.trim().substring(0, 100)}${child.notes.length > 100 ? '...' : ''}`;
                }
                overview += '\n';
            });
            
            overview += '\n';
            return overview;
        }

        function countDescendants(node) {
            const children = getChildrenOfNode(node);
            let count = children.length;
            children.forEach(child => {
                count += countDescendants(child);
            });
            return count;
        }

        function getChildTypeSummary(node) {
            const descendants = getAllDescendants(node);
            const types = [];
            
            const hasLists = descendants.some(n => n.isListNode);
            const hasMedia = descendants.some(n => n.isMediaNode);
            const hasExpanded = descendants.some(n => n.isExpanded);
            
            if (hasLists) types.push('lists');
            if (hasMedia) types.push('media');
            if (hasExpanded) types.push('expanded');
            
            return types.length > 0 ? types.join(', ') : null;
        }

        function getAllDescendants(node) {
            const descendants = [];
            const children = getChildrenOfNode(node);
            
            children.forEach(child => {
                descendants.push(child);
                descendants.push(...getAllDescendants(child));
            });
            
            return descendants;
        }

        function getChildrenOfNode(parentNode) {
            return links
                .filter(link => link.source.id === parentNode.id)
                .map(link => link.target)
                .sort((a, b) => a.name.localeCompare(b.name));
        }

        function processNodeHierarchy(node, depth) {
            let markdown = '';
            const children = getChildrenOfNode(node);
            
            for (const child of children) {
                markdown += generateNodeMarkdown(child, depth + 1);
                // Recursively process children
                markdown += processNodeHierarchy(child, depth + 1);
            }
            
            return markdown;
        }

        function generateNodeMarkdown(node, depth) {
            let markdown = '';
            const indent = '  '.repeat(Math.max(0, depth - 1)); // Indent for hierarchy
            const prefix = depth === 1 ? '## ' : `${'#'.repeat(Math.min(depth + 1, 6))} `;
            
            // Add node type indicator and enhanced formatting
            const nodeType = getNodeTypeLabel(node);
            const typeIndicator = nodeType ? ` <small>(${nodeType})</small>` : '';
            
            if (node.isListNode && node.listItems && node.listItems.length > 0) {
                // Handle list nodes with enhanced formatting
                markdown += `${prefix}${node.name}${typeIndicator}\n\n`;
                
                // Add list metadata
                markdown += `${indent}**List Type**: ${getListTypeLabel(node.listType)}\n`;
                markdown += `${indent}**Items**: ${node.listItems.length}\n\n`;
                
                // Add list items with enhanced formatting
                for (const item of node.listItems) {
                    if (node.listType === 'bullet') {
                        markdown += `${indent}- ${item.text}\n`;
                    } else if (node.listType === 'numbered') {
                        const index = node.listItems.indexOf(item) + 1;
                        markdown += `${indent}${index}. ${item.text}\n`;
                    } else if (node.listType === 'task') {
                        const checkbox = item.checked ? '[x]' : '[ ]';
                        const status = item.checked ? ' ~~' : '';
                        const endStatus = item.checked ? '~~' : '';
                        markdown += `${indent}- ${checkbox} ${status}${item.text}${endStatus}\n`;
                    }
                }
                markdown += '\n';
                
            } else if (node.isListNode) {
                // Handle list nodes that might not have items yet
                markdown += `${prefix}${node.name}${typeIndicator}\n\n`;
                markdown += `${indent}**List Type**: ${getListTypeLabel(node.listType)}\n`;
                markdown += `${indent}**Items**: 0 (empty list)\n\n`;
                
            } else if (node.isMediaNode) {
                // Handle media nodes with enhanced formatting
                markdown += `${prefix}${node.name}${typeIndicator}\n\n`;
                
                // Add media metadata
                markdown += `${indent}**Media Type**: ${getMediaTypeLabel(node.mediaType)}\n`;
                if (node.mediaMetadata?.source) {
                    markdown += `${indent}**Source**: ${node.mediaMetadata.source}\n`;
                }
                markdown += '\n';
                
                // Enhanced media content
                if (node.mediaType === 'youtube') {
                    markdown += `${indent}🎥 **YouTube Video**: [${node.name}](${node.mediaSrc})\n`;
                    if (node.mediaMetadata?.videoId) {
                        markdown += `${indent}**Video ID**: \`${node.mediaMetadata.videoId}\`\n`;
                    }
                    if (node.mediaMetadata?.duration) {
                        markdown += `${indent}**Duration**: ${node.mediaMetadata.duration}\n`;
                    }
                } else if (node.mediaType === 'image') {
                    markdown += `${indent}![${node.name}](${node.mediaSrc})\n`;
                    if (node.mediaMetadata?.dimensions) {
                        markdown += `${indent}**Dimensions**: ${node.mediaMetadata.dimensions}\n`;
                    }
                } else if (node.mediaType === 'pdf') {
                    markdown += `${indent}📄 **PDF Document**: [${node.name}](${node.mediaSrc})\n`;
                    if (node.mediaMetadata?.pages) {
                        markdown += `${indent}**Pages**: ${node.mediaMetadata.pages}\n`;
                    }
                } else if (node.mediaType === 'github') {
                    markdown += `${indent}🗂️ **GitHub Repository**: [${node.name}](${node.mediaSrc})\n`;
                    if (node.mediaMetadata?.owner && node.mediaMetadata?.repo) {
                        markdown += `${indent}**Repository**: \`${node.mediaMetadata.owner}/${node.mediaMetadata.repo}\`\n`;
                    }
                    if (node.mediaMetadata?.stars) {
                        markdown += `${indent}**Stars**: ⭐ ${node.mediaMetadata.stars}\n`;
                    }
                } else if (node.mediaType === 'link') {
                    markdown += `${indent}🔗 **Link**: [${node.name}](${node.mediaSrc})\n`;
                    if (node.mediaMetadata?.domain) {
                        markdown += `${indent}**Domain**: ${node.mediaMetadata.domain}\n`;
                    }
                } else {
                    markdown += `${indent}📎 **Media**: [${node.name}](${node.mediaSrc})\n`;
                }
                markdown += '\n';
                
            } else if (node.isExpanded) {
                // Handle expanded nodes with enhanced formatting
                markdown += `${prefix}${node.name}${typeIndicator}\n\n`;
                
                // Add expanded node content
                if (node.notes && node.notes.trim()) {
                    markdown += `${indent}**Notes**:\n\n${indent}${node.notes.trim()}\n\n`;
                }
                
            } else {
                // Handle standard nodes with enhanced formatting
                markdown += `${prefix}${node.name}${typeIndicator}\n\n`;
                
                // Add notes if present
                if (node.notes && node.notes.trim()) {
                    markdown += `${indent}**Notes**: ${node.notes.trim()}\n\n`;
                }
            }
            
            // Add connection information
            const children = getChildrenOfNode(node);
            if (children.length > 0) {
                markdown += `${indent}**Connected to**: ${children.length} child node${children.length !== 1 ? 's' : ''}\n\n`;
            }
            
            return markdown;
        }

        function getNodeTypeLabel(node) {
            if (node.isExpanded) return 'Expanded Node';
            if (node.isListNode) return 'List Node';
            if (node.isMediaNode) return 'Media Node';
            return 'Standard Node';
        }

        function getListTypeLabel(listType) {
            switch (listType) {
                case 'bullet': return 'Bullet List';
                case 'numbered': return 'Numbered List';
                case 'task': return 'Task List';
                default: return 'Unknown';
            }
        }

        function getMediaTypeLabel(mediaType) {
            switch (mediaType) {
                case 'youtube': return 'YouTube Video';
                case 'image': return 'Image';
                case 'pdf': return 'PDF Document';
                case 'github': return 'GitHub Repository';
                case 'link': return 'Web Link';
                default: return 'Unknown Media';
            }
        }

        function downloadMarkdown(content, filename = 'cogniflow-mindmap.md') {
            const blob = new Blob([content], { type: 'text/markdown;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        async function copyToClipboard(text) {
            try {
                await navigator.clipboard.writeText(text);
                return true;
            } catch (err) {
                console.error('Failed to copy to clipboard:', err);
                // Fallback method
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                textArea.style.top = '-999999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    return true;
                } catch (err) {
                    document.body.removeChild(textArea);
                    return false;
                }
            }
        }

        // Helper function to generate export actions for Flow Assistant cards
        function generateInsightActions(cardType = 'full') {
            return `
                <div class="insight-actions">
                    <button class="insight-export-btn export-full-map" onclick="exportFullMap(this, event)">
                        📄 Export Full Map
                    </button>
                    <button class="insight-export-btn copy-full-map" onclick="copyFullMap(this, event)">
                        📋 Copy Full Map
                    </button>
                </div>
            `;
        }

        // Export button handlers for Flow Assistant cards
        function exportFullMap(button, event) {
            event.stopPropagation();
            const markdown = exportToMarkdown();
            if (markdown) {
                const timestamp = new Date().toISOString().slice(0, 10);
                const filename = `cogniflow-mindmap-${timestamp}.md`;
                downloadMarkdown(markdown, filename);
                
                // Provide visual feedback
                const originalText = button.textContent;
                button.textContent = '✅ Downloaded!';
                button.classList.add('success');
                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('success');
                }, 2000);
            }
        }

        async function copyFullMap(button, event) {
            event.stopPropagation();
            const markdown = exportToMarkdown();
            if (markdown) {
                const success = await copyToClipboard(markdown);
                
                // Provide visual feedback
                const originalText = button.textContent;
                if (success) {
                    button.textContent = '✅ Copied!';
                    button.classList.add('success');
                } else {
                    button.textContent = '❌ Failed';
                    button.classList.add('error');
                }
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('success', 'error');
                }, 2000);
            }
        }

        // Create Live Suggestions card for Flow Assistant
        function createLiveSuggestionsCard(inputText, suggestions) {
            const suggestionPills = suggestions.map(suggestion => 
                `<button class="suggestion-pill live-suggestion" data-suggestion="${suggestion.replace(/"/g, '&quot;')}">${suggestion}</button>`
            ).join('');
            
            const fullContent = `
                <strong>Ideas based on your typing:</strong> "${inputText}"<br/><br/>
                <div class="suggestion-pills-container">
                    <div class="suggestion-pills">
                        ${suggestionPills}
                    </div>
                </div>
                <br/><em>Click any suggestion to use it in your input field</em>
                ${generateInsightActions()}
            `;
            
            return `
                <div class="flow-insight live-suggestions" onclick="expandInsight(this)">
                    <div class="insight-title">🤖 Live Suggestions</div>
                    <div class="insight-preview">Ideas based on "${inputText}" (${suggestions.length} suggestions)</div>
                    <div class="insight-full" style="display: none;">
                        ${fullContent}
                    </div>
                </div>
            `;
        }

        // --- Real Google Search Integration (Separate from AI) ---
        // Google Search functionality removed - Flow Assistant uses only local LLM knowledge

        // --- Event-Driven Flow Assistant System ---
        let flowAssistantEnabled = true;
        let lastFlowUpdate = 0;
        let pendingFlowUpdates = new Map();
        const FLOW_UPDATE_DELAY = 200; // 200ms after user stops interacting (10x faster)
        const MIN_FLOW_INTERVAL = 1000; // Minimum 1 second between updates for same node (10x faster)

        // Enhanced event-driven Flow Assistant updates with deduplication
        function queueFlowAssistantUpdate(nodeId, changeType = 'change', priority = 'medium') {
            if (!flowAssistantEnabled || !selectedNode) return;
            
            const now = Date.now();
            const lastUpdate = lastFlowUpdate;
            
            // Skip if too recent for same node (prevent spam) - much more aggressive deduplication
            if (now - lastUpdate < MIN_FLOW_INTERVAL && pendingFlowUpdates.has(nodeId)) {
                console.log(`🚫 Skipping duplicate Flow Assistant request for ${changeType}`);
                return;
            }
            
            // Skip if same request type is already pending
            const pendingKey = `${nodeId}-${changeType}`;
            if (pendingFlowUpdates.has(pendingKey)) {
                console.log(`🚫 Skipping duplicate ${changeType} request already in queue`);
                return;
            }
            
            // Clear existing timeout for this node
            if (pendingFlowUpdates.has(nodeId)) {
                clearTimeout(pendingFlowUpdates.get(nodeId));
            }
            if (pendingFlowUpdates.has(pendingKey)) {
                clearTimeout(pendingFlowUpdates.get(pendingKey));
            }
            
            // Set new timeout with priority-based delay (10x faster)
            const delay = priority === 'high' ? 100 : FLOW_UPDATE_DELAY;
            
            const timeoutId = setTimeout(async () => {
                const node = nodes.find(n => n.id === nodeId);
                if (node && selectedNode && selectedNode.id === nodeId) {
                    console.log(`🌊 Flow Assistant triggered: ${changeType} on "${node.name}"`);
                    try {
                        await activateFlowAssistant(node);
                        lastFlowUpdate = Date.now();
                    } catch (error) {
                        console.error('Flow Assistant update failed:', error);
                    }
                }
                pendingFlowUpdates.delete(nodeId);
                pendingFlowUpdates.delete(pendingKey);
            }, delay);
            
            pendingFlowUpdates.set(nodeId, timeoutId);
            pendingFlowUpdates.set(pendingKey, timeoutId);
        }

        // Intelligent change detection for Flow Assistant triggers
        function detectSignificantMapChange(changeType, nodeData) {
            if (!flowAssistantEnabled) return;
            
            switch (changeType) {
                case 'node_added':
                    // New node added - analyze its parent with high priority
                    if (nodeData.parent && selectedNode && selectedNode.id === nodeData.parent.id) {
                        queueFlowAssistantUpdate(nodeData.parent.id, 'child node added', 'high');
                    }
                    // Also analyze the new node itself if it gets selected
                    if (selectedNode && selectedNode.id === nodeData.id) {
                        queueFlowAssistantUpdate(nodeData.id, 'new node analyzed', 'medium');
                    }
                    break;
                    
                case 'node_renamed':
                    // Node text changed - immediate reanalysis
                    if (selectedNode && selectedNode.id === nodeData.id) {
                        queueFlowAssistantUpdate(nodeData.id, 'node content changed', 'high');
                    }
                    break;
                    
                case 'node_selected':
                    // Different node selected - contextual analysis
                    queueFlowAssistantUpdate(nodeData.id, 'node selected', 'medium');
                    break;
                    
                case 'structure_changed':
                    // Map structure modified - reanalyze current selection
                    if (selectedNode) {
                        queueFlowAssistantUpdate(selectedNode.id, 'structure modified', 'medium');
                    }
                    break;
                    
                case 'structure_changed':
                    // Map structure changed - update current node
                    if (selectedNode) {
                        queueBackgroundFlowUpdate(selectedNode.id, 'structure changed');
                    }
                    break;
            }
        }

        // Toggle background processing
        function toggleBackgroundProcessing() {
            backgroundProcessingEnabled = !backgroundProcessingEnabled;
            console.log(`🔄 Background processing ${backgroundProcessingEnabled ? 'enabled' : 'disabled'}`);
            
            if (!backgroundProcessingEnabled) {
                // Clear all pending updates
                Object.values(pendingBackgroundUpdates).forEach(timeout => clearTimeout(timeout));
                pendingBackgroundUpdates = {};
            }
            
            return backgroundProcessingEnabled;
        }

        // LM Studio API call implementation (OpenAI-compatible format)
        async function makeActualAPICall(prompt, maxChars = 260, requestType = 'standard') {
            const limitedPrompt = `${prompt}\n\nIMPORTANT: Keep your response under ${maxChars} characters.`;
            
            // Don't block UI - show loading only for explicit user actions
            const isUserAction = prompt.includes('Summarize') || prompt.includes('Elaborate') || prompt.includes('Define') || prompt.includes('Solutions');
            
            try {
                const { name: modelName, config: modelConfig } = getBestAvailableModel(requestType);
                
                // Minimal rate limiting for local model
                const now = Date.now();
                const lastCall = lastApiCall[modelName] || 0;
                const timeSinceLastCall = now - lastCall;
                
                if (timeSinceLastCall < modelConfig.rateLimitDelay) {
                    await new Promise(resolve => setTimeout(resolve, modelConfig.rateLimitDelay - timeSinceLastCall));
                }
                
                if (isUserAction) {
                    loadingIndicator.style.display = 'block';
                    loadingIndicator.textContent = `Processing with ${modelName.toUpperCase()} (Local)...`;
                }
                
                // OpenAI-compatible API call to LM Studio
                const response = await fetch(modelConfig.url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: modelConfig.model,
                        messages: [
                            {
                                role: "user",
                                content: limitedPrompt
                            }
                        ],
                        temperature: llmSettings.temperature,
                        max_tokens: maxChars > 1500 ? 3000 : (maxChars > 500 ? 1500 : 500),
                        stream: false
                    })
                });
                
                lastApiCall[modelName] = Date.now();
                
                if (isUserAction) {
                    loadingIndicator.style.display = 'none';
                }
                
                if (response.ok) {
                    // Successful response - increment usage counter
                    modelUsage[modelName].today++;
                    
                    const data = await response.json();
                    if (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) {
                        let text = data.choices[0].message.content.trim();
                        // Enforce character limit
                        if (text.length > maxChars) {
                            text = text.substring(0, maxChars - 3) + '...';
                        }
                        
                        console.log(`✅ Success with ${modelName} (Local Llama) - Response: ${text.length} chars`);
                        
                        // Update AI status in real-time
                        if (typeof updateAIStatus === 'function') {
                            updateAIStatus();
                        }
                        
                        return text;
                    }
                } else {
                    const errorText = await response.text();
                    throw new Error(`LM Studio API request failed: ${response.status} - ${errorText}`);
                }
            } catch (error) {
                console.error(`❌ LM Studio API error:`, error);
                
                if (isUserAction) {
                    loadingIndicator.style.display = 'none';
                }
                
                // Check if LM Studio is running
                if (error.message.includes('Failed to fetch') || error.message.includes('ECONNREFUSED')) {
                    throw new Error('LM Studio server not running. Please start LM Studio and load the Llama model.');
                }
                
                throw error;
            }
        }

        // Advanced Flow Assistant API call - Event-Driven AI Analysis System
        async function callFlowAssistantAPI(contextData, priority = 'medium') {
            const systemPrompt = `You are "Flow Assistant," an expert thinking partner integrated within a mind-mapping application called CogniFlow. You are designed to operate as a dynamic, always-on resource, continually processing and updating insights relevant to the user's evolving mind map.

Your primary goal is to deepen the user's understanding of their own ideas, provoke new lines of inquiry with insightful questions, clarify ambiguities, and provide relevant, well-curated context from your knowledge base. You aim to help users build clear, well-structured, and insightful mind maps that reflect their thinking process, adapting your insights as their map evolves.

You are NOT a content generator who suggests new nodes randomly. You are a catalyst for the user's own thinking, encouraging structural improvement, deeper connections, and conceptual refinement. Your tone is insightful, concise, and helpful, like a brilliant research assistant. Your responses should be fresh, reflecting the current state of the mind map and providing actionable insights.`;

            const userPrompt = `You will receive a JSON object containing the current context of the user's mind map. This represents the latest state of the map, and your response should reflect updated information and insights.

CONTEXT INPUT:
${JSON.stringify(contextData, null, 2)}

Based on the provided context, perform the following three tasks sequentially and format your entire response as a single JSON object.

TASK 1: ANALYZE, CLARIFY, AND PROBE
- Analyze the fullMapStructure to understand the user's overarching topic and the specific angle of the currentNodeText
- Scan the currentNodeText for non-trivial technical terms or potentially ambiguous concepts and provide concise definitions
- If the currentNodeText is longer than ideal for a mind map (more than 5-7 words), suggest a more concise keyword or short phrase
- Formulate a single, powerful, open-ended Socratic question that challenges assumptions or explores implications

TASK 2: INTELLIGENT CONTEXT & KNOWLEDGE SYNTHESIS
- Generate 3-4 distinct, highly relevant knowledge cards with SPECIFIC FACTUAL CONTENT from your training data
- Each card must contain ACTUAL information: specific facts, data, examples, names, dates, processes, or concrete details
- Include specific bullet points with real facts, concrete examples, and actionable information
- Provide clickable suggestions for expanding the mind map (these will be bolded and clickable in the UI)

TASK 3: MIND MAP STRUCTURAL & CONNECTIVE INSIGHTS
- Identify potential connections between the current node and other nodes in the map
- Spot underdeveloped areas or gaps in the map structure
- Suggest one high-level structural refinement or organizational improvement
- Provide specific node expansion suggestions that can be added to the map

Your entire output must be a single, valid JSON object with NO trailing commas, proper escaping, and complete array/object closure. Follow this structure EXACTLY:

{
  "analysis": {
    "definitions": [
      {
        "term": "...",
        "definition": "..."
      }
    ],
    "keywordSuggestion": {
      "originalText": "...",
      "suggestedKeyword": "..."
    },
    "probingQuestion": "..."
  },
  "overviews": {
    "results": [
      {
        "title": "Knowledge-Based Title",
        "summary": "Concrete facts and specific details from AI knowledge",
        "detailed": "Detailed factual information with specifics from training data",
        "keyPoints": ["Specific fact 1 with numbers/names/dates", "Concrete example 2", "Actual process or method 3"],
        "takeaways": ["Actionable insight with specifics", "Practical application"],
        "clickableSuggestions": ["Suggestion 1", "Suggestion 2"],
        "source": "Local AI Knowledge"
      }
    ]
  },
  "mapInsights": {
    "potentialConnections": [
      {
        "type": "semantic_link",
        "description": "...",
        "fromNodeId": "...",
        "toNodeId": "...",
        "suggestedRelationshipPhrase": "..."
      }
    ],
    "underdevelopedAreas": [
      {
        "type": "potential_subtopic",
        "description": "...",
        "forNodeId": "...",
        "suggestedNodes": ["Node suggestion 1", "Node suggestion 2"]
      }
    ],
    "structuralSuggestion": {
      "type": "clarity_refinement_question",
      "description": "..."
    }
  }
}`;

            try {
                // Use sophisticated multi-model system for Flow Assistant
                const fullPrompt = `${systemPrompt}\n\n${userPrompt}\n\nCRITICAL: Return ONLY valid JSON. NO markdown formatting (**bold**, *italic*), NO code blocks, NO explanations. Pure JSON only.`;
                const responseText = await callLocalAPIWithRateLimit(fullPrompt, 4000, priority, 'flow-assistant');
                
                if (responseText) {
                    // Clean the response text
                    let cleanedResponse = responseText.trim();
                    
                    // Remove markdown code blocks if present
                    cleanedResponse = cleanedResponse.replace(/```json\s*/g, '').replace(/```\s*$/g, '');
                    
                    // Remove any text before the first { and after the last }
                    const firstBrace = cleanedResponse.indexOf('{');
                    const lastBrace = cleanedResponse.lastIndexOf('}');
                    
                    if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
                        cleanedResponse = cleanedResponse.substring(firstBrace, lastBrace + 1);
                    }
                    
                    // In callFlowAssistantAPI, after the last JSON.parse attempt, add more robust cleaning and fallback:
                    try {
                        return JSON.parse(cleanedResponse);
                    } catch (parseError) {
                        console.log('First parse failed, trying structure fix...');
                        let structureFixed = cleanedResponse;
                        // Fix "overviews": [...] to "overviews": {"results": [...]}
                        if (structureFixed.includes('"overviews": [')) {
                            structureFixed = structureFixed.replace(/"overviews": \[/, '"overviews": {"results": [');
                            // Find the end of the overviews array and close the object
                            const mapInsightsIndex = structureFixed.indexOf('"mapInsights":');
                            if (mapInsightsIndex > 0) {
                                structureFixed = structureFixed.substring(0, mapInsightsIndex) + '},' + structureFixed.substring(mapInsightsIndex);
                            }
                        }
                        try {
                            return JSON.parse(structureFixed);
                        } catch (parseError2) {
                            // Try to fix more issues: missing commas, unquoted property names, etc.
                            let fixedJson = structureFixed;
                            // Ensure property names are quoted
                            fixedJson = fixedJson.replace(/([,{\s])(\w+)\s*:/g, '$1"$2":');
                            // Remove trailing commas before } or ]
                            fixedJson = fixedJson.replace(/,\s*([}\]])/g, '$1');
                            // Remove any invalid trailing characters after the last }
                            const lastBrace = fixedJson.lastIndexOf('}');
                            if (lastBrace !== -1) fixedJson = fixedJson.substring(0, lastBrace + 1);
                            // Add missing closing braces/brackets
                            const openBraces = (fixedJson.match(/\{/g) || []).length;
                            const closeBraces = (fixedJson.match(/\}/g) || []).length;
                            const openBrackets = (fixedJson.match(/\[/g) || []).length;
                            const closeBrackets = (fixedJson.match(/\]/g) || []).length;
                            for (let i = 0; i < (openBraces - closeBraces); i++) fixedJson += '}';
                            for (let i = 0; i < (openBrackets - closeBrackets); i++) fixedJson += ']';
                            try {
                                return JSON.parse(fixedJson);
                            } catch (parseError3) {
                                // Final fallback: log error and return safe structure
                                console.error('Unable to fix JSON, returning fallback. Error:', parseError3, '\nRaw response:', responseText, '\nCleaned:', cleanedResponse, '\nFixed:', fixedJson);
                                return {
                                    error: true,
                                    message: "Flow Assistant returned invalid data. Please try again or check your LLM output formatting.",
                                    analysis: {
                                        definitions: [],
                                        keywordSuggestion: null,
                                        probingQuestion: "What aspects of this topic would you like to explore further?"
                                    },
                                    overviews: {
                                        results: [
                                            {
                                                title: "Invalid AI Response",
                                                summary: "The Flow Assistant returned invalid data. Please try again.",
                                                source: "Local AI Knowledge"
                                            }
                                        ]
                                    },
                                    mapInsights: {
                                        potentialConnections: [],
                                        underdevelopedAreas: [],
                                        structuralSuggestion: {
                                            type: "general_tip",
                                            description: "Consider organizing related concepts closer together in your mind map for better visual flow."
                                        }
                                    }
                                };
                            }
                        }
                    }
                }
                return null;
            } catch (error) {
                loadingIndicator.style.display = 'none';
                console.error('Flow Assistant API error:', error);
                
                // Return a helpful error structure for display
                return {
                    error: true,
                    message: "Flow Assistant is temporarily unavailable. Please check your connection and try again.",
                    analysis: {
                        definitions: [],
                        keywordSuggestion: null,
                        probingQuestion: "What aspects of this topic would you like to explore further?"
                    },
                    overviews: {
                        results: [
                            {
                                title: "Service Unavailable",
                                summary: "The Flow Assistant service is currently unavailable. Your mind map will continue to work normally.",
                                source: "Local AI Knowledge"
                            }
                        ]
                    },
                    mapInsights: {
                        potentialConnections: [],
                        underdevelopedAreas: [],
                        structuralSuggestion: {
                            type: "general_tip",
                            description: "Consider organizing related concepts closer together in your mind map for better visual flow."
                        }
                    }
                };
            }
        }

        // Build context data for Flow Assistant
        function buildFlowAssistantContext(selectedNode) {
            if (!selectedNode) return null;

            // Find parent node
            const parentLink = links.find(l => l.target.id === selectedNode.id);
            const parentNode = parentLink ? parentLink.source : null;

            // Find sibling nodes
            const siblingNodes = parentNode ? 
                nodes.filter(n => {
                    const siblingLink = links.find(l => l.target.id === n.id);
                    return siblingLink && siblingLink.source.id === parentNode.id && n.id !== selectedNode.id;
                }) : [];

            // Build full map structure
            function buildMapStructure(node, visited = new Set()) {
                if (visited.has(node.id)) return null; // Prevent infinite loops
                visited.add(node.id);
                
                const children = links
                    .filter(l => l.source.id === node.id)
                    .map(l => buildMapStructure(l.target, visited))
                    .filter(child => child !== null);

                return {
                    text: node.name,
                    id: `node_${node.id}`,
                    children: children.length > 0 ? children : undefined
                };
            }

            const centralNode = nodes.find(n => n.depth === 0);
            const fullMapStructure = centralNode ? [buildMapStructure(centralNode)] : [];

            // Determine map goal from central node and first generation
            let mapGoal = "Exploring ideas and concepts";
            if (centralNode) {
                const firstGenNodes = nodes.filter(n => n.depth === 1);
                if (firstGenNodes.length > 0) {
                    mapGoal = `Exploring "${centralNode.name}" through: ${firstGenNodes.slice(0, 3).map(n => n.name).join(', ')}`;
                }
            }

            return {
                currentNodeText: selectedNode.name,
                currentNodeId: `node_${selectedNode.id}`,
                parentNodeText: parentNode ? parentNode.name : null,
                parentNodeId: parentNode ? `node_${parentNode.id}` : null,
                siblingNodeTexts: siblingNodes.map(n => n.name),
                siblingNodeIds: siblingNodes.map(n => `node_${n.id}`),
                fullMapStructure: fullMapStructure,
                mapGoal: mapGoal
            };
        }

        // --- Flow Assistant: Contextual Insights Provider ---
        // Provides contextual insights and Google overview results 
        // to help users stay in flow while exploring ideas

        // Show Flow Assistant welcome message
        function showFlowAssistantWelcome() {
            const assistantMessages = document.getElementById('assistant-messages');
            
            assistantMessages.innerHTML = `
                <div id="assistant-welcome" class="assistant-message">
                    <div class="assistant-content">
                        <div class="assistant-name">🌊 Flow Assistant</div>
                        <div class="assistant-text">Keeping you in the flow of ideas. I'll provide contextual insights using the knowledge from your local AI model to help expand your thinking without interruption.</div>
                    </div>
                </div>
            `;
        }

        // Flow Assistant function for when a node is selected
        async function activateFlowAssistant(selectedNode) {
            const assistantMessages = document.getElementById('assistant-messages');
            
            // Show loading state
            assistantMessages.innerHTML = `
                <div class="assistant-message">
                    <div class="assistant-content">
                        <div class="assistant-name">🌊 Flow Assistant</div>
                        <div class="assistant-text">Analyzing "${selectedNode.name}" using local AI knowledge...</div>
                    </div>
                </div>
            `;

            // Build context for the Flow Assistant
            const contextData = buildFlowAssistantContext(selectedNode);
            if (!contextData) {
                showFlowAssistantWelcome();
                return;
            }

            try {
                // Get AI analysis using only local LLM knowledge
                const insights = await callFlowAssistantAPI(contextData, 'medium');
                
                // Display the insights from local AI
                if (insights) {
                    displayStructuredFlowInsights(selectedNode, insights);
                } else {
                    // Fallback to simple insights if AI fails
                    const fallbackContext = buildMindMapContext();
                    const fallbackInsights = await generateFlowInsights(selectedNode, fallbackContext);
                    displayFlowInsights(selectedNode, fallbackInsights);
                }
                
            } catch (error) {
                console.error('Flow Assistant activation error:', error);
                
                // Fallback to simple insights if everything fails
                const fallbackContext = buildMindMapContext();
                const fallbackInsights = await generateFlowInsights(selectedNode, fallbackContext);
                displayFlowInsights(selectedNode, fallbackInsights);
            }
        }

        // Generate flow insights using Gemini AI based on node context
        async function generateFlowInsights(node, context) {
            const prompt = `You are the Flow Assistant, helping users explore ideas about "${context}".

The user is thinking about: "${node.name}"

Generate 4-6 informational insights that would provide valuable context and expand understanding of "${node.name}" in relation to "${context}".

For each insight, provide:
- A descriptive title (max 50 characters)
- Informative content (max 120 characters)

Format as JSON array: [{"title": "...", "content": "..."}]

Focus on background information, context, examples, or interesting facts that would enrich understanding.`;

            try {
                const response = await callLocalAPI(prompt, 700);
                if (response) {
                    const jsonMatch = response.match(/\[[\s\S]*\]/);
                    if (jsonMatch) {
                        const insights = JSON.parse(jsonMatch[0]);
                        return insights.slice(0, 6);
                    }
                }
            } catch (error) {
                console.error('Error generating flow insights:', error);
            }

            // Fallback insights based on context
            return generateFallbackInsights(node, context);
        }

        // Generate fallback insights if AI fails
        function generateFallbackInsights(node, context) {
            const nodeName = node.name.toLowerCase();
            
            // Smart insights based on common patterns
            if (nodeName.includes('tool') || nodeName.includes('equipment')) {
                return [
                    { title: "Essential Tool Categories", content: "Hand tools, power tools, and specialty equipment form the foundation of any toolkit" },
                    { title: "Tool Evolution", content: "Modern tools have evolved from ancient designs, combining traditional principles with new materials" },
                    { title: "Quality vs Cost", content: "Professional-grade tools offer durability and precision but may not be necessary for casual use" },
                    { title: "Maintenance Principles", content: "Proper cleaning, storage, and regular maintenance extend tool life significantly" }
                ];
            } else if (context.toLowerCase().includes('garden')) {
                return [
                    { title: "Seasonal Rhythms", content: "Gardens follow natural cycles that vary by climate zone and local weather patterns" },
                    { title: "Soil Ecosystem", content: "Healthy soil contains billions of microorganisms that support plant growth and nutrient cycling" },
                    { title: "Plant Relationships", content: "Companion planting utilizes beneficial relationships between different plant species" },
                    { title: "Water Wisdom", content: "Efficient watering considers soil type, plant needs, and environmental conditions" }
                ];
            } else {
                return [
                    { title: `Understanding ${node.name}`, content: `Core principles and foundational concepts that define ${node.name}` },
                    { title: `Context & Background`, content: `Historical development and current relevance of ${node.name}` },
                    { title: `Key Considerations`, content: `Important factors to keep in mind when working with ${node.name}` },
                    { title: `Related Concepts`, content: `Connected ideas and complementary topics related to ${node.name}` }
                ];
            }
        }

        // Display Flow Assistant insights in the assistant area
        function displayFlowInsights(node, insights) {
            const assistantMessages = document.getElementById('assistant-messages');
            
            let insightsHTML = insights.map((insight, index) => `
                <div class="flow-insight" onclick="expandInsight(this)">
                    <div class="insight-title">${insight.title}</div>
                    <div class="insight-preview">${insight.content || insight.description || ''}</div>
                    <div class="insight-full" style="display: none;">${insight.content || insight.description || ''}</div>
                </div>
            `).join('');

            assistantMessages.innerHTML = `
                <div class="assistant-message">
                    <div class="assistant-content">
                        <div class="assistant-name">🌊 Flow Assistant</div>
                        <div class="assistant-text">Contextual insights for "${node.name}":</div>
                        <div class="flow-insights">
                            ${insightsHTML}
                        </div>
                    </div>
                </div>
            `;
        }

        // Display structured Flow Assistant insights from the new JSON format
        function displayStructuredFlowInsights(node, insights) {
            const assistantMessages = document.getElementById('assistant-messages');
            
            // Handle error cases
            if (insights.error) {
                assistantMessages.innerHTML = `
                    <div class="assistant-message">
                        <div class="assistant-content">
                            <div class="assistant-name">⚠️ Flow Assistant</div>
                            <div class="assistant-text">${insights.message}</div>
                            <div class="flow-insights">
                                <div class="flow-insight" onclick="expandInsight(this)">
                                    <div class="insight-title">🔄 Try Again</div>
                                    <div class="insight-preview">Click to retry Flow Assistant analysis...</div>
                                    <div class="insight-full" style="display: none;">
                                        The Flow Assistant encountered an issue. Click here to retry the analysis for "${node.name}".
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                // Add retry functionality
                const retryButton = assistantMessages.querySelector('.flow-insight');
                retryButton.addEventListener('click', () => {
                    activateFlowAssistant(node);
                });
                return;
            }
            
            // Build the analysis section
            let analysisHTML = '';
            if (insights.analysis) {
                // Definitions
                if (insights.analysis.definitions && insights.analysis.definitions.length > 0) {
                    const definitionsHTML = insights.analysis.definitions.map(def => `
                        <div class="flow-insight" onclick="expandInsight(this)">
                            <div class="insight-title">📚 ${def.term}</div>
                            <div class="insight-preview">${def.definition.substring(0, 120)}</div>
                            <div class="insight-full" style="display: none;">
                                ${def.definition}
                                ${generateInsightActions()}
                            </div>
                        </div>
                    `).join('');
                    analysisHTML += definitionsHTML;
                }

                // Keyword suggestion (handle both simple string and object formats)
                const keywordSuggestion = insights.analysis.keywordSuggestion;
                if (keywordSuggestion && keywordSuggestion !== null) {
                    const suggestedText = typeof keywordSuggestion === 'string' ? keywordSuggestion : keywordSuggestion.suggestedKeyword;
                    const originalText = typeof keywordSuggestion === 'string' ? node.name : keywordSuggestion.originalText;
                    
                    if (suggestedText && suggestedText !== originalText) {
                        analysisHTML += `
                            <div class="flow-insight keyword-suggestion" onclick="expandInsight(this)">
                                <div class="insight-title">✏️ Suggested Refinement</div>
                                <div class="insight-preview">Consider: "${suggestedText}"</div>
                                <div class="insight-full" style="display: none;">
                                    <strong>Original:</strong> "${originalText}"<br/>
                                    <strong>Suggested:</strong> "${suggestedText}"<br/>
                                    <em>Click to apply this suggestion to your node.</em>
                                    ${generateInsightActions()}
                                </div>
                            </div>
                        `;
                    }
                }

                // Probing question
                if (insights.analysis.probingQuestion) {
                    analysisHTML += `
                        <div class="flow-insight probing-question" onclick="expandInsight(this)">
                            <div class="insight-title">🤔 Think Deeper</div>
                            <div class="insight-preview">${insights.analysis.probingQuestion}</div>
                            <div class="insight-full" style="display: none;">
                                ${insights.analysis.probingQuestion}
                                ${generateInsightActions()}
                            </div>
                        </div>
                    `;
                }
            }

            // Build the overviews section (knowledge from local AI)
            let overviewsHTML = '';
            if (insights.overviews && insights.overviews.results) {
                
                overviewsHTML += insights.overviews.results.map(result => {
                    // Build detailed content with key points and takeaways
                    let detailedContent = result.detailed || result.summary;
                    
                    if (result.keyPoints && result.keyPoints.length > 0) {
                        detailedContent += '<br/><br/><strong>Key Points:</strong><ul>';
                        result.keyPoints.forEach(point => {
                            detailedContent += `<li>${point}</li>`;
                        });
                        detailedContent += '</ul>';
                    }
                    
                    if (result.takeaways && result.takeaways.length > 0) {
                        detailedContent += '<br/><strong>Key Takeaways:</strong><ul>';
                        result.takeaways.forEach(takeaway => {
                            detailedContent += `<li>${takeaway}</li>`;
                        });
                        detailedContent += '</ul>';
                    }
                    
                    if (result.clickableSuggestions && result.clickableSuggestions.length > 0) {
                        detailedContent += `
                            <div class="suggestion-pills-container">
                                <strong>💡 Quick Add:</strong>
                                <div class="suggestion-pills">`;
                        result.clickableSuggestions.forEach(suggestion => {
                            const suggestionText = typeof suggestion === 'string' ? suggestion : String(suggestion);
                            detailedContent += `<button class="suggestion-pill" data-suggestion="${suggestionText.replace(/"/g, '&quot;')}">${suggestionText}</button>`;
                        });
                        detailedContent += `</div>
                            </div>`;
                    }
                    
                    return `
                        <div class="flow-insight overview-card" onclick="expandInsight(this)">
                            <div class="insight-title">🧠 ${result.title}</div>
                            <div class="insight-preview">${result.summary}</div>
                            <div class="insight-full" style="display: none;">
                                ${detailedContent}
                                ${result.source ? `<br/><br/><strong>Source:</strong> ${result.source}` : ''}
                                <br/><em>Knowledge from local AI model</em>
                                ${generateInsightActions()}
                            </div>
                        </div>
                    `;
                }).join('');
            }

            // Build the map insights section
            let mapInsightsHTML = '';
            if (insights.mapInsights) {
                // Potential connections
                if (insights.mapInsights.potentialConnections && insights.mapInsights.potentialConnections.length > 0) {
                    mapInsightsHTML += insights.mapInsights.potentialConnections.map(connection => `
                        <div class="flow-insight connection-insight" onclick="expandInsight(this)">
                            <div class="insight-title">🔗 Connection Found</div>
                            <div class="insight-preview">${connection.description}</div>
                            <div class="insight-full" style="display: none;">
                                ${connection.description}<br/>
                                <em>Relationship: ${connection.suggestedRelationshipPhrase || 'relates to'}</em><br/>
                                <small>Between nodes: ${connection.fromNodeId || 'current'} → ${connection.toNodeId || 'target'}</small>
                                ${generateInsightActions()}
                            </div>
                        </div>
                    `).join('');
                }

                // Underdeveloped areas
                if (insights.mapInsights.underdevelopedAreas && insights.mapInsights.underdevelopedAreas.length > 0) {
                    mapInsightsHTML += insights.mapInsights.underdevelopedAreas.map(area => {
                        let areaContent = area.description;
                        if (area.suggestedNodes && area.suggestedNodes.length > 0) {
                            areaContent += `
                                <div class="area-suggestions">
                                    <strong>🎯 Expand This Area:</strong>
                                    <div class="suggestion-pills">`;
                            area.suggestedNodes.forEach(nodeText => {
                                const nodeTextStr = typeof nodeText === 'string' ? nodeText : String(nodeText);
                                areaContent += `<button class="suggestion-pill secondary" data-suggestion="${nodeTextStr.replace(/"/g, '&quot;')}">${nodeTextStr}</button>`;
                            });
                            areaContent += `</div>
                                </div>`;
                        }
                        return `
                            <div class="flow-insight gap-insight" onclick="expandInsight(this)">
                                <div class="insight-title">💡 Potential Gap</div>
                                <div class="insight-preview">${area.description}</div>
                                <div class="insight-full" style="display: none;">
                                    ${areaContent}<br/>
                                    <small>For node: ${area.forNodeId || 'current area'}</small>
                                    ${generateInsightActions()}
                                </div>
                            </div>
                        `;
                    }).join('');
                }

                // Structural suggestion
                if (insights.mapInsights.structuralSuggestion) {
                    mapInsightsHTML += `
                        <div class="flow-insight structural-suggestion" onclick="expandInsight(this)">
                            <div class="insight-title">🏗️ Structure Tip</div>
                            <div class="insight-preview">${insights.mapInsights.structuralSuggestion.description}</div>
                            <div class="insight-full" style="display: none;">
                                ${insights.mapInsights.structuralSuggestion.description}
                                ${generateInsightActions()}
                            </div>
                        </div>
                    `;
                }
            }

            // Build Live Suggestions card if appropriate
            let liveSuggestionsHTML = '';
            const inputText = nodeInput.value.trim();
            if (inputText.length >= 3 && inputText.toLowerCase().includes(node.name.toLowerCase().substring(0, 3))) {
                try {
                    // Generate live suggestions based on current input context
                    const contextPrompt = `The user is working on a mindmap about "${node.name}" and typing "${inputText}". Provide 4 helpful suggestions:
1. A refined/improved version of what they're typing
2. A related concept they might want to explore
3. A follow-up question or direction  
4. A practical next step

Format as JSON: {"suggestions": ["suggestion1", "suggestion2", "suggestion3", "suggestion4"]}`;
                    
                    callLocalAPIWithRateLimit(contextPrompt, 400, 'medium', 'live-suggestions').then(response => {
                        if (response) {
                            let suggestions = [];
                            try {
                                if (response.includes('{')) {
                                    const cleanedResponse = response.substring(response.indexOf('{'), response.lastIndexOf('}') + 1);
                                    const parsed = JSON.parse(cleanedResponse);
                                    suggestions = parsed.suggestions || [];
                                } else {
                                    suggestions = response.split('\n')
                                        .filter(line => line.trim() && !line.includes('{') && !line.includes('}'))
                                        .map(line => line.replace(/^\d+\.?\s*/, '').replace(/^["-•]\s*/, '').trim())
                                        .filter(s => s.length > 0)
                                        .slice(0, 4);
                                }
                            } catch (parseError) {
                                suggestions = response.split('\n').filter(line => line.trim()).slice(0, 4);
                            }
                            
                            if (suggestions && suggestions.length > 0) {
                                // Add Live Suggestions card to existing insights
                                const liveSuggestionsCard = createLiveSuggestionsCard(inputText, suggestions);
                                const currentInsights = document.querySelector('.flow-insights');
                                if (currentInsights) {
                                    currentInsights.insertAdjacentHTML('beforeend', liveSuggestionsCard);
                                    
                                    // Add click handlers for live suggestion pills
                                    const liveSuggestionPills = currentInsights.querySelectorAll('.suggestion-pill.live-suggestion');
                                    liveSuggestionPills.forEach(pill => {
                                        pill.addEventListener('click', (e) => {
                                            e.stopPropagation();
                                            const suggestionText = pill.dataset.suggestion;
                                            nodeInput.value = suggestionText;
                                            nodeInput.focus();
                                            pill.style.transform = 'scale(0.95)';
                                            pill.style.opacity = '0.7';
                                            setTimeout(() => {
                                                pill.style.transform = '';
                                                pill.style.opacity = '';
                                            }, 200);
                                        });
                                    });
                                }
                            }
                        }
                    });
                } catch (error) {
                    console.log('Live suggestions card error:', error);
                }
            }

            // Combine all sections
            const allInsights = analysisHTML + overviewsHTML + mapInsightsHTML;

            assistantMessages.innerHTML = `
                <div class="assistant-message">
                    <div class="assistant-content">
                        <div class="assistant-name">🌊 Flow Assistant</div>
                        <div class="assistant-text">Comprehensive analysis for "${node.name}":</div>
                        <div class="flow-insights">
                            ${allInsights}
                        </div>
                    </div>
                </div>
            `;

            // Add click handler for keyword suggestions
            const keywordSuggestions = assistantMessages.querySelectorAll('.keyword-suggestion');
            keywordSuggestions.forEach(suggestion => {
                suggestion.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const keywordSuggestion = insights.analysis.keywordSuggestion;
                    const suggestedText = typeof keywordSuggestion === 'string' ? keywordSuggestion : keywordSuggestion?.suggestedKeyword;
                    
                    if (suggestedText && confirm(`Apply suggested refinement: "${suggestedText}"?`)) {
                        node.name = suggestedText;
                        updateGraph();
                        // Re-run Flow Assistant with the updated node (10x faster)
                        setTimeout(() => activateFlowAssistant(node), 50);
                    }
                });
            });
            
            // Add click handlers for all clickable suggestions (both pills and legacy spans)
            const clickableSuggestions = assistantMessages.querySelectorAll('.clickable-suggestion, .suggestion-pill');
            clickableSuggestions.forEach(suggestion => {
                suggestion.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const suggestionText = suggestion.dataset.suggestion;
                    
                    // Handle live suggestions differently (they update the input)
                    if (suggestion.classList.contains('live-suggestion')) {
                        if (suggestionText) {
                            // Update the input field with the suggestion
                            nodeInput.value = suggestionText;
                            nodeInput.focus();
                            
                            // Visual feedback
                            suggestion.style.transform = 'scale(0.95)';
                            suggestion.style.opacity = '0.7';
                            setTimeout(() => {
                                suggestion.style.transform = '';
                                suggestion.style.opacity = '';
                            }, 200);
                            
                            // Remove the typing overlay after selection
                            setTimeout(() => {
                                const overlay = assistantMessages.querySelector('.typing-suggestions-overlay');
                                if (overlay) overlay.remove();
                            }, 500);
                        }
                        return;
                    }
                    
                    // Handle regular Flow Assistant suggestions (create child nodes)
                    if (suggestionText && selectedNode) {
                        // Visual feedback - animate the clicked element
                        if (suggestion.classList.contains('suggestion-pill')) {
                            suggestion.style.transform = 'scale(0.95)';
                            suggestion.style.opacity = '0.7';
                            setTimeout(() => {
                                suggestion.style.transform = '';
                                suggestion.style.opacity = '';
                            }, 200);
                        }
                        
                        // Add the suggestion as a child node to the current selected node
                        const newNode = addNode(suggestionText, selectedNode);
                        if (newNode) {
                            updateGraph();
                            console.log(`✨ Added suggestion "${suggestionText}" as child of "${selectedNode.name}"`);
                            
                            // Auto-select the new node and trigger Flow Assistant
                            setTimeout(() => {
                                selectNode(newNode);
                                queueFlowAssistantUpdate(newNode.id, 'suggestion added', 'high');
                            }, 100);
                        }
                    }
                });
            });
            
            // Auto-place definitions under terms
            if (insights.analysis && insights.analysis.definitions) {
                insights.analysis.definitions.forEach(def => {
                    // Find if the term appears in the current node or nearby nodes
                    const termLower = def.term.toLowerCase();
                    if (node.name.toLowerCase().includes(termLower)) {
                        // Check if definition already exists as a child
                        const existingDef = nodes.find(n => 
                            n.parent === node.id && 
                            n.name.toLowerCase().includes('definition') ||
                            n.name.toLowerCase().includes(termLower)
                        );
                        
                        if (!existingDef) {
                            // Auto-add definition as a child node (10x faster)
                            setTimeout(() => {
                                const defNode = addNode(`📖 ${def.term}: ${def.definition}`, node);
                                if (defNode) {
                                    updateGraph();
                                }
                            }, 200);
                        }
                    }
                });
            }
        }

        // Expand/collapse insight card - simplified version since content is pre-loaded
        function expandInsight(element) {
            const preview = element.querySelector('.insight-preview');
            const full = element.querySelector('.insight-full');
            
            if (full.style.display === 'none' || full.style.display === '') {
                // Expanding the card
                preview.style.display = 'none';
                full.style.display = 'block';
                element.classList.add('expanded');
            } else {
                // Collapsing the card
                preview.style.display = 'block';
                full.style.display = 'none';
                element.classList.remove('expanded');
            }
        }

        // Generate AI-powered insight summary
        async function generateInsightSummary(title, preview, context) {
            const prompt = `You are providing an AI overview for a Flow Assistant insight card.

Insight Title: ${title}
Insight Preview: ${preview}
Context: ${context}

Generate a comprehensive but concise overview (2-3 paragraphs, max 200 words) that:
1. Explains the insight in detail
2. Provides actionable suggestions or deeper analysis
3. Relates to the current context when relevant
4. Uses a helpful, informative tone

Format as plain text with natural paragraph breaks.

CRITICAL: Your response must be VALID JSON only. Do not include any text before or after the JSON object. Ensure all strings are properly escaped and arrays/objects are properly closed. NO trailing commas allowed.`;

            try {
                const response = await callLocalAPIWithRateLimit(prompt, 300, 'high', 'standard');
                return response || 'Unable to generate detailed overview at this time.';
            } catch (error) {
                throw new Error('Failed to generate AI overview');
            }
        }

        // Helper function to get context from a node
        function getNodeContext(node) {
            const children = nodes.filter(n => n.parent === node.id).map(n => n.data.name);
            const siblings = node.parent ? nodes.filter(n => n.parent === node.parent && n.id !== node.id).map(n => n.data.name) : [];
            
            let context = [];
            if (children.length > 0) context.push(`children: ${children.slice(0, 3).join(', ')}`);
            if (siblings.length > 0) context.push(`siblings: ${siblings.slice(0, 3).join(', ')}`);
            
            return context.length > 0 ? context.join('; ') : 'isolated concept';
        }
        
        // Make expandInsight available globally
        window.expandInsight = expandInsight;
        
        // Global event listener for live suggestions (since they can appear anytime)
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('live-suggestion')) {
                e.preventDefault();
                e.stopPropagation();
                const suggestionText = e.target.getAttribute('data-suggestion');
                
                if (suggestionText) {
                    // Update the input field with the suggestion
                    nodeInput.value = suggestionText;
                    nodeInput.focus();
                    
                    // Visual feedback
                    e.target.style.transform = 'scale(0.95)';
                    e.target.style.opacity = '0.7';
                    setTimeout(() => {
                        e.target.style.transform = '';
                        e.target.style.opacity = '';
                    }, 200);
                    
                    // Live suggestions are now handled by Flow Assistant cards
                }
                return false;
            }
        });

        // Helper function to escape strings for JavaScript
        function escapeForJs(text) {
            return text.replace(/'/g, "\\'").replace(/"/g, '\\"');
        }

        // --- Advanced Theme Engine ---
        const themeDefinitions = {
            "Midnight Scholar": {
                dynastyPalettes: [
                    ["#2a5a82", "#4a7db9", "#6a9fdf", "#8abfff", "#aadaff"],
                    ["#8a4c4c", "#bc6c6c", "#d48c8c", "#ecacac", "#ffcccc"],
                    ["#6a5a7d", "#8a7aad", "#aa9acd", "#cabbed", "#eadbff"],
                    ["#5a5a5a", "#7a7a7a", "#9a9a9a", "#bababa", "#dadada"],
                    ["#4d6582", "#6d85b2", "#8da5d2", "#adc5f2", "#cde5ff"]
                ],
                backgroundBase: "#4a7aa2"
            },
            "Autumn Whisper": {
                dynastyPalettes: [
                    ["#8d4f2a", "#cd6f3a", "#ed8f5a", "#ffaf7a", "#ffcf9a"],
                    ["#9b5439", "#db7459", "#fb9479", "#ffb499", "#ffd4b9"],
                    ["#5a6539", "#7a8559", "#9aa579", "#bac599", "#dae5b9"],
                    ["#8d2020", "#cd4040", "#ed6060", "#ff8080", "#ffa0a0"],
                    ["#3f5353", "#5f7373", "#7f9393", "#9fb3b3", "#bfd3d3"]
                ],
                backgroundBase: "#ad6f4a"
            },
            "Ocean Depths": {
                dynastyPalettes: [
                    ["#2a4a73", "#4a6aa3", "#6a8ad3", "#8aaaff", "#aacaff"],
                    ["#2a5353", "#4a7373", "#6a9393", "#8ab3b3", "#aad3d3"],
                    ["#2f2f87", "#4f4fb7", "#6f6fd7", "#8f8ff7", "#afafff"],
                    ["#3f5353", "#5f7373", "#7f9393", "#9fb3b3", "#bfd3d3"],
                    ["#7d2a96", "#bd4ad6", "#dd6af6", "#fd8aff", "#ffaaff"]
                ],
                backgroundBase: "#4a6a93"
            },
            "Forest Sage": {
                dynastyPalettes: [
                    ["#3a632a", "#5a834a", "#7aa36a", "#9ac38a", "#bae3aa"],
                    ["#8d4f2a", "#cd6f3a", "#ed8f5a", "#ffaf7a", "#ffcf9a"],
                    ["#536339", "#738359", "#93a379", "#b3c399", "#d3e3b9"],
                    ["#7d9b7d", "#9dbb9d", "#bddbbd", "#ddfbdd", "#fdfffd"],
                    ["#3f5353", "#5f7373", "#7f9393", "#9fb3b3", "#bfd3d3"]
                ],
                backgroundBase: "#5a834a"
            },
            "Crimson Dusk": {
                dynastyPalettes: [
                    ["#8d2020", "#cd4040", "#ed6060", "#ff8080", "#ffa0a0"],
                    ["#8d2060", "#cd40a0", "#ed60c0", "#ff80e0", "#ffa0ff"],
                    ["#5e2082", "#8e40c2", "#ae60e2", "#ce80ff", "#eea0ff"],
                    ["#3f5353", "#5f7373", "#7f9393", "#9fb3b3", "#bfd3d3"],
                    ["#8d4f2a", "#cd6f3a", "#ed8f5a", "#ffaf7a", "#ffcf9a"]
                ],
                backgroundBase: "#ad4040"
            },
            "Arctic Twilight": {
                dynastyPalettes: [
                    ["#4e7d9b", "#6e9dbb", "#8ebddb", "#aeddfb", "#cefdff"],
                    ["#4e4e9c", "#6e6ecc", "#8e8eec", "#aeaeff", "#ceceef"],
                    ["#3f5353", "#5f7373", "#7f9393", "#9fb3b3", "#bfd3d3"],
                    ["#606060", "#808080", "#a0a0a0", "#c0c0c0", "#e0e0e0"],
                    ["#7d2a96", "#bd4ad6", "#dd6af6", "#fd8aff", "#ffaaff"]
                ],
                backgroundBase: "#6e9dbb"
            },
            "Neon Pulse": {
                dynastyPalettes: [
                    ["#e3208a", "#ff40aa", "#ff60ca", "#ff80ea", "#ffaaff"],
                    ["#20e380", "#40ffa0", "#60ffc0", "#80ffe0", "#aaffff"],
                    ["#8020e3", "#a040ff", "#c060ff", "#e080ff", "#ffaaff"],
                    ["#e38020", "#ffa040", "#ffc060", "#ffe080", "#ffffaa"],
                    ["#2080e3", "#40a0ff", "#60c0ff", "#80e0ff", "#aaffff"]
                ],
                backgroundBase: "#5a4073"
            },
            "Electric Storm": {
                dynastyPalettes: [
                    ["#ffff20", "#ffff40", "#ffff60", "#ffff80", "#ffffaa"],
                    ["#ff5520", "#ff7540", "#ff9560", "#ffb580", "#ffd5aa"],
                    ["#20ffff", "#40ffff", "#60ffff", "#80ffff", "#aaffff"],
                    ["#ff2093", "#ff40b3", "#ff60d3", "#ff80f3", "#ffaaff"],
                    ["#46d346", "#66f366", "#86ff86", "#a6ffa6", "#c6ffc6"]
                ],
                backgroundBase: "#404073"
            }
        };

        let currentTheme = "Crimson Dusk"; // Default theme
        let dynastyPalettes = themeDefinitions[currentTheme].dynastyPalettes;
        
        // Darken Midnight Scholar background
        themeDefinitions["Midnight Scholar"].backgroundBase = "#2a3a4a"; // darker than before
        
        // Track which palette each first-gen node gets
        let firstGenPaletteAssignment = new Map();
        
        const defs = svg.append("defs");

        // Create radial gradient for edge fadeout effect
        const fadeoutGradient = defs.append("radialGradient")
            .attr("id", "edge-fadeout")
            .attr("cx", "50%")
            .attr("cy", "50%")
            .attr("r", "50%");

        fadeoutGradient.append("stop")
            .attr("offset", "0%")
            .attr("stop-opacity", "1");

        fadeoutGradient.append("stop")
            .attr("offset", "85%")
            .attr("stop-opacity", "1");

        fadeoutGradient.append("stop")
            .attr("offset", "100%")
            .attr("stop-opacity", "0");

        // Add Roboto Slab to the page (if not already present)
        if (!document.getElementById('roboto-slab-font')) {
            const link = document.createElement('link');
            link.id = 'roboto-slab-font';
            link.rel = 'stylesheet';
            link.href = 'https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@400;500;700&display=swap';
            document.head.appendChild(link);
        }

        function applyTheme() {
            const theme = themeDefinitions[currentTheme];
            // Set the focus color for UI elements using the first dynasty's primary color
            const focusColorHex = theme.dynastyPalettes[0][0];
            document.querySelector(':root').style.setProperty('--ui-focus-dark', focusColorHex);
            const focusColor = d3.color(focusColorHex);
            if (focusColor) {
                 document.querySelector(':root').style.setProperty('--ui-focus-glow', `rgba(${focusColor.r}, ${focusColor.g}, ${focusColor.b}, 0.7)`);
            }
            // Create a sophisticated background gradient based on theme
            const baseColor = d3.hsl(theme.backgroundBase);
            baseColor.s *= 0.4; // Reduced saturation by 20% (was 0.5, now 0.4)
            const centerColor = d3.color(baseColor).darker(2.875).toString(); // 15% darker (2.5 * 1.15 = 2.875)
            const edgeColor = d3.color(baseColor).darker(4.6).toString(); // 15% darker (4 * 1.15 = 4.6)
            document.body.style.background = `radial-gradient(ellipse at center, ${centerColor} 0%, ${edgeColor} 100%)`;
            // --- Font switching by theme ---
            if (currentTheme === 'Forest Sage') {
                document.body.style.fontFamily = "'Roboto Slab', serif";
            } else {
                document.body.style.fontFamily = "'Helvetica Neue', Helvetica, Arial, sans-serif";
            }
        }

        function switchTheme(themeName) {
            currentTheme = themeName;
            dynastyPalettes = themeDefinitions[currentTheme].dynastyPalettes;
            applyTheme();
            
            // Update existing nodes with new colors while preserving dynasty assignments
            updateAllNodeColors();
            updateGraph();
        }

        function updateAllNodeColors() {
            nodes.forEach(node => {
                if (node.depth === 0) {
                    // Central node remains white
                    node.color = "#FFFFFF";
                } else if (node.depth === 1) {
                    // First generation nodes keep their dynasty assignment but get new colors
                    const paletteIdx = firstGenPaletteAssignment.get(node.id);
                    if (paletteIdx !== undefined && dynastyPalettes[paletteIdx]) {
                        node.color = ensureTextVisible(dynastyPalettes[paletteIdx][0]);
                    }
                } else {
                    // Deeper generations: recalculate based on new dynasty colors with gradient evolution
                    let firstGenAncestor = node;
                    let currentNode = node;
                    
                    // Find the first generation ancestor
                    while (firstGenAncestor.depth > 1) {
                        const parentLink = links.find(l => l.target.id === firstGenAncestor.id);
                        firstGenAncestor = parentLink ? parentLink.source : null;
                        if (!firstGenAncestor) break;
                    }
                    
                    if (firstGenAncestor) {
                        const dynastyPaletteIdx = firstGenPaletteAssignment.get(firstGenAncestor.id);
                        if (dynastyPaletteIdx !== undefined && dynastyPalettes[dynastyPaletteIdx]) {
                            const palette = dynastyPalettes[dynastyPaletteIdx];
                            
                            // Enhanced color evolution: transition through multiple colors as depth increases
                            const colorIndex = Math.min(currentNode.depth - 2, palette.length - 1);
                            const nextColorIndex = Math.min(currentNode.depth - 1, palette.length - 1);
                            
                            // For 3rd+ generation, create gradient blending between colors
                            if (currentNode.depth >= 3 && nextColorIndex < palette.length - 1) {
                                const baseColor = d3.color(palette[colorIndex]);
                                const nextColor = d3.color(palette[nextColorIndex]);
                                const blendFactor = (currentNode.depth - 3) * 0.25; // Gradual transition
                                
                                if (baseColor && nextColor) {
                                    const blendedColor = d3.interpolate(baseColor, nextColor)(Math.min(blendFactor, 1));
                                    currentNode.color = ensureTextVisible(blendedColor.toString());
                                } else {
                                    currentNode.color = ensureTextVisible(palette[colorIndex]);
                                }
                            } else {
                                currentNode.color = ensureTextVisible(palette[colorIndex]);
                            }
                        }
                    }
                }
            });
        }
        
        // Helper function to check if a color is too bright for white text
        function isColorTooBright(color) {
            const d3Color = d3.color(color);
            if (!d3Color) return false;
            // Standard luminance calculation
            const luminance = (0.299 * d3Color.r + 0.587 * d3Color.g + 0.114 * d3Color.b) / 255;
            return luminance > 0.5; // Lowered threshold for better contrast
        }

        function ensureTextVisible(color) {
            const d3Color = d3.color(color);
            if (!d3Color) return color;
            
            // Calculate contrast ratio with white text
            const luminance = (0.299 * d3Color.r + 0.587 * d3Color.g + 0.114 * d3Color.b) / 255;
            
            // If color is too bright (luminance > 0.5), darken it significantly
            if (luminance > 0.5) {
                // Darken until we get good contrast
                let darkened = d3Color.darker(2);
                let newLuminance = (0.299 * darkened.r + 0.587 * darkened.g + 0.114 * darkened.b) / 255;
                
                // Keep darkening if still too bright, but stop before getting too dark
                while (newLuminance > 0.4 && darkened.l > 0.2) { // Increased minimum lightness from 0.1 to 0.2
                    darkened = darkened.darker(0.5);
                    newLuminance = (0.299 * darkened.r + 0.587 * darkened.g + 0.114 * darkened.b) / 255;
                }
                
                return darkened.toString();
            }
            
            // If color is too dark (luminance < 0.15), brighten it slightly to prevent pure black
            if (luminance < 0.15) {
                let brightened = d3Color.brighter(0.5);
                let newLuminance = (0.299 * brightened.r + 0.587 * brightened.g + 0.114 * brightened.b) / 255;
                
                // Keep brightening until we reach minimum acceptable darkness
                while (newLuminance < 0.15 && brightened.l < 0.8) {
                    brightened = brightened.brighter(0.3);
                    newLuminance = (0.299 * brightened.r + 0.587 * brightened.g + 0.114 * brightened.b) / 255;
                }
                
                return brightened.toString();
            }
            
            // If color is already in acceptable range, return as is
            return color;
        }

        // --- User Instructions & LLM Assistant System ---
        function updateUserInstruction(text) {
            currentInstruction.textContent = text;
        }

        function addAssistantMessage(text, suggestions = []) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'assistant-message';
            
            messageDiv.innerHTML = `
                <div class="assistant-content">
                    <div class="assistant-name">CogniFlow Assistant</div>
                    <div class="assistant-text">${text}</div>
                    ${suggestions.length > 0 ? `
                        <div class="assistant-suggestions">
                            ${suggestions.map(suggestion => 
                                `<div class="suggestion-chip" onclick="handleSuggestionClick('${suggestion}')">${suggestion}</div>`
                            ).join('')}
                        </div>
                    ` : ''}
                </div>
            `;
            
            assistantMessages.appendChild(messageDiv);
            assistantMessages.scrollTop = assistantMessages.scrollHeight;
        }

        // Make handleSuggestionClick available globally for onclick handlers
        window.handleSuggestionClick = function(suggestion) {
            // Don't interrupt if user is typing
            if (document.activeElement === nodeInput && nodeInput.value.trim() !== '') return;
            
            if (selectedNode) {
                const newNode = addNode(suggestion, selectedNode);
                if (newNode) {
                    handleNodeClick(null, newNode);
                    // Don't immediately trigger more suggestions
                }
            } else if (nodes.length === 0) {
                const newNode = addNode(suggestion, null);
                if (newNode) {
                    handleNodeClick(null, newNode);
                }
            }
        };

        async function generateContextualSuggestions() {
            if (nodes.length === 0) return;
            
            // Don't interrupt if user is typing
            if (document.activeElement === nodeInput && nodeInput.value.trim() !== '') return;
            
            // Create context from the current mind map structure
            const context = buildMindMapContext();
            
            const prompt = `Based on mind map: ${context}
Suggest 3-5 concise nodes (2-3 words each) as JSON array.`;
            
            // Run async without blocking
            callLocalAPI(prompt, 200).then(response => {
                if (response) {
                    try {
                        const suggestions = JSON.parse(response);
                        if (Array.isArray(suggestions)) {
                            addAssistantMessage("Suggested ideas:", suggestions.slice(0, 5));
                        }
                    } catch (e) {
                        // Silent fail - don't interrupt user
                    }
                }
            }).catch(e => {
                // Silent fail
            });
        }

        function buildMindMapContext() {
            if (nodes.length === 0) return "Empty mind map";
            
            const centralNode = nodes.find(n => n.depth === 0);
            if (!centralNode) return "No central node";
            
            let context = `Central idea: "${centralNode.name}"`;
            
            // Add first generation nodes
            const firstGenNodes = nodes.filter(n => n.depth === 1);
            if (firstGenNodes.length > 0) {
                context += `\nMain branches: ${firstGenNodes.map(n => `"${n.name}"`).join(', ')}`;
            }
            
            // Add deeper nodes with their hierarchy
            const deeperNodes = nodes.filter(n => n.depth > 1);
            if (deeperNodes.length > 0) {
                context += `\nSub-topics: ${deeperNodes.map(n => `"${n.name}"`).join(', ')}`;
            }
            
            return context;
        }

        // Keep the original function but add async AI version
        function generateGhostSuggestions(node) {
            // Generate contextual suggestions based on the node's content and context
            const suggestions = [];
            
            // Get existing children to avoid duplicates
            const existingChildren = nodes.filter(n => {
                const parentLink = links.find(l => l.target.id === n.id);
                return parentLink && parentLink.source.id === node.id;
            }).map(n => n.name.toLowerCase());
            
            // Base suggestions based on node name and common patterns
            const nodeName = node.name.toLowerCase();
            
            // Context-aware suggestions
            if (nodeName.includes('business') || nodeName.includes('company')) {
                suggestions.push('Strategy', 'Marketing', 'Finance', 'Operations', 'Team');
            } else if (nodeName.includes('project') || nodeName.includes('plan')) {
                suggestions.push('Timeline', 'Resources', 'Goals', 'Risks', 'Tasks');
            } else if (nodeName.includes('research') || nodeName.includes('study')) {
                suggestions.push('Methods', 'Data', 'Analysis', 'Results', 'Sources');
            } else if (nodeName.includes('design') || nodeName.includes('create')) {
                suggestions.push('Concept', 'Prototype', 'Testing', 'Feedback', 'Iteration');
            } else if (nodeName.includes('problem') || nodeName.includes('issue')) {
                suggestions.push('Causes', 'Solutions', 'Impact', 'Prevention', 'Action');
            } else if (nodeName.includes('learning') || nodeName.includes('education')) {
                suggestions.push('Concepts', 'Practice', 'Examples', 'Resources', 'Assessment');
            } else {
                // Generic suggestions that work for most contexts
                const genericSuggestions = [
                    'Details', 'Examples', 'Benefits', 'Challenges', 'Steps',
                    'Features', 'Components', 'Process', 'Requirements', 'Options',
                    'Analysis', 'Comparison', 'Timeline', 'Resources', 'Impact',
                    'Methods', 'Tools', 'Goals', 'Outcomes', 'Next Steps'
                ];
                
                // Randomly select from generic suggestions
                const shuffled = genericSuggestions.sort(() => 0.5 - Math.random());
                suggestions.push(...shuffled.slice(0, 5));
            }
            
            // Filter out existing children and limit to 3-4 suggestions
            const filteredSuggestions = suggestions
                .filter(s => !existingChildren.includes(s.toLowerCase()))
                .slice(0, Math.min(4, Math.max(3, suggestions.length)));
            
            // If we don't have enough unique suggestions, add some generic ones
            if (filteredSuggestions.length < 3) {
                const fallbackSuggestions = ['Ideas', 'Notes', 'Related', 'More'];
                fallbackSuggestions.forEach(s => {
                    if (filteredSuggestions.length < 3 && !existingChildren.includes(s.toLowerCase())) {
                        filteredSuggestions.push(s);
                    }
                });
            }
            
            return filteredSuggestions;
        }

        // AI-powered ghost suggestions for expanded nodes
        async function generateAIGhostSuggestions(node) {
            // Get parent context for better suggestions
            const parentLink = links.find(l => l.target.id === node.id);
            const parent = parentLink ? parentLink.source : null;
            
            const context = {
                node: node.name,
                parent: parent ? parent.name : null,
                siblings: parent ? nodes.filter(n => {
                    const pLink = links.find(l => l.target.id === n.id);
                    return pLink && pLink.source.id === parent.id && n.id !== node.id;
                }).map(n => n.name) : [],
                existing: nodes.filter(n => {
                    const pLink = links.find(l => l.target.id === n.id);
                    return pLink && pLink.source.id === node.id;
                }).map(n => n.name)
            };

            const prompt = `Suggest 4 child nodes for "${node.name}" (2-3 words max). Return JSON array only.`;

            const response = await callLocalAPIWithRateLimit(prompt, 100, 'low'); // Shorter limit for JSON array
            if (response) {
                try {
                    const suggestions = JSON.parse(response);
                    if (Array.isArray(suggestions)) {
                        return suggestions.slice(0, 4).map(s => s.substring(0, 20)); // Ensure short suggestions
                    }
                } catch (e) {
                    // Fallback to static suggestions
                    return generateGhostSuggestions(node);
                }
            }
            
            return generateGhostSuggestions(node);
        }

        // Advanced text wrapping function with dynamic width control (no truncation)
        function wrapTextPreview(textElement, textContent, maxWidth, lineHeight, startingDy = 0, fillColor = '#FFFFFF', fontWeight = '500', fontSize = null, opacity = 1, maxLines = 6) {
            if (!textContent || textContent.trim() === '') return;
            
            const words = textContent.split(/\s+/);
            let line = '';
            let lineCount = 0;
            let tspan = textElement.append('tspan')
                .attr('x', 0)
                .attr('dy', startingDy)
                .style('fill', fillColor)
                .style('font-weight', fontWeight)
                .style('opacity', opacity);
            
            if (fontSize) tspan.style('font-size', fontSize);
            
            for (let i = 0; i < words.length; i++) {
                const testLine = line + (line ? ' ' : '') + words[i];
                tspan.text(testLine);
                
                try {
                    if (tspan.node().getComputedTextLength() > maxWidth) {
                        if (line) {
                            // Current line is full, start a new line
                            lineCount++;
                            if (lineCount >= maxLines) {
                                // We've reached max lines, just continue on next line
                                tspan = textElement.append('tspan')
                                    .attr('x', 0)
                                    .attr('dy', lineHeight)
                                    .style('fill', fillColor)
                                    .style('font-weight', fontWeight)
                                    .style('opacity', opacity);
                                
                                if (fontSize) tspan.style('font-size', fontSize);
                                line = words[i];
                                tspan.text(line);
                            } else {
                                // Start new line
                                tspan = textElement.append('tspan')
                                    .attr('x', 0)
                                    .attr('dy', lineHeight)
                                    .style('fill', fillColor)
                                    .style('font-weight', fontWeight)
                                    .style('opacity', opacity);
                                
                                if (fontSize) tspan.style('font-size', fontSize);
                                line = words[i];
                                tspan.text(line);
                            }
                        } else {
                            // Single word is too long, just display it
                            tspan.text(words[i]);
                            // Continue to next word on new line
                            if (i < words.length - 1) {
                                tspan = textElement.append('tspan')
                                    .attr('x', 0)
                                    .attr('dy', lineHeight)
                                    .style('fill', fillColor)
                                    .style('font-weight', fontWeight)
                                    .style('opacity', opacity);
                                if (fontSize) tspan.style('font-size', fontSize);
                                line = '';
                            }
                        }
                    } else {
                        line = testLine;
                    }
                } catch (e) {
                    // Fallback if getComputedTextLength fails
                    if (line.length > 25) { // Increased threshold
                        lineCount++;
                        tspan = textElement.append('tspan')
                            .attr('x', 0)
                            .attr('dy', lineHeight)
                            .style('fill', fillColor)
                            .style('font-weight', fontWeight)
                            .style('opacity', opacity);
                        if (fontSize) tspan.style('font-size', fontSize);
                        line = words[i];
                        tspan.text(line);
                    } else {
                        line = testLine;
                    }
                }
            }
        }

        function wrapText(textElement, textContent, maxWidth, lineHeight, startingDy = 0, fillColor = '#FFFFFF', fontWeight = '500', fontSize = null, opacity = 1) {
            if (!textContent || textContent.trim() === '') return;
            
            const words = textContent.split(/\s+/);
            let line = [];
            let lineNumber = 0;
            const maxLines = 4; // Increased max lines to prevent truncation
            
            // Create first tspan
            let tspan = textElement.append('tspan')
                .attr('x', 0)
                .attr('dy', startingDy)
                .style('fill', fillColor)
                .style('font-weight', fontWeight)
                .style('opacity', opacity);
            
            if (fontSize) {
                tspan.style('font-size', fontSize);
            }
            
            // Process each word
            words.forEach((word, i) => {
                line.push(word);
                const testText = line.join(' ');
                tspan.text(testText);
                
                try {
                    // Check if line exceeds maximum width
                    if (tspan.node().getComputedTextLength() > maxWidth && line.length > 1) {
                        // Remove the last word that caused overflow
                        line.pop();
                        tspan.text(line.join(' '));
                        
                        // Start new line with the overflow word (removed max line check)
                        line = [word];
                        lineNumber++;
                        tspan = textElement.append('tspan')
                            .attr('x', 0)
                            .attr('dy', lineHeight)
                            .style('fill', fillColor)
                            .style('font-weight', fontWeight)
                            .style('opacity', opacity)
                            .text(word);
                        
                        if (fontSize) {
                            tspan.style('font-size', fontSize);
                        }
                    }
                } catch (e) {
                    // Fallback if getComputedTextLength fails
                    if (line.join(' ').length > 25) { // Increased threshold
                        lineNumber++;
                        tspan = textElement.append('tspan')
                            .attr('x', 0)
                            .attr('dy', lineHeight)
                            .style('fill', fillColor)
                            .style('font-weight', fontWeight)
                            .style('opacity', opacity);
                        if (fontSize) tspan.style('font-size', fontSize);
                        line = [word];
                        tspan.text(line.join(' '));
                    }
                }
            });
        }

        // Optimized font sizing based on zoom level and hierarchy for content viewing
        function updateDynamicFontSizes(specificNode = null) {
            const currentScale = d3.zoomTransform(svg.node()).k;

            nodeGroup.selectAll('.node').each(function(d) {
                if (specificNode && d.id !== specificNode.id) return;

                const text = d3.select(this).select('text');
                if (d.isExpanded || d.isListNode || d.isMediaNode) {
                    text.style('font-size', '0pt');
                    return;
                }

                // Optimized font sizing for better readability
                let baseSize;
                if (d.depth === 0) {
                    baseSize = 16; // Central node
                } else if (d.depth === 1) {
                    baseSize = 14; // First generation
                } else if (d.depth === 2) {
                    baseSize = 12; // Second generation
                } else {
                    baseSize = 10; // Third generation and beyond
                }

                // Zoom-responsive scaling - more conservative for better readability
                const zoomMultiplier = Math.max(0.6, Math.min(2.0, 1 / Math.sqrt(currentScale * 0.8)));
                const finalSize = Math.max(8, baseSize * zoomMultiplier);
                
                text.style('font-size', `${finalSize}pt`);

                // Improved opacity handling for better content visibility
                const opacity = currentScale < 0.15 && d.depth > 4 ? Math.max(0.3, (currentScale - 0.05) * 10) : 1;
                text.style('opacity', opacity);
            });
        }
        


        const simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).id(d => d.id).distance(d => {
                // Dynamically increase link distance for expanded/list/media nodes
                if (d.target.isExpanded || d.target.isListNode || d.target.isMediaNode) return 220;
                if (d.target.depth === 1) return 140;
                return d.targetDistance || 90;
            }).strength(0.12)) // Slightly stronger for more separation
            .force("charge", d3.forceManyBody().strength(d => {
                if (d.depth === 0) return -1000;
                if (d.depth === 1) return -700;
                if (d.isExpanded || d.isListNode || d.isMediaNode) return -600;
                return -350;
            }))
            .force("y", d3.forceY(container.clientHeight / 2).strength(0.04))
            .force("collide", d3.forceCollide().radius(d => {
                // Use bounding box for expanded/list/media nodes
                if (d.isExpanded || d.isListNode || d.isMediaNode) return 120;
                if (d.depth === 1) return 65;
                if (d.depth === 0) return d.radius + 45;
                return d.radius + 24;
            }).strength(1.0)) // Max strength for no overlap
            .force("linkRepel", forceLinkRepel())
            .force("textRepel", forceTextRepel())
            .force("bounds", forceViewportBounds())
            .force("nodeRepulsion", forceNodeRepulsion().strength(0.04)) // Stronger for more even spacing
            .velocityDecay(0.68)
            .alphaDecay(0.035)
            .alphaMin(0.001);

        const masterGroup = svg.append("g");
        let linkGroup = masterGroup.append("g").attr("class", "link-layer");
        let nodeGroup = masterGroup.append("g");
        
        const zoom = d3.zoom().scaleExtent([0.1, 4]).on("zoom", (event) => {
            masterGroup.attr("transform", event.transform);
            updateDynamicFontSizes(); // Update font sizes on zoom
        });
        svg.call(zoom);

        d3.select(container).on('click', handleBackgroundClick);

        // Helper function to find closest point on a line segment
        function getClosestPointOnLine(lineStart, lineEnd, point) {
            const A = point.x - lineStart.x;
            const B = point.y - lineStart.y;
            const C = lineEnd.x - lineStart.x;
            const D = lineEnd.y - lineStart.y;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            
            if (lenSq === 0) return lineStart; // Line is a point
            
            let param = dot / lenSq;
            
            // Clamp to line segment
            if (param < 0) param = 0;
            if (param > 1) param = 1;
            
            return {
                x: lineStart.x + param * C,
                y: lineStart.y + param * D
            };
        }

        // Refactored forceTextRepel to use d3.quadtree
        function forceTextRepel() {
            let strength = 0.3;
            let textNodes = [];
            function force(alpha) {
                const textRepelDistance = 25;
                const linkRepelDistance = 15;
                // Get current text positions
                textNodes = [];
                nodeGroup.selectAll('.node').each(function(d) {
                    if (!d.isExpanded && !d.isListNode && !d.isMediaNode) {
                        const textElement = d3.select(this).select('text');
                        const transform = textElement.attr('transform');
                        let textX = d.x;
                        let textY = d.y;
                        if (transform) {
                            const translateMatch = transform.match(/translate\(([^,]+),([^)]+)\)/);
                            if (translateMatch) {
                                textX = d.x + parseFloat(translateMatch[1]);
                                textY = d.y + parseFloat(translateMatch[2]);
                            }
                        }
                        
                        textNodes.push({
                            node: d,
                            x: textX,
                            y: textY,
                            textElement: textElement
                        });
                    }
                });
                
                // Apply repelling forces between text elements
                for (let i = 0; i < textNodes.length; i++) {
                    for (let j = i + 1; j < textNodes.length; j++) {
                        const a = textNodes[i];
                        const b = textNodes[j];
                        
                        const dx = b.x - a.x;
                        const dy = b.y - a.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < textRepelDistance && distance > 0) {
                            const force = (textRepelDistance - distance) / distance * strength * alpha;
                            const fx = dx * force;
                            const fy = dy * force;
                            
                            // Apply force to the nodes (which will move the text)
                            a.node.vx -= fx;
                            a.node.vy -= fy;
                            b.node.vx += fx;
                            b.node.vy += fy;
                        }
                    }
                    
                    // Apply repelling forces from link paths
                    const textNode = textNodes[i];
                    links.forEach(link => {
                        // Skip if this text belongs to nodes connected by this link
                        if (link.source.id === textNode.node.id || link.target.id === textNode.node.id) return;
                        
                        // Calculate closest point on link to text
                        const linkStart = { x: link.source.x, y: link.source.y };
                        const linkEnd = { x: link.target.x, y: link.target.y };
                        
                        // Simple distance check to link line segment
                        const closestPoint = getClosestPointOnLine(
                            linkStart, linkEnd, 
                            { x: textNode.x, y: textNode.y }
                        );
                        
                        const dx = textNode.x - closestPoint.x;
                        const dy = textNode.y - closestPoint.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < linkRepelDistance && distance > 0) {
                            const force = (linkRepelDistance - distance) / distance * strength * alpha * 0.5;
                            const fx = dx * force;
                            const fy = dy * force;
                            
                            textNode.node.vx += fx;
                            textNode.node.vy += fy;
                        }
                    });
                }
            }
            
            force.strength = function(_) {
                return arguments.length ? (strength = _, force) : strength;
            };
            
            return force;
        }

        // Simple force to push nodes away from each other
        function forceNodeRepulsion() {
            let nodes;
            let strength = 0.02;

            function force() {
                if (!nodes) return;
                
                for (let i = 0; i < nodes.length; i++) {
                    const nodeA = nodes[i];
                    if (nodeA.fx !== undefined || nodeA.fy !== undefined) continue;
                    
                    for (let j = i + 1; j < nodes.length; j++) {
                        const nodeB = nodes[j];
                        if (nodeB.fx !== undefined || nodeB.fy !== undefined) continue;
                        
                        const dx = nodeA.x - nodeB.x;
                        const dy = nodeA.y - nodeB.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 0 && distance < 100) {
                            const force = strength / distance;
                            const fx = (dx / distance) * force;
                            const fy = (dy / distance) * force;
                            
                            nodeA.vx += fx;
                            nodeA.vy += fy;
                            nodeB.vx -= fx;
                            nodeB.vy -= fy;
                        }
                    }
                }
            }

            force.initialize = function(_) { nodes = _; };
            force.strength = function(_) { return arguments.length ? (strength = _, force) : strength; };

            return force;
        }

        // --- Core Functions ---
        function updateGraph() {
            // --- LINKS ---
            linkGroup.selectAll(".link")
                .data(links, d => `${d.source.id}-${d.target.id}`)
                .join("path")
                .attr("class", "link")
                .attr("stroke", d => d.source.color)
                .style("stroke-opacity", 0.5);

            // --- NODES (The General Update Pattern) ---
            const node = nodeGroup.selectAll(".node")
                .data(nodes, d => d.id);

            // Exit
            node.exit().transition().duration(800).attr("transform", "scale(0)").remove();

            // Enter
            const nodeEnter = node.enter().append("g")
                .attr("class", "node")
                .attr("transform", d => `translate(${d.x},${d.y})`)
                .on("dblclick", handleNodeDoubleClick)
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            nodeEnter.append("circle");
            
            nodeEnter.append("text");

            nodeEnter.append('foreignObject')
                .style('opacity', 0)
                .style('pointer-events', 'none');

            // Update
            const nodeUpdate = nodeEnter.merge(node)
                .classed('selected', d => d.id === selectedNode?.id);

            nodeUpdate.each(function(d) {
                const el = d3.select(this);
                const circle = el.select('circle');
                const text = el.select('text');
                const fo = el.select('foreignObject');

                // Remove the hamburger icon indicator completely

                // Calculate dimensions based on state - larger to accommodate ghost nodes
                const foWidth = Math.min(320, container.clientWidth * 0.32); // Larger width for ghost nodes
                // Height calculation with more space for ghost nodes
                const baseHeight = 40; // Header height
                const notesHeight = 120; // Fixed notes area height
                const ghostNodeHeight = 90; // Space for ghost nodes
                const padding = 24; // Top and bottom padding
                const foHeight = Math.min(230, baseHeight + notesHeight + ghostNodeHeight + padding); // Larger height
                
                // Logic for Expanded View
                if (d.isExpanded) {
                    el.raise();
                    
                    // Smoothly morph the circle to a rounded rectangle
                    circle.transition()
                        .duration(600)
                        .ease(d3.easeCubicInOut)
                        .attr('r', 0);
                    
                    // Scale out text
                    text.transition()
                        .duration(300)
                        .attr('transform', 'scale(0)');
                    
                    // Expanded node sizing: auto height, max 70vh, min 180px, width matches list node
                    const foWidth = Math.max(260, Math.min(420, container.clientWidth * 0.35));
                    const minHeight = 180;
                    const maxHeight = Math.max(320, window.innerHeight * 0.7);
                    // We'll let the content determine the height, but cap it at maxHeight
                    fo.transition()
                        .duration(600)
                        .ease(d3.easeCubicInOut)
                        .attr('x', -foWidth / 2)
                        .attr('y', 0)
                        .attr('width', foWidth)
                        .attr('height', maxHeight)
                        .style('opacity', 1)
                        .on('end', () => {
                            fo.style('pointer-events', 'all')
                              .on('click', event => event.stopPropagation());
                        });
                    if (fo.select('.expanded-node-container').empty()) {
                        fo.html(''); // Clear previous content before rebuilding
                        const baseColor = d.color === '#FFFFFF' ? '#EAEAEA' : d.color;
                        const bgColor = d3.color(baseColor);
                        bgColor.opacity = 0.93;
                        const textColor = isColorTooBright(baseColor) ? '#000000' : '#FFFFFF';
                        const h2Color = isColorTooBright(baseColor) ? d3.color(baseColor).darker(1.5) : d3.color(baseColor).brighter(1.5);
                        // Match list node design
                        const borderRadius = '10px';
                        const padding = '12px 10px';
                        const fontSize = '11pt';
                        const notesFontSize = '10pt';
                        const notesLineHeight = '1.3';
                        const notesMinHeight = '60px';
                        const notesMaxHeight = 'none';
                        const notesPadding = '8px';
                        const notesBorderRadius = '8px';
                        const notesBg = 'rgba(255,255,255,0.10)';
                        const div = fo.append('xhtml:div')
                            .attr('class', 'expanded-node-container')
                            .style('width', '100%')
                            .style('min-height', minHeight + 'px')
                            .style('max-height', maxHeight + 'px')
                            .style('background-color', bgColor.toString())
                            .style('color', textColor)
                            .style('opacity', 0)
                            .style('border-radius', borderRadius)
                            .style('padding', padding)
                            .style('box-sizing', 'border-box')
                            .style('display', 'flex')
                            .style('flex-direction', 'column')
                            .style('gap', '8px')
                            .style('backdrop-filter', 'blur(4px)')
                            .style('font-size', fontSize)
                            .style('overflow', 'visible');
                        // Fade in the content after a delay
                        div.transition()
                            .delay(300)
                            .duration(300)
                            .style('opacity', 1);
                        // Header (title)
                        div.append('xhtml:h3')
                            .style('font-weight', '600')
                            .style('color', h2Color.toString())
                            .style('font-size', fontSize)
                            .style('margin', '0')
                            .style('padding', '0')
                            .style('text-align', 'center')
                            .style('flex-shrink', '0')
                            .attr('contenteditable', true)
                            .text(d.name)
                            .on('mousedown', event => event.stopPropagation())
                            .on('click', event => event.stopPropagation())
                            .on('keydown', function(event) { 
                                if (event.key === 'Enter') { 
                                    event.preventDefault(); 
                                    this.blur(); 
                                } 
                                event.stopPropagation(); 
                            })
                            .on('blur', function() { 
                                d.name = this.innerText; 
                                updateGraph(); 
                            });
                        // Notes text area - placed at the top, no scroll, let modal grow
                        const notesArea = div.append('xhtml:div')
                            .attr('class', 'notes-editor')
                            .style('min-height', notesMinHeight)
                            .style('max-height', notesMaxHeight)
                            .style('background-color', notesBg)
                            .style('border-radius', notesBorderRadius)
                            .style('padding', notesPadding)
                            .style('color', textColor)
                            .style('font-size', notesFontSize)
                            .style('line-height', notesLineHeight)
                            .style('overflow', 'visible')
                            .style('resize', 'none')
                            .style('margin-bottom', '8px')
                            .attr('contenteditable', true)
                            .text(d.notes || '')
                            .on('mousedown', event => event.stopPropagation())
                            .on('click', event => event.stopPropagation())
                            .on('keydown', event => event.stopPropagation())
                            .on('blur', function() { 
                                d.notes = this.innerText.trim(); 
                                updateGraph(); 
                            });
                        // Add placeholder text when empty
                        if (!d.notes) {
                            notesArea.style('color', 'rgba(255,255,255,0.5)')
                                .text('Click to add notes...')
                                .on('focus', function() {
                                    if (this.innerText === 'Click to add notes...') {
                                        this.innerText = '';
                                        d3.select(this).style('color', textColor);
                                    }
                                })
                                .on('click', event => event.stopPropagation());
                        }
                        // Bottom content area - horizontal layout for buttons and ghost nodes
                        const bottomArea = div.append('xhtml:div')
                            .style('display', 'flex')
                            .style('flex-direction', 'row')
                            .style('gap', '8px')
                            .style('flex-grow', '1')
                            .style('min-height', '80px')
                            .style('align-items', 'flex-start');
                        // Left side - Action buttons
                        const actionsContainer = bottomArea.append('xhtml:div')
                            .attr('class', 'ai-actions-container')
                            .style('display', 'flex')
                            .style('flex-direction', 'column')
                            .style('gap', '3px')
                            .style('flex-shrink', '0')
                            .style('width', '80px')
                            .style('align-items', 'stretch');
                        // Calculate lighter button color based on node color
                        const buttonColor = d3.color(baseColor).brighter(0.5).toString();
                        const buttonTextColor = isColorTooBright(buttonColor) ? '#000000' : '#FFFFFF';
                        const actions = ['Define', 'Expand On', 'Solutions'];
                        actions.forEach(action => {
                            actionsContainer.append('xhtml:button')
                                .attr('class', 'ai-action-btn')
                                .style('background-color', buttonColor)
                                .style('color', buttonTextColor)
                                .style('padding', '5px 8px')
                                .style('border-radius', '4px')
                                .style('border', 'none')
                                .style('cursor', 'pointer')
                                .style('font-size', '8pt')
                                .style('font-weight', '500')
                                .style('transition', 'opacity 0.2s ease')
                                .text(action)
                                .on('mouseover', function() {
                                    d3.select(this).style('opacity', '0.8');
                                })
                                .on('mouseout', function() {
                                    d3.select(this).style('opacity', '1');
                                })
                                .on('click', async function(event) {
                                    event.stopPropagation();
                                    event.preventDefault();
                                    let prompt = '';
                                    if (action === 'Define') {
                                        prompt = `Define "${d.name}" clearly and concisely.`;
                                    } else if (action === 'Expand On') {
                                        prompt = `Elaborate on "${d.name}" with key details or examples.`;
                                    } else if (action === 'Solutions') {
                                        prompt = `Suggest practical solutions or approaches for "${d.name}".`;
                                    }
                                    const aiResponse = await callLocalAPIWithRateLimit(prompt, 260, 'high', 'standard');
                                    if (aiResponse) {
                                        const currentNotes = d.notes || '';
                                        const newContent = aiResponse;
                                        d.notes = currentNotes ? `${currentNotes}\n\n${newContent}` : newContent;
                                        if (notesArea && notesArea.node()) {
                                            notesArea.node().innerText = d.notes;
                                            notesArea.style('color', textColor);
                                        }
                                        if (d.notes && notesArea.text() !== 'Click to add notes...') {
                                            notesArea.style('color', textColor);
                                        }
                                    } else {
                                        const currentNotes = d.notes || '';
                                        const newContent = `${action}: Content generation unavailable. Please check your API key.`;
                                        d.notes = currentNotes ? `${currentNotes}\n\n${newContent}` : newContent;
                                        if (notesArea && notesArea.node()) {
                                            notesArea.node().innerText = d.notes;
                                            notesArea.style('color', textColor);
                                        }
                                    }
                                });
                        });
                        // Right side - Ghost node suggestions with breathing animation
                        const ghostContainer = bottomArea.append('xhtml:div')
                            .attr('class', 'ghost-suggestions-container')
                            .style('display', 'flex')
                            .style('flex-direction', 'row')
                            .style('gap', '6px')
                            .style('flex-grow', '1')
                            .style('justify-content', 'flex-start')
                            .style('align-items', 'center')
                            .style('flex-wrap', 'wrap')
                            .style('overflow', 'hidden')
                            .style('padding', '2px');
                        generateAIGhostSuggestions(d).then(ghostSuggestions => {
                            ghostContainer.selectAll('*').remove();
                            ghostSuggestions.forEach((suggestion, index) => {
                                const textLength = suggestion.length;
                                const minSize = 45;
                                const maxSize = 70;
                                const size = Math.min(maxSize, Math.max(minSize, textLength * 3 + 35));
                                const ghostWrapper = ghostContainer.append('xhtml:div')
                                    .style('position', 'relative')
                                    .style('width', `${size}px`)
                                    .style('height', `${size}px`)
                                    .style('flex-shrink', '0');
                                const ghostNode = ghostWrapper.append('xhtml:div')
                                    .attr('class', 'ghost-node')
                                    .style('width', '100%')
                                    .style('height', '100%')
                                    .style('border-radius', '50%')
                                    .style('background-color', 'rgba(255,255,255,0.85)')
                                    .style('border', '2px solid rgba(255,255,255,0.3)')
                                    .style('display', 'flex')
                                    .style('align-items', 'center')
                                    .style('justify-content', 'center')
                                    .style('cursor', 'pointer')
                                    .style('transition', 'all 0.3s ease')
                                    .style('font-size', textLength > 12 ? '6pt' : '7pt')
                                    .style('font-weight', '500')
                                    .style('color', '#333')
                                    .style('text-align', 'center')
                                    .style('padding', '4px')
                                    .style('box-sizing', 'border-box')
                                    .style('word-break', 'break-word')
                                    .style('overflow', 'hidden')
                                    .style('line-height', '1.1')
                                    .style('white-space', 'normal')
                                    .style('hyphens', 'auto')
                                    .style('animation', `breathe ${3 + index * 0.3}s ease-in-out infinite`)
                                    .style('animation-delay', `${index * 0.2}s`)
                                    .text(suggestion)
                                .on('mouseover', function() {
                                    d3.select(this)
                                        .style('background-color', 'rgba(255,255,255,1)')
                                        .style('border-color', 'rgba(255,255,255,0.8)')
                                        .style('transform', 'scale(1.1)')
                                        .style('animation-play-state', 'paused');
                                })
                                .on('mouseout', function() {
                                    d3.select(this)
                                        .style('background-color', 'rgba(255,255,255,0.85)')
                                        .style('border-color', 'rgba(255,255,255,0.3)')
                                        .style('transform', 'scale(1)')
                                        .style('animation-play-state', 'running');
                                })
                                .on('click', function(event) {
                                    event.stopPropagation();
                                    // Add the suggested node as a child
                                    const newNode = addNode(suggestion, d);
                                    if (newNode) {
                                        // Close the expanded view
                                        closeExpandedView(d);
                                        // Select the new node
                                        handleNodeClick(null, newNode);
                                    }
                                });
                            });
                        });
                    }
                } else if (d.isListNode) { // Logic for List Node View
                    // Compact sizing for list node
                    const itemHeight = 22;
                    const headerHeight = 28;
                    const topBottomPadding = 12; // Consistent top and bottom padding
                    const sidePadding = 10;
                    const minListItems = Math.max(3, d.listItems.length);
                    const listHeight = headerHeight + (minListItems * itemHeight) + (topBottomPadding * 2);
                    const maxItemTextLength = Math.max(d.name.length, ...d.listItems.map(item => item.text.length));
                    const listWidth = Math.max(220, Math.min(400, maxItemTextLength * 8 + 60));
                    d.radius = Math.hypot(listWidth, listHeight) / 2;
                    circle.attr('r', 0);
                    text.attr('transform', 'scale(0)');
                    
                    // Check if this is the first time rendering or if content has changed
                    const existingContainer = fo.select('.list-node-container');
                    const needsRebuild = existingContainer.empty() || d._lastListName !== d.name;
                    const needsItemUpdate = d._lastListItemCount !== d.listItems.length;
                    
                    if (needsRebuild) {
                        // Store current state for comparison
                        d._lastListItemCount = d.listItems.length;
                        d._lastListName = d.name;
                        
                    fo.transition()
                      .duration(400)
                      .ease(d3.easeCubicInOut)
                      .attr('x', -listWidth / 2)
                      .attr('y', -listHeight / 2)
                      .attr('width', listWidth)
                      .attr('height', listHeight)
                      .style('opacity', 1)
                      .on('end', () => {
                          fo.style('pointer-events', 'all')
                            .on('click', event => event.stopPropagation());
                          // Only render the list items after the expand animation completes
                              if (fo.select('.list-items-container').empty()) {
                          renderListNodeContent();
                              }
                      });
                    // Render only the container and header immediately
                    fo.html('');
                    const baseColor = d.color === '#FFFFFF' ? '#EAEAEA' : d.color;
                    const bgColor = d3.color(baseColor); bgColor.opacity = 0.9;
                    const textColor = isColorTooBright(baseColor) ? '#000000' : '#FFFFFF';
                    const headerColor = isColorTooBright(baseColor) ? d3.color(baseColor).darker(1.5) : d3.color(baseColor).brighter(1.5);
                    const div = fo.append('xhtml:div')
                        .attr('class', 'list-node-container')
                        .style('width', '100%')
                        .style('height', '100%')
                        .style('background-color', bgColor.toString())
                        .style('color', textColor)
                        .style('border-radius', '10px')
                            .style('padding', `${topBottomPadding}px ${sidePadding}px`)
                        .style('box-sizing', 'border-box')
                        .style('backdrop-filter', 'blur(4px)')
                        .style('display', 'flex')
                        .style('flex-direction', 'column')
                        .style('transition', 'background-color 0.3s ease');
                    // Header
                    div.append('xhtml:h3')
                            .style('margin', '0')
                        .style('font-size', '11pt')
                        .style('font-weight', '600')
                        .style('color', headerColor.toString())
                        .style('text-align', 'center')
                        .style('flex-shrink', '0')
                        .attr('contenteditable', true)
                        .text(d.name)
                        .on('mousedown', event => event.stopPropagation())
                        .on('keydown', function(event) { if (event.key === 'Enter') { event.preventDefault(); this.blur(); } event.stopPropagation(); })
                        .on('blur', function() { d.name = this.innerText; updateGraph(); });
                    // Function to render list items after animation
                    function renderListNodeContent() {
                        const listContainer = div.append('xhtml:div')
                            .attr('class', 'list-items-container')
                            .style('flex-grow', '1')
                            .style('display', 'flex')
                            .style('flex-direction', 'column')
                            .style('gap', '4px')
                                .style('margin-top', `${topBottomPadding}px`)
                            .style('transition', 'all 0.3s ease');
                        d.listItems.forEach((item, index) => {
                                addListItemElement(listContainer, item, index, d, textColor);
                            });
                        }
                    } else if (needsItemUpdate) {
                        // Only add new items without rebuilding existing ones
                        d._lastListItemCount = d.listItems.length;
                        
                        // Update container size
                        fo.transition()
                          .duration(400)
                          .ease(d3.easeCubicInOut)
                          .attr('x', -listWidth / 2)
                          .attr('y', -listHeight / 2)
                          .attr('width', listWidth)
                          .attr('height', listHeight);
                        
                        // Add only the new items
                        const listContainer = fo.select('.list-items-container');
                        const existingItems = listContainer.selectAll('[data-list-index]').size();
                        
                        // Add new items starting from the existing count
                        for (let i = existingItems; i < d.listItems.length; i++) {
                            const item = d.listItems[i];
                            addListItemElement(listContainer, item, i, d, isColorTooBright(d.color === '#FFFFFF' ? '#EAEAEA' : d.color) ? '#000000' : '#FFFFFF');
                        }
                    } else {
                        // Just update the size if content hasn't changed
                        fo.transition()
                          .duration(400)
                          .ease(d3.easeCubicInOut)
                          .attr('x', -listWidth / 2)
                          .attr('y', -listHeight / 2)
                          .attr('width', listWidth)
                          .attr('height', listHeight)
                          .style('opacity', 1);
                    }
                } else if (d.isMediaNode) { // Logic for Media Node View
                    // Better proportioned sizing to prevent clipping
                    const mediaWidth = 140;
                    const mediaHeight = 90;
                    d.radius = Math.hypot(mediaWidth, mediaHeight) / 2;
                    circle.attr('r', 0);
                    text.attr('transform', 'scale(0)');

                    fo.transition()
                      .duration(400)
                      .ease(d3.easeCubicInOut)
                      .attr('x', -mediaWidth / 2)
                      .attr('y', -mediaHeight / 2)
                      .attr('width', mediaWidth)
                      .attr('height', mediaHeight)
                      .style('opacity', 1)
                      .on('end', () => {
                          fo.style('pointer-events', 'all')
                            .on('click', event => event.stopPropagation());
                      });

                    // Render the container only once
                    if (fo.select('.media-node-container').empty()) {
                        fo.html('');
                        const baseColor = d.color === '#FFFFFF' ? '#EAEAEA' : d.color;
                        const bgColor = d3.color(baseColor); bgColor.opacity = 0.9;
                        const textColor = isColorTooBright(baseColor) ? '#000000' : '#FFFFFF';
                        const headerColor = isColorTooBright(baseColor) ? d3.color(baseColor).darker(1.5) : d3.color(baseColor).brighter(1.5);

                        const div = fo.append('xhtml:div')
                            .attr('class', 'media-node-container')
                            .style('width', '100%')
                            .style('height', '100%')
                            .style('background-color', bgColor.toString())
                                    .style('color', textColor)
                            .style('border-radius', '6px')
                            .style('padding', '8px')
                            .style('box-sizing', 'border-box')
                            .style('backdrop-filter', 'blur(4px)')
                            .style('display', 'flex')
                            .style('flex-direction', 'column')
                            .style('justify-content', 'space-between')
                            .style('align-items', 'center')
                            .style('text-align', 'center')
                            .style('overflow', 'hidden');

                        // Header (editable name) - better sizing and spacing
                        div.append('xhtml:h3')
                            .style('margin', '0')
                            .style('font-size', '8pt')
                            .style('font-weight', '600')
                            .style('color', headerColor.toString())
                            .style('text-align', 'center')
                                    .style('flex-shrink', '0')
                            .style('padding', '2px 4px')
                            .style('cursor', 'text')
                            .style('white-space', 'nowrap')
                            .style('overflow', 'hidden')
                            .style('text-overflow', 'ellipsis')
                            .style('max-width', '100%')
                            .attr('contenteditable', true)
                            .text(d.name)
                            .on('mousedown', event => event.stopPropagation())
                            .on('keydown', function(event) { if (event.key === 'Enter') { event.preventDefault(); this.blur(); } event.stopPropagation(); })
                            .on('blur', function() { d.name = this.innerText; });

                        // Media Preview Container - better proportioned
                        const previewContainer = div.append('xhtml:div')
                            .style('flex-grow', '1')
                            .style('display', 'flex')
                            .style('flex-direction', 'column')
                            .style('justify-content', 'center')
                            .style('align-items', 'center')
                            .style('overflow', 'hidden')
                            .style('border-radius', '4px')
                            .style('background', 'rgba(0,0,0,0.05)')
                            .style('padding', '6px')
                            .style('min-height', '0');

                        // Render based on media type with cleaner design
                        if (d.mediaType === 'image') {
                            // Show icon only for deeper generations (not first gen)
                            if (d.depth > 1) {
                                previewContainer.append('xhtml:div')
                                    .style('font-size', '16px')
                                    .style('margin-bottom', '3px')
                                    .text('🖼️');
                            }
                            // Link
                            previewContainer.append('xhtml:a')
                                .attr('href', d.mediaSrc)
                                .attr('target', '_blank')
                                .style('font-size', '8pt')
                                    .style('color', textColor)
                                .style('text-decoration', 'underline')
                                .style('cursor', 'pointer')
                                .style('text-align', 'center')
                                .style('line-height', '1.2')
                                .style('word-wrap', 'break-word')
                                .style('hyphens', 'auto')
                                .text('View Image');
                        } else if (d.mediaType === 'youtube') {
                            // Always try to get videoId from metadata or src
                            let videoId = d.mediaMetadata && d.mediaMetadata.videoId;
                            if (!videoId && d.mediaSrc) {
                                const match = d.mediaSrc.match(/[?&]v=([\w-]{11})/) || d.mediaSrc.match(/youtu\.be\/([\w-]{11})/);
                                if (match) videoId = match[1];
                            }
                            // Fallback: try to extract from originalUrl if present
                            if (!videoId && d.mediaMetadata && d.mediaMetadata.originalUrl) {
                                const match = d.mediaMetadata.originalUrl.match(/[?&]v=([\w-]{11})/) || d.mediaMetadata.originalUrl.match(/youtu\.be\/([\w-]{11})/);
                                if (match) videoId = match[1];
                            }
                            if (videoId) {
                                // Embed the YouTube video
                                previewContainer.append('xhtml:div')
                                    .style('width', '100%')
                                    .style('display', 'flex')
                                    .style('flex-direction', 'column')
                                    .style('align-items', 'center')
                                    .html(`
                                        <iframe width='100' height='56' style='border-radius:6px; margin-bottom:4px; border:none; background:#000;' src='https://www.youtube.com/embed/${videoId}' allowfullscreen></iframe>
                                        <div style='color:${textColor}; font-size:8pt; font-weight:600; text-align:center; max-width:90px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;'>${d.mediaMetadata && d.mediaMetadata.title ? d.mediaMetadata.title : 'YouTube'}</div>
                                    `);
                            } else if (d.mediaMetadata && d.mediaMetadata.thumbnail_url) {
                                previewContainer.append('xhtml:a')
                                    .attr('href', d.mediaMetadata?.originalUrl || d.mediaSrc)
                                    .attr('target', '_blank')
                                    .style('display', 'flex')
                                    .style('flex-direction', 'column')
                                    .style('align-items', 'center')
                                    .style('text-decoration', 'none')
                                    .html(`
                                        <img src='${d.mediaMetadata.thumbnail_url}' style='width:80px; border-radius:6px; margin-bottom:4px;'>
                                        <div style='color:${textColor}; font-size:8pt; font-weight:600; text-align:center; max-width:90px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;'>${d.mediaMetadata.title || 'YouTube'}</div>
                                    `);
                            } else {
                                // Fallback: generic icon and label
                            if (d.depth > 1) {
                                previewContainer.append('xhtml:div')
                                    .style('font-size', '16px')
                                    .style('margin-bottom', '3px')
                                    .text('▶️');
                            }
                            previewContainer.append('xhtml:a')
                                .attr('href', d.mediaMetadata?.originalUrl || d.mediaSrc)
                                .attr('target', '_blank')
                                .style('font-size', '8pt')
                                .style('color', textColor)
                                .style('text-decoration', 'underline')
                                .style('cursor', 'pointer')
                                .style('text-align', 'center')
                                .style('line-height', '1.2')
                                .text('YouTube');
                            }
                        } else if (d.mediaType === 'vimeo') {
                            // Show icon only for deeper generations
                            if (d.depth > 1) {
                                previewContainer.append('xhtml:div')
                                    .style('font-size', '16px')
                                    .style('margin-bottom', '3px')
                                    .text('🎬');
                            }
                            // Link
                            previewContainer.append('xhtml:a')
                                .attr('href', d.mediaMetadata?.originalUrl || d.mediaSrc)
                                .attr('target', '_blank')
                                .style('font-size', '8pt')
                                .style('color', textColor)
                                .style('text-decoration', 'underline')
                                .style('cursor', 'pointer')
                                .style('text-align', 'center')
                                .style('line-height', '1.2')
                                .text('Vimeo');
                        } else if (d.mediaType === 'twitter') {
                            // Show icon only for deeper generations
                            if (d.depth > 1) {
                                previewContainer.append('xhtml:div')
                                    .style('font-size', '16px')
                                    .style('margin-bottom', '3px')
                                    .text('𝕏');
                            }
                            // Link
                            previewContainer.append('xhtml:a')
                                .attr('href', d.mediaSrc)
                                .attr('target', '_blank')
                                .style('font-size', '8pt')
                                .style('color', textColor)
                                .style('text-decoration', 'underline')
                                .style('cursor', 'pointer')
                                .style('text-align', 'center')
                                .style('line-height', '1.2')
                                .text('x.com');
                        } else if (d.mediaType === 'github') {
                            const metadata = d.mediaMetadata || {};
                            // Show icon only for deeper generations
                            if (d.depth > 1) {
                                previewContainer.append('xhtml:div')
                                    .style('font-size', '16px')
                                    .style('margin-bottom', '3px')
                                    .text('⚡');
                            }
                            // Link
                            previewContainer.append('xhtml:a')
                                .attr('href', d.mediaSrc)
                                .attr('target', '_blank')
                                .style('font-size', '8pt')
                                .style('color', textColor)
                                .style('text-decoration', 'underline')
                                .style('cursor', 'pointer')
                                .style('text-align', 'center')
                                .style('line-height', '1.2')
                                .style('word-wrap', 'break-word')
                                .text(`${metadata.owner}/${metadata.repo}` || 'GitHub');
                        } else if (d.mediaType === 'pdf') {
                            // Show icon only for deeper generations
                            if (d.depth > 1) {
                                previewContainer.append('xhtml:div')
                                    .style('font-size', '16px')
                                    .style('margin-bottom', '3px')
                                    .text('📄');
                            }
                            // Link
                            previewContainer.append('xhtml:a')
                                .attr('href', d.mediaSrc)
                                .attr('target', '_blank')
                                .style('font-size', '8pt')
                                .style('color', textColor)
                                .style('text-decoration', 'underline')
                                .style('cursor', 'pointer')
                                .style('text-align', 'center')
                                .style('line-height', '1.2')
                                .text('PDF');
                        } else if (d.mediaType === 'link') {
                            const metadata = d.mediaMetadata || {};
                            // Show icon only for deeper generations
                            if (d.depth > 1) {
                                previewContainer.append('xhtml:div')
                                    .style('font-size', '16px')
                                    .style('margin-bottom', '3px')
                                    .text(metadata.isSecure ? '🔗' : '🌐');
                            }
                            // Domain link
                            previewContainer.append('xhtml:a')
                                .attr('href', d.mediaSrc)
                                .attr('target', '_blank')
                                .style('font-size', '8pt')
                                .style('color', textColor)
                                .style('text-decoration', 'underline')
                                .style('cursor', 'pointer')
                                .style('text-align', 'center')
                                .style('line-height', '1.2')
                                .style('word-wrap', 'break-word')
                                .text(metadata.domain || 'Link');
                        } else if (d.mediaType === 'file') {
                            // Show icon only for deeper generations
                            if (d.depth > 1) {
                                previewContainer.append('xhtml:div')
                                    .style('font-size', '16px')
                                    .style('margin-bottom', '3px')
                                    .text('📁');
                            }
                            // Filename
                            previewContainer.append('xhtml:div')
                                .style('font-size', '8pt')
                                .style('color', textColor)
                                .style('text-align', 'center')
                                .style('word-wrap', 'break-word')
                                .style('line-height', '1.2')
                                .style('hyphens', 'auto')
                                .text(d.mediaSrc);
                        }
                    }
                } else { // Logic for Standard (Circle) View
                    // Set proper dimensions for the circle based on depth
                    if (d.depth === 0) {
                        // Make central node smaller by 5px
                        d.radius = 22; // Reduced from 27 by 5px
                        
                        // Text positioning for central node - below the circle, capitalized
                        const words = d.name.toUpperCase().split(/\s+/); // Convert to uppercase
                        const lineHeight = 22; // Line height for below-circle text
                        const maxWidth = 120; // Increased for better readability
                        const textOffsetY = d.radius + 16; // Set to 16 pixels spacing below circle
                        
                        // Clear existing text
                        text.text('');
                        
                        // Use the new text wrapping function
                        wrapText(text, words.join(' '), maxWidth, lineHeight, 0, '#E0E0E0', '500');
                        
                        // Add notes text if available - with proper wrapping
                        if (d.notes && d.notes.trim() !== '') {
                            const notesText = d.notes.trim();
                            const currentTspanCount = text.selectAll('tspan').size();
                            const startingDy = currentTspanCount > 0 ? lineHeight * 0.8 : 0;
                            
                            // Add wrapped notes with preview formatting (wider, smaller font, max 3 lines)
                            wrapTextPreview(text, notesText, maxWidth * 0.85, lineHeight * 0.5, startingDy, '#FFFFFF', '400', '6pt', 0.6, 3);
                        }
                        
                        // Position the text below the circle
                        const totalLines = text.selectAll('tspan').size();
                        text.attr('transform', `translate(0, ${textOffsetY})`)
                            .attr('dominant-baseline', 'hanging'); // Ensure text starts below circle
                        
                        // Style the text - smaller and less bold for a softer look
                        text.style('font-size', '13pt')
                            .style('letter-spacing', '0px')
                            .style('fill', '#E0E0E0')
                            .style('font-weight', '500');
                        
                        // Remove fisheye effect handlers
                        el.on('mouseenter', null).on('mouseleave', null);
                        // Add minimal breathing effect to the central node's circle
                        if (!circle.classed('breathing')) {
                            circle.classed('breathing', true);
                            circle.transition('breathe-in')
                                .duration(1800)
                                .ease(d3.easeSinInOut)
                                .attr('r', d.radius * 1.07)
                                .transition('breathe-out')
                                .duration(1800)
                                .ease(d3.easeSinInOut)
                                .attr('r', d.radius)
                                .on('end', function repeat() {
                                    d3.select(this)
                                      .transition('breathe-in')
                                      .duration(1800)
                                      .ease(d3.easeSinInOut)
                                      .attr('r', d.radius * 1.07)
                                      .transition('breathe-out')
                                      .duration(1800)
                                      .ease(d3.easeSinInOut)
                                      .attr('r', d.radius)
                                      .on('end', repeat);
                                });
                        }
                    } else {
                        // Optimized node size scaling for better content visibility
                        if (d.depth === 1) {
                            d.radius = 18; // Slightly smaller first generation for better balance
                        } else if (d.depth === 2) {
                            d.radius = 14; // Second generation
                        } else if (d.depth === 3) {
                            d.radius = 11; // Third generation  
                        } else if (d.depth === 4) {
                            d.radius = 9; // Fourth generation
                        } else {
                            d.radius = 8; // Fifth generation and beyond - larger minimum for readability
                        }
                        
                        // For non-central nodes, ensure single line text and proper color
                        let textColor;
                        if (d.depth === 1) {
                            // First generation: use a softer, lighter version of the background color, 10% whiter
                            const baseTextColor = d3.color(d.color).brighter(1.8);
                            // Make it 10% whiter by interpolating towards white
                            textColor = d3.interpolate(baseTextColor, '#FFFFFF')(0.1).toString();
                        } else {
                            // Other depths: use a soft light gray or black
                            textColor = isColorTooBright(d.color) ? '#000000' : '#E0E0E0';
                        }
                        
                        // Clear existing text and rebuild with notes
                        text.text('');
                        
                        // Optimized text positioning and sizing for content viewing
                        let textOffsetY;
                        let maxWidth;
                        // Reduce line height for 2nd generation and beyond
                        let lineHeight;
                        if (d.depth >= 2) {
                            lineHeight = 14; // Balanced compactness and readability
                        } else {
                            lineHeight = 16;
                        }

                        if (d.depth === 1) {
                            // First generation: text inside the node (centered)
                            textOffsetY = 0;
                            maxWidth = 120; // Increased for first generation to prevent truncation
                            text.attr('dominant-baseline', 'middle');
                        } else if (d.depth === 2) {
                            // Second generation: text below the node
                            textOffsetY = d.radius + 14;
                            maxWidth = 80; // Increased for better readability
                            text.attr('dominant-baseline', 'hanging');
                        } else if (d.depth === 3) {
                            // Third generation: balanced width
                            textOffsetY = d.radius + 12;
                            maxWidth = 70; // Increased for better readability
                            text.attr('dominant-baseline', 'hanging');
                        } else {
                            // Fourth generation and beyond: still readable
                            textOffsetY = d.radius + 10;
                            maxWidth = 60; // Increased for better readability
                            text.attr('dominant-baseline', 'hanging');
                        }
                        
                        // Use the new text wrapping function for the main heading
                        wrapText(text, d.name, maxWidth, lineHeight, 0, textColor, '500');
                        
                        // Add notes if available - with proper wrapping
                        if (d.notes && d.notes.trim() !== '') {
                            const notesText = d.notes.trim();
                            const currentTspanCount = text.selectAll('tspan').size();
                            const startingDy = currentTspanCount > 0 ? lineHeight * 0.8 : 0;
                            
                            // Add wrapped notes with preview formatting (wider, smaller font, max 3 lines)
                            wrapTextPreview(text, notesText, maxWidth * 0.75, lineHeight * 0.6, startingDy, '#FFFFFF', '400', '6pt', 0.6, 3);
                        }
                        
                        // Position the text properly
                        text.attr('transform', `translate(0, ${textOffsetY})`);
                    }
                    
                    // If we're transitioning back from expanded, animate it
                    if (d.wasExpanded) {
                        d.wasExpanded = false; // Consume the flag immediately

                        fo.style('pointer-events', 'none');
                        
                        // All animations happen simultaneously
                        // Fade out the content
                        fo.select('.expanded-node-container')
                            .transition()
                            .duration(300)
                            .style('opacity', 0);
                        
                        // Shrink the foreignObject
                        fo.transition()
                            .duration(600)
                            .ease(d3.easeCubicInOut)
                            .attr('x', 0)
                            .attr('y', 0)
                            .attr('width', 0)
                            .attr('height', 0)
                            .style('opacity', 0)
                            .on('end', function() {
                                d3.select(this).html(''); // Clean up content after transition
                            });
                        
                        // Simultaneously morph back to circle
                        circle.transition()
                            .duration(600)
                            .ease(d3.easeCubicInOut)
                            .attr('r', d.radius);
                        
                        // And scale text back in
                        text.transition()
                            .duration(600)
                            .ease(d3.easeCubicInOut)
                            .attr('transform', d.depth === 0 ? `translate(0, ${d.radius + 16}) scale(1)` : 'scale(1)');
                    } else {
                        // Normal rendering (no transition needed)
                        fo.style('opacity', 0).style('pointer-events', 'none');
                        circle.attr('r', d.radius);
                        text.attr('transform', d.depth === 0 ? `translate(0, ${d.radius + 16}) scale(1)` : 'scale(1)');
                    }
                    
                    // Handle fill and fadeout effect for selected nodes
                    const isSelected = selectedNode && selectedNode.id === d.id;
                    
                    if (isSelected) {
                        // Update gradient color and apply it to selected nodes
                        const fadeoutGradient = defs.select("#edge-fadeout");
                        fadeoutGradient.selectAll("stop")
                            .attr("stop-color", d.color);
                        circle.attr('fill', 'url(#edge-fadeout)');
                    } else {
                        circle.attr('fill', d.color);
                    }
                    
                    // Add subtle glow to central node when not selected
                    if (d.depth === 0 && !isSelected) {
                        circle.style('filter', 'drop-shadow(0 0 8px rgba(255, 255, 255, 0.05))');
                    } else if (!isSelected) {
                        circle.style('filter', null); // Remove any existing filter
                    }
                    // When selected (including central node), the CSS .node.selected circle filter takes over
                }
            });

            simulation.nodes(nodes);
            simulation.force("link").links(links);
            
            // Apply dynamic font sizing after node updates
            setTimeout(() => updateDynamicFontSizes(), 50);
        }

        function generateBranchPath(d) {
            const dx = d.target.x - d.source.x;
            const dy = d.target.y - d.source.y;
            const length = Math.sqrt(dx * dx + dy * dy);

            // If nodes are on top of each other, fallback to a straight line
            if (length === 0) {
                return `M${d.source.x},${d.source.y} L${d.target.x},${d.target.y}`;
            }

            // Normalized perpendicular vector to calculate control point offset
            let nx = -dy / length;
            let ny = dx / length;

            // Randomly reverse curve direction for some connectors
            // Use a combination of node IDs to create consistent but varied curve directions
            const curveHash = (d.source.id * 31 + d.target.id * 17) % 100;
            const shouldReverseCurve = curveHash < 50; // 50% chance to reverse
            
            if (shouldReverseCurve) {
                nx = -nx;
                ny = -ny;
            }

            // Base curvature is reactive to the child's depth, creating a fanning effect.
            const baseCurvature = d.target.depth * 8;

            // A continuous, subtle sine wave animation, applied only to children of the central node
            // and only for nodes up to generation 3 (depth <= 3).
            // We add node IDs to desynchronize the animations of different links.
            const animOffset = (d.source.depth === 0 && d.target.depth <= 3) 
                ? Math.sin(Date.now() / 700 + d.source.id + d.target.id) * 4
                : 0;

            const totalCurvature = baseCurvature + animOffset;

            // Calculate the quadratic Bezier curve control point.
            const cpx = (d.source.x + d.target.x) / 2 + nx * totalCurvature;
            const cpy = (d.source.y + d.target.y) / 2 + ny * totalCurvature;

            const path = d3.path();
            path.moveTo(d.source.x, d.source.y);
            path.quadraticCurveTo(cpx, cpy, d.target.x, d.target.y);
            return path.toString();
        }
        
        simulation.on("tick", () => {
            linkGroup.selectAll(".link").attr("d", generateBranchPath);
            nodeGroup.selectAll(".node").attr("transform", d => `translate(${d.x},${d.y})`);
            
            // Post-tick bounding box overlap resolver
            const expandedNodes = nodes.filter(n => n.isExpanded || n.isListNode || n.isMediaNode);
            for (let i = 0; i < expandedNodes.length; i++) {
                for (let j = i + 1; j < expandedNodes.length; j++) {
                    const a = expandedNodes[i];
                    const b = expandedNodes[j];
                    // Assume 200x120 bounding box for expanded nodes
                    const ax1 = a.x - 100, ax2 = a.x + 100, ay1 = a.y - 60, ay2 = a.y + 60;
                    const bx1 = b.x - 100, bx2 = b.x + 100, by1 = b.y - 60, by2 = b.y + 60;
                    if (ax1 < bx2 && ax2 > bx1 && ay1 < by2 && ay2 > by1) {
                        // Overlap detected, nudge apart
                        const dx = b.x - a.x;
                        const dy = b.y - a.y;
                        const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                        const overlapX = (200 - Math.abs(dx)) / 2;
                        const overlapY = (120 - Math.abs(dy)) / 2;
                        a.x -= overlapX * (dx / dist) * 0.2;
                        a.y -= overlapY * (dy / dist) * 0.2;
                        b.x += overlapX * (dx / dist) * 0.2;
                        b.y += overlapY * (dy / dist) * 0.2;
                    }
                }
            }

            // Maintain minimum movement
            if (simulation.alpha() < 0.018) {
                simulation.alpha(0.018);
            }
        });
        
        function optimizeView(force = false) {
            if (nodes.length === 0) return;
            
            // Check if any nodes are outside the current viewport
            const transform = d3.zoomTransform(svg.node());
            const margin = 100;
            let needsReframing = force;
            
            if (!force) {
                nodes.forEach(node => {
                    const screenX = (node.x * transform.k) + transform.x;
                    const screenY = (node.y * transform.k) + transform.y;
                    const nodeRadius = (node.radius || 20) * transform.k;
                    
                    if (screenX - nodeRadius < margin || 
                        screenX + nodeRadius > container.clientWidth - margin ||
                        screenY - nodeRadius < margin || 
                        screenY + nodeRadius > container.clientHeight - margin) {
                        needsReframing = true;
                    }
                });
            }
            
            if (!needsReframing) return;
            
            const padding = 80; // Reduced padding for tighter zoom
            const xExtent = d3.extent(nodes, d => d.x);
            const yExtent = d3.extent(nodes, d => d.y);
            if (xExtent[0] === undefined) return;
            const [x0, x1] = xExtent;
            const [y0, y1] = yExtent;
            const fullWidth = x1 - x0;
            const fullHeight = y1 - y0;
            if (fullWidth === 0 || fullHeight === 0) return;
            const midX = x0 + fullWidth / 2;
            const midY = y0 + fullHeight / 2;
            const scale = Math.min(2.5, 1.8 / Math.max((fullWidth + padding) / container.clientWidth, (fullHeight + padding) / container.clientHeight)); // Much closer zoom by default
            const newTransform = d3.zoomIdentity.translate(container.clientWidth / 2 - scale * midX, container.clientHeight / 2 - scale * midY).scale(scale);
            svg.transition().duration(800).call(zoom.transform, newTransform) // Slightly longer for smoother transitions
                .on('end', updateDynamicFontSizes); // Update font sizes after zoom transition
        }

        // Function to add individual list items to the container
        function addListItemElement(container, item, index, node, textColor) {
            const itemElement = container.append('xhtml:div')
                .attr('data-list-index', index)
                .style('display', 'flex')
                .style('align-items', 'center')
                .style('gap', '6px')
                .style('padding', '2px 4px')
                .style('border-radius', '4px')
                .style('transition', 'background-color 0.2s ease')
                .style('cursor', 'pointer')
                .on('mouseenter', function() {
                    d3.select(this).style('background-color', 'rgba(255,255,255,0.1)');
                })
                .on('mouseleave', function() {
                    d3.select(this).style('background-color', 'transparent');
                })
                .on('click', function(event) {
                    event.stopPropagation();
                    // Handle item click (e.g., toggle checkbox for task lists)
                    if (node.listType === 'task') {
                        item.checked = !item.checked;
                        updateGraph();
                    }
                });
            
            // Add checkbox for task lists
            if (node.listType === 'task') {
                itemElement.append('xhtml:input')
                    .attr('type', 'checkbox')
                    .attr('checked', item.checked)
                    .style('margin', '0')
                    .style('cursor', 'pointer')
                    .on('change', function() {
                        item.checked = this.checked;
                        updateGraph();
                    });
            }
            
            // Add bullet or number for other list types
            if (node.listType === 'bullet') {
                itemElement.append('xhtml:span')
                    .style('color', textColor)
                    .style('font-size', '10pt')
                    .style('font-weight', 'bold')
                    .text('•');
            } else if (node.listType === 'numbered') {
                itemElement.append('xhtml:span')
                    .style('color', textColor)
                    .style('font-size', '10pt')
                    .style('font-weight', 'bold')
                    .style('min-width', '16px')
                    .text(`${index + 1}.`);
            }
            
            // Add the item text
            const textElement = itemElement.append('xhtml:span')
                .style('color', textColor)
                .style('font-size', '10pt')
                .style('line-height', '1.3')
                .style('flex-grow', '1')
                .style('word-wrap', 'break-word')
                .style('text-decoration', item.checked ? 'line-through' : 'none')
                .style('opacity', item.checked ? '0.7' : '1')
                .text(item.text);
            
            // Add delete button
            const deleteBtn = itemElement.append('xhtml:button')
                .style('background', 'none')
                .style('border', 'none')
                .style('color', textColor)
                .style('cursor', 'pointer')
                .style('font-size', '8pt')
                .style('opacity', '0.6')
                .style('padding', '0')
                .style('margin-left', '4px')
                .style('transition', 'opacity 0.2s ease')
                .text('×')
                .on('mouseenter', function() {
                    d3.select(this).style('opacity', '1');
                })
                .on('mouseleave', function() {
                    d3.select(this).style('opacity', '0.6');
                })
                .on('click', function(event) {
                    event.stopPropagation();
                    // Remove the item from the list
                    node.listItems.splice(index, 1);
                    updateGraph();
                });
        }

        // --- State Management ---
        // Removed setMode and selectNode functions, reverting to older, direct logic.

        // --- Interaction Logic ---
        function addNode(name, parent = null) {
            if (!name.trim()) return null;
            let newNode;

            // Check if this is a list type entry
            const listTypeMatch = name.match(/^(- |1\. |\[\] )(.*)/);
            const isListType = listTypeMatch !== null;
            let listType = null;
            let listContent = name;
            
            if (isListType) {
                if (listTypeMatch[1] === '- ') listType = 'bullet';
                else if (listTypeMatch[1] === '1. ') listType = 'numbered';
                else if (listTypeMatch[1] === '[] ') listType = 'task';
                listContent = listTypeMatch[2];
            }

            if (parent === null) {
                // This block should only ever create the VERY FIRST node.
                if (nodes.length > 0) {
                    console.error("Attempted to create a second central node. Action blocked.");
                    return null; // Prevent creating more than one root.
                }
                const color = "#FFFFFF"; // Central nodes are always white
                let x, y;
                x = container.clientWidth / 2;
                y = container.clientHeight / 2;
                newNode = { 
                    id: nextId++, 
                    name: isListType ? (listContent || 'New List') : name, 
                    depth: 0, 
                    children:[], 
                    x, y, fx: x, fy: y, 
                    color: color,
                    isListNode: false, // Central node cannot be a list
                    listType: undefined,
                listItems: undefined,
                isMediaNode: false,
                mediaType: null,
                mediaSrc: null,
                mediaMetadata: {},
                createdAt: Date.now() // Track creation time for consistency
                };
                nodes.push(newNode);
            } else {
                // If this is a list type entry, transform the parent into a list node
                if (isListType && parent && !parent.isListNode) {
                    // Save previous state for undo
                    const prevState = {
                        isListNode: parent.isListNode,
                        listType: parent.listType,
                        listItems: parent.listItems ? [...parent.listItems] : []
                    };
                                    // Transform the parent into a list node
                parent.isListNode = true;
                parent.listType = listType;
                parent.listItems = [];
                
                // Add the first item if there's content
                if (listContent) {
                    parent.listItems.push({
                        text: listContent,
                        checked: listType === 'task' ? false : undefined,
                        id: Date.now()
                    });
                }
                
                // Ensure the listItems array is properly initialized
                if (!parent.listItems) {
                    parent.listItems = [];
                }
                    // Push transformation to historyStack
                    historyStack.push({type: 'transform-list', nodeId: parent.id, prevState});
                    // Enter list entry mode for this node
                    isListEntryMode = true;
                    activeListNode = parent;
                    
                    updateGraph();
                    simulation.alpha(0.05).restart();
                    return parent; // Return the transformed parent
                }
                
                // Regular node creation
                const depth = parent.depth + 1;
                // Distance logic with reduced 1st generation connector length
                let targetDistance;
                if (depth === 1) {
                    // 1st generation: much larger minimum distance for better spacing
                    // Now: minimum 500px, maximum 650px
                    targetDistance = Math.max(500, 650 - parent.children.length * 8); // Varies from 650 down to 500
                } else {
                    // Other generations: keep original logic
                    targetDistance = Math.max(40, 150 - depth * 35); // e.g., 80, 45, 40...
                }

                if (!parent.children) parent.children = [];

                let finalColor;
                if (depth === 1) {
                    // First generation: each child gets a unique palette
                    const availablePalettes = dynastyPalettes.filter((_, idx) => !Array.from(firstGenPaletteAssignment.values()).includes(idx));
                    const paletteIdx = availablePalettes.length > 0 ? dynastyPalettes.indexOf(availablePalettes[0]) : parent.children.length % dynastyPalettes.length;
                    firstGenPaletteAssignment.set(nextId, paletteIdx);
                    finalColor = ensureTextVisible(dynastyPalettes[paletteIdx][0]);
                } else {
                    // Deeper generations: inherit from their dynasty's palette with gradient evolution
                    let firstGenAncestor = parent;
                    while (firstGenAncestor.depth > 1) {
                        const parentLink = links.find(l => l.target.id === firstGenAncestor.id);
                        firstGenAncestor = parentLink ? parentLink.source : null;
                    }
                    const dynastyPaletteIdx = firstGenPaletteAssignment.get(firstGenAncestor.id);
                    if (dynastyPaletteIdx !== undefined && dynastyPalettes[dynastyPaletteIdx]) {
                        const palette = dynastyPalettes[dynastyPaletteIdx];
                        
                        // Enhanced color evolution: transition through multiple colors as depth increases
                        const colorIndex = Math.min(depth - 2, palette.length - 1);
                        const nextColorIndex = Math.min(depth - 1, palette.length - 1);
                        
                        // For 3rd+ generation, create gradient blending between colors
                        if (depth >= 3 && nextColorIndex < palette.length - 1) {
                            const baseColor = d3.color(palette[colorIndex]);
                            const nextColor = d3.color(palette[nextColorIndex]);
                            const blendFactor = (depth - 3) * 0.25; // Gradual transition
                            
                            if (baseColor && nextColor) {
                                const blendedColor = d3.interpolate(baseColor, nextColor)(Math.min(blendFactor, 1));
                                finalColor = ensureTextVisible(blendedColor.toString());
                            } else {
                        finalColor = ensureTextVisible(palette[colorIndex]);
                            }
                        } else {
                            finalColor = ensureTextVisible(palette[colorIndex]);
                        }
                    } else {
                        finalColor = ensureTextVisible(d3.color(parent.color).brighter(0.3).toString());
                    }
                }

                // Restore cone-based placement logic
                const rootNode = nodes[0];
                if (!rootNode) return null; // Should not happen if we have a parent

                let bestAngle;
                if (parent.depth === 0) {
                    // For the central node, cycle through 7 positions with variations
                    const childIndex = parent.children.length;
                    const baseAngles = [
                        0,                      // Right (0°)
                        Math.PI,               // Left (180°)
                        -Math.PI / 2,          // Top (-90°)
                        -3 * Math.PI / 4,      // Top-left (-135°)
                        -Math.PI / 4,          // Top-right (-45°)
                        3 * Math.PI / 4,       // Bottom-left (135°)
                        Math.PI / 4            // Bottom-right (45°)
                    ];
                    
                    // Cycle through the seven base positions
                    const baseAngleIndex = childIndex % 7;
                    let baseAngle = baseAngles[baseAngleIndex];
                    
                    // Add more random variation for visual variety
                    const variationGroup = Math.floor(childIndex / 7); // Which cycle we're in (0, 1, 2, ...)
                    const maxVariation = Math.PI / 7; // ±~25 degrees max variation
                    // Add a random offset within the allowed range
                    const randomOffset = (Math.random() - 0.5) * maxVariation;
                    const variation = (variationGroup * (maxVariation / 2)) * (baseAngleIndex % 2 === 0 ? 1 : -1) + randomOffset;
                    bestAngle = baseAngle + variation;
                } else {
                    // For other nodes, use a 160-degree cone based on their own angle from the center
                    const parentAngle = Math.atan2(parent.y - rootNode.y, parent.x - rootNode.x);
                    const coneWidth = (160 * Math.PI) / 180;
                const coneStart = parentAngle - coneWidth / 2;

                const siblingAngles = parent.children.map(child => Math.atan2(child.y - parent.y, child.x - parent.x));
                    bestAngle = parentAngle; // Default to center

                if (siblingAngles.length > 0) {
                    let normalizedSiblings = siblingAngles.map(a => {
                        let norm = a - coneStart;
                        while(norm < 0) norm += 2 * Math.PI;
                        return norm % (2 * Math.PI);
                    }).filter(a => a <= coneWidth + 0.001).sort((a,b)=>a-b);

                    if (normalizedSiblings.length > 0) {
                        let maxGap = 0;
                        let angleAtMaxGap = -1;

                        maxGap = normalizedSiblings[0];
                        angleAtMaxGap = coneStart + maxGap / 2;

                        for(let i = 0; i < normalizedSiblings.length - 1; i++){
                            let gap = normalizedSiblings[i+1] - normalizedSiblings[i];
                            if (gap > maxGap) {
                                maxGap = gap;
                                angleAtMaxGap = coneStart + normalizedSiblings[i] + gap / 2;
                            }
                        }

                        let lastGap = coneWidth - normalizedSiblings[normalizedSiblings.length - 1];
                        if (lastGap > maxGap){
                            angleAtMaxGap = coneStart + normalizedSiblings[normalizedSiblings.length - 1] + lastGap / 2;
                        }
                        bestAngle = angleAtMaxGap;
                        }
                    }
                }

                newNode = {
                    id: nextId++, 
                    name: isListType ? (listContent || 'New List') : name, 
                    depth, 
                    children: [], 
                    x: parent.x + 20 * Math.cos(bestAngle), 
                    y: parent.y + 20 * Math.sin(bestAngle), 
                    color: finalColor,
                    isListNode: false,
                    listType: undefined,
                    listItems: undefined,
                    isMediaNode: false,
                    mediaType: null,
                    mediaSrc: null,
                    mediaMetadata: {},
                    createdAt: Date.now() // Track creation time for position fixing
                };
                nodes.push(newNode);
                
                // Fix position after time delay to prevent excessive floating
                if (depth >= 1) {
                    const fixDelay = depth === 1 ? 2000 : 4000; // 2s for 1st gen (faster), 4s for deeper
                    setTimeout(() => {
                        // Find the node again in case it was moved in the array
                        const nodeToFix = nodes.find(n => n.id === newNode.id);
                        if (nodeToFix && !nodeToFix.fx && !nodeToFix.fy) {
                            // Fix the node's position to stop floating
                            nodeToFix.fx = nodeToFix.x;
                            nodeToFix.fy = nodeToFix.y;
                        }
                    }, fixDelay);
                }

                links.push({ 
                    source: parent, target: newNode, 
                    targetDistance: targetDistance,
                    cp_dx_factor: (Math.random() - 0.5) * 0.4, cp_dy_factor: (Math.random() - 0.5) * 0.4
                });
                parent.children.push(newNode);
            }

            if (newNode) {
                historyStack.push(newNode);
                
                // Trigger Flow Assistant for new node events
                if (nodes.length > 1) {
                    detectSignificantMapChange('node_added', { 
                        id: newNode.id, 
                        parent: parent,
                        name: newNode.name 
                    });
                    
                    // Trigger contextual suggestions occasionally
                    if (Math.random() < 0.3) { // Reduced frequency
                        setTimeout(() => generateContextualSuggestions(), 6000); // Longer delay
                    }
                }
            }
            
            updateGraph();
            simulation.alpha(0.1).restart(); // Quick restart that settles fast
            
            // Intelligent camera panning - for central node, center immediately
            if (newNode && newNode.depth === 0) {
                setTimeout(() => optimizeView(true), 100); // Center central node quickly
            } else {
                // For other nodes, check if new node needs reframing
                setTimeout(() => optimizeView(), 500); // Delay to let node settle first
            }
            
            return newNode;
        }

        function removeNode(nodeToRemove) {
            if (!nodeToRemove) return;

            // Find parent before links are filtered, so we can update its children array
            const parentLink = links.find(l => l.target.id === nodeToRemove.id);
            const parentNode = parentLink ? parentLink.source : null;

            const nodesToDelete = new Set([nodeToRemove.id]);
            const findDescendants = (nodeId) => {
                links.filter(l => l.source.id === nodeId).forEach(l => {
                    nodesToDelete.add(l.target.id);
                    findDescendants(l.target.id);
                });
            };
            findDescendants(nodeToRemove.id);

            nodes = nodes.filter(n => !nodesToDelete.has(n.id));
            links = links.filter(l => !nodesToDelete.has(l.source.id) && !nodesToDelete.has(l.target.id));

            // *** FIX ***: Correctly remove the node from its parent's children array
            if (parentNode && parentNode.children) {
                parentNode.children = parentNode.children.filter(child => child.id !== nodeToRemove.id);
            }

            if (selectedNode && nodesToDelete.has(selectedNode.id)) {
                selectedNode = null;
                updateUserInstruction(nodes.length > 0 ? 'Select a node to continue' : 'Click to create your central idea');
                summarizeBtn.style.display = 'none';
                elaborateBtn.style.display = 'none';
            }
            
            updateGraph();
            simulation.alpha(0.1).restart(); // Quick restart that settles fast
            optimizeView();
        }

        function handleNodeClick(event, d) {
            if (event && event.sourceEvent) event.sourceEvent.stopPropagation();
            else if (event) event.stopPropagation();
            
            if (activeExpandedNode) closeExpandedView(activeExpandedNode);

            // Exit list entry mode if clicking a different node
            if (isListEntryMode && activeListNode && activeListNode.id !== d.id) {
                exitListEntryMode();
            }

            // Only update selection and UI, do not call updateGraph or restart simulation
            if (selectedNode) {
                nodeGroup.selectAll('.node').filter(n => n.id === selectedNode.id).classed('selected', false);
            }
            selectedNode = d;
            isPrimedForChild = true;

            if (selectedNode) {
                nodeGroup.selectAll('.node').filter(n => n.id === selectedNode.id).classed('selected', true);
                summarizeBtn.style.display = 'inline-block';
                elaborateBtn.style.display = 'inline-block';
                
                // Trigger intelligent Flow Assistant activation
                detectSignificantMapChange('node_selected', selectedNode);
                
                // Update instructions based on context
                if (isListEntryMode && activeListNode && activeListNode.id === d.id) {
                    updateUserInstruction(`Adding items to list "${d.name}" • Enter to add item • Shift+Enter for child node`);
                } else if (isPrimedForChild) {
                    updateUserInstruction(`Creating child of "${d.name}" • Enter to create child • Click elsewhere to cancel`);
                } else {
                    updateUserInstruction(`Selected "${d.name}" • Enter for sibling • Shift+Enter for child • Click node again for primed mode`);
                }
            }
            nodeInput.focus();
        }
        
        function handleNodeDoubleClick(event, d) {
            if (event) event.stopPropagation();
            
            // Don't allow expanding list nodes or the central node
            if (d.isListNode || d.isMediaNode || d.depth === 0) return;

            if (activeExpandedNode && activeExpandedNode.id !== d.id) {
                closeExpandedView(activeExpandedNode, () => openExpandedView(d));
            } else if (d.isExpanded) {
                closeExpandedView(d);
            } else {
                openExpandedView(d);
            }
        }

        window.addEventListener('drop', (event) => {
            event.preventDefault();
            container.style.border = 'none'; // Hide the container border

            if (dropTargetNode) {
                // Always remove the highlight from the drop target node
                nodeGroup.selectAll('.node').filter(n => n.id === dropTargetNode.id).classed('drop-target', false);
                
                const dt = event.dataTransfer;
                const files = dt.files;
                const url = dt.getData('text/uri-list') || dt.getData('text/plain');

                if (files.length > 0) {
                    // Handle file drop
                    const file = files[0];
                    if (file.type.startsWith('image/')) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            transformToMediaNode(dropTargetNode, 'image', e.target.result);
                        };
                        reader.readAsDataURL(file);
            } else {
                        // For other file types, just use the file name
                         transformToMediaNode(dropTargetNode, 'file', file.name);
                    }
                } else if (url) {
                    // --- Intelligent URL Processing ---
                    const linkInfo = intelligentLinkDetection(url);
                    transformToMediaNode(dropTargetNode, linkInfo.type, linkInfo.src, linkInfo.metadata);
                }
                // Reset drop target after processing
                dropTargetNode = null;
            }
        });

        svg.on('click', (event) => {
            // Check if we clicked on the background, not a node or button
            if (event.target !== container && event.target !== svg.node()) return;
            
            // Additional check to prevent closing on button clicks
            if (event.target.classList && (
                event.target.classList.contains('ai-action-btn') ||
                event.target.closest('.ai-action-btn') ||
                event.target.closest('.notes-editor') ||
                event.target.closest('.expanded-node-container')
            )) {
                return;
            }
            
            if (activeExpandedNode) {
                closeExpandedView(activeExpandedNode);
            }

            if (selectedNode) {
                nodeGroup.selectAll('.node').filter(n => n.id === selectedNode.id).classed('selected', false);
                selectedNode = null;
                isPrimedForChild = false;
                updateUserInstruction(nodes.length > 0 ? 'Select a node to continue' : 'Click to create your central idea');
                summarizeBtn.style.display = 'none';
                elaborateBtn.style.display = 'none';
            }
        });

        nodeInput.addEventListener('focus', () => {
            if (activeExpandedNode) {
                closeExpandedView(activeExpandedNode);
            }
        });

        function saveToHistory() {
            // TODO: In-depth history implementation for undo/redo
        }

        function openExpandedView(d) {
            d.isExpanded = true;
            activeExpandedNode = d;
            updateGraph();
            // --- Camera pan/zoom to center expanded node ---
            // Get node position
            const svgRect = svg.node().getBoundingClientRect();
            const centerX = svgRect.width / 2;
            const centerY = svgRect.height / 2;
            // Use d.x, d.y as node position in simulation coordinates
            // Calculate the current transform
            const currentTransform = d3.zoomTransform(svg.node());
            // Target: move d.x, d.y to center of viewport
            const targetScale = Math.max(0.7, Math.min(1.2, currentTransform.k)); // Keep scale reasonable
            const tx = centerX - d.x * targetScale;
            const ty = centerY - d.y * targetScale;
            // Animate the zoom/pan
            svg.transition()
                .duration(700)
                .call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(targetScale));
        }

        function closeExpandedView(d) {
            d.isExpanded = false;
            d.fx = d.x;
            d.fy = d.y;
            updateGraph();
            simulation.alpha(0.05).restart();
        }

        function handleBackgroundClick(event) {
            if (event.target !== container && event.target !== svg.node()) return;
            
            if (activeExpandedNode) {
                closeExpandedView(activeExpandedNode);
            }

            // Exit list entry mode
            if (isListEntryMode) {
                exitListEntryMode();
            }

            if (selectedNode) {
                nodeGroup.selectAll('.node').filter(n => n.id === selectedNode.id).classed('selected', false);
                selectedNode = null;
                isPrimedForChild = false;
                updateUserInstruction(nodes.length > 0 ? 'Select a node to continue' : 'Click to create your central idea');
                summarizeBtn.style.display = 'none';
                elaborateBtn.style.display = 'none';
                
                // Show Flow Assistant welcome message when no node is selected
                showFlowAssistantWelcome();
            }
        }

        function centerOnNode(d) {
            const foWidth = Math.min(320, container.clientWidth * 0.32);
            const foHeight = Math.min(230, container.clientHeight * 0.35);

            const width = svg.node().clientWidth;
            const height = svg.node().clientHeight;
            
            // For expanded nodes, calculate scale to ensure it fits comfortably on screen
            const scale = d.isExpanded ? 
                Math.min(
                    width / (foWidth * 2.5), 
                    height / (foHeight * 2.5),
                    1.8 // Increased max scale for closer zoom on expanded nodes
                ) : 
                1.5; // Closer default scale when not expanded

            const transform = d3.zoomIdentity
                .translate(width / 2, height / 2)
                .scale(scale)
                .translate(-d.x, -d.y);

            svg.transition()
                .duration(600) // Reduced transition duration
                .call(zoom.transform, transform)
                .on('end', updateDynamicFontSizes);
        }

        function exitListEntryMode() {
            isListEntryMode = false;
            activeListNode = null;
            if (selectedNode) {
                updateUserInstruction(`Selected "${selectedNode.name}" • Enter for sibling • Shift+Enter for child`);
            }
        }

        // Custom backspace logic for list entry mode
        let listBackspaceState = 0; // 0: normal, 1: highlight last, 2: delete
        nodeInput.addEventListener('keydown', (event) => {
            if (isListEntryMode && event.key === 'Backspace' && activeListNode && activeListNode.listItems.length > 0 && nodeInput.value === '') {
                event.preventDefault();
                if (listBackspaceState === 0) {
                    // Highlight last item for replacement
                    const idx = activeListNode.listItems.length - 1;
                    const node = nodeGroup.selectAll('.node').filter(d => d.id === activeListNode.id);
                    node.selectAll('.list-items-container > div').filter((d, i) => i === idx)
                        .style('background', '#ffb7b7')
                        .style('color', '#a00');
                    listBackspaceState = 1;
                } else if (listBackspaceState === 1) {
                    // Delete last item
                    activeListNode.listItems.pop();
                    listBackspaceState = 0;
                    updateGraph();
                }
            } else if (event.key !== 'Backspace') {
                listBackspaceState = 0;
                // Remove highlight if present
                if (activeListNode) {
                    const node = nodeGroup.selectAll('.node').filter(d => d.id === activeListNode.id);
                    node.selectAll('.list-items-container > div').style('background', '').style('color', '');
                }
            }
        });

        // Global keyboard event listener for Ctrl+Z undo functionality
        document.addEventListener('keydown', (event) => {
            // Only handle Ctrl+Z / Cmd+Z when not typing in the input field
            if ((event.ctrlKey || event.metaKey) && (event.key === 'z' || event.key === 'Z')) {
                // Don't interfere if user is actively typing
                if (document.activeElement === nodeInput && nodeInput.value.trim() !== '') return;
                
                event.preventDefault();
                const lastAction = historyStack.pop();
                if (lastAction) {
                    if (lastAction.type === 'transform-list') {
                        // Undo list transformation
                        const node = nodes.find(n => n.id === lastAction.nodeId);
                        if (node) {
                            node.isListNode = lastAction.prevState.isListNode;
                            node.listType = lastAction.prevState.listType;
                            node.listItems = lastAction.prevState.listItems;
                            updateGraph();
                            simulation.alpha(0.1).restart();
                        }
                    } else if (lastAction.type === 'transform-media') {
                        // Undo media transformation (implement if you have media node transforms)
                        const node = nodes.find(n => n.id === lastAction.nodeId);
                        if (node) {
                            node.isMediaNode = false;
                            node.mediaType = null;
                            node.mediaSrc = null;
                            node.mediaMetadata = {};
                            updateGraph();
                            simulation.alpha(0.1).restart();
                        }
                    } else {
                        // Default: remove node
                        const nodeToRemove = nodes.find(n => n.id === lastAction.id);
                        if(nodeToRemove) {
                            // Find the previous node to focus on after undo
                            const previousNode = historyStack.length > 0 ? historyStack[historyStack.length - 1] : null;
                            const previousNodeInGraph = previousNode ? nodes.find(n => n.id === previousNode.id) : null;
                            removeNode(nodeToRemove);
                            if (previousNodeInGraph) {
                                handleNodeClick(null, previousNodeInGraph);
                            } else if (nodes.length > 0) {
                                const centralNode = nodes.find(n => n.depth === 0);
                                if (centralNode) {
                                    handleNodeClick(null, centralNode);
                                }
                            }
                        }
                    }
                }
            }
            
            // Handle Ctrl+V for pasting images and URLs
            if ((event.ctrlKey || event.metaKey) && (event.key === 'v' || event.key === 'V')) {
                // Don't interfere if user is actively typing in input field
                if (document.activeElement === nodeInput) return;
                
                event.preventDefault();
                
                // Check if we have a selected node to attach the media to
                if (!selectedNode) {
                    // If no node selected, create a new central node or add to existing central node
                    const centralNode = nodes.find(n => n.depth === 0);
                    if (centralNode) {
                        selectedNode = centralNode;
                    } else {
                        // Create central node if none exists
                        selectedNode = addNode("Media Collection", null);
                        if (!selectedNode) return;
                    }
                }
                
                // Try to get clipboard data
                navigator.clipboard.read().then(async (clipboardItems) => {
                    for (const clipboardItem of clipboardItems) {
                        for (const type of clipboardItem.types) {
                            if (type.startsWith('image/')) {
                                // Handle image paste
                                const blob = await clipboardItem.getType(type);
                                const imageUrl = URL.createObjectURL(blob);
                                createMediaNode(selectedNode, 'image', imageUrl, { source: 'clipboard' });
                                return;
                            }
                        }
                    }
                }).catch(() => {
                    // Fallback: try to get text (URLs)
                    navigator.clipboard.readText().then(text => {
                        if (text && text.trim()) {
                            // Check if it's a URL
                            try {
                                new URL(text);
                                // It's a valid URL, create media node
                                const mediaInfo = intelligentLinkDetection(text);
                                if (mediaInfo) {
                                    createMediaNode(selectedNode, mediaInfo.type, mediaInfo.src, mediaInfo.metadata);
            }
          } catch (e) {
                                // Not a URL, ignore
                            }
                        }
                    }).catch(() => {
                        // Clipboard access failed, show user instruction
                        addAssistantMessage("To paste images: Copy an image from another tab, then Ctrl+V here. For URLs: Copy the URL and Ctrl+V here.", []);
                    });
                });
            }

            // --- Delete Node Logic (Delete / Backspace) ---
            // Only delete if not editing text (input, textarea, or contenteditable)
            const active = document.activeElement;
            const isEditing = active && (
                active.tagName === 'INPUT' ||
                active.tagName === 'TEXTAREA' ||
                active.isContentEditable
            );
            if (!isEditing && selectedNode && (event.key === 'Delete' || event.key === 'Backspace')) {
                event.preventDefault();
                removeNode(selectedNode);
            }
        });
        
        // Helper function to create media nodes
        function createMediaNode(parentNode, type, src, metadata = {}) {
            if (!parentNode) return null;
            
            // Save previous state for undo
            const prevState = {
                isMediaNode: parentNode.isMediaNode,
                mediaType: parentNode.mediaType,
                mediaSrc: parentNode.mediaSrc,
                mediaMetadata: parentNode.mediaMetadata ? {...parentNode.mediaMetadata} : {}
            };
            
            // If YouTube, fetch oEmbed data for title/thumbnail
            if (type === 'youtube') {
                // Extract video ID from src or metadata
                let videoId = null;
                if (metadata && metadata.videoId) {
                    videoId = metadata.videoId;
          } else {
                    // Try to extract from src
                    const match = src.match(/[?&]v=([\w-]{11})/) || src.match(/youtu\.be\/([\w-]{11})/);
                    if (match) videoId = match[1];
                }
                if (videoId) {
                    const oembedUrl = `https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${videoId}&format=json`;
                    fetch(oembedUrl)
                        .then(r => r.json())
                        .then(data => {
                            // Update node with oEmbed data
                            parentNode.mediaMetadata = {
                                ...metadata,
                                title: data.title,
                                thumbnail_url: data.thumbnail_url,
                                author_name: data.author_name,
                                oembed: true
                            };
                            updateGraph();
                        })
                        .catch(() => {
                            // Fallback to generic
                            parentNode.mediaMetadata = metadata;
                            updateGraph();
                        });
                }
            }
            // Transform the parent into a media node
            parentNode.isMediaNode = true;
            parentNode.mediaType = type;
            parentNode.mediaSrc = src;
            parentNode.mediaMetadata = metadata;
            
            // Push transformation to historyStack
            historyStack.push({type: 'transform-media', nodeId: parentNode.id, prevState});
            
            updateGraph();
            simulation.alpha(0.1).restart();
            
            // Show success message
            const mediaTypeNames = {
                'image': 'Image',
                'youtube': 'YouTube Video',
                'vimeo': 'Vimeo Video',
                'twitter': 'Twitter Post',
                'github': 'GitHub Repository',
                'pdf': 'PDF Document',
                'link': 'Link'
            };
            const mediaName = mediaTypeNames[type] || 'Media';
            addAssistantMessage(`Added ${mediaName} to "${parentNode.name}"`, []);
            
            return parentNode;
        }

        // Intelligent link detection with metadata extraction
        function intelligentLinkDetection(url) {
            // 1. YouTube videos
            const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/)|youtu\.be\/)([\w-]{11})/;
            const youtubeMatch = url.match(youtubeRegex);
            if (youtubeMatch && youtubeMatch[1]) {
                return {
                    type: 'youtube',
                    src: `https://www.youtube.com/embed/${youtubeMatch[1]}`,
                    metadata: {
                        videoId: youtubeMatch[1],
                        oembedUrl: `https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=${youtubeMatch[1]}&format=json`,
                        thumbnail: `https://img.youtube.com/vi/${youtubeMatch[1]}/maxresdefault.jpg`,
                        originalUrl: url
                    }
                };
            }

            // 2. Vimeo videos
            const vimeoRegex = /(?:https?:\/\/)?(?:www\.)?vimeo\.com\/(\d+)/;
            const vimeoMatch = url.match(vimeoRegex);
            if (vimeoMatch && vimeoMatch[1]) {
                return {
                    type: 'vimeo',
                    src: `https://player.vimeo.com/video/${vimeoMatch[1]}`,
                    metadata: {
                        videoId: vimeoMatch[1],
                        originalUrl: url
                    }
                };
            }

            // 3. Twitter/X posts
            const twitterRegex = /(?:https?:\/\/)?(?:www\.)?(?:twitter\.com|x\.com)\/\w+\/status\/(\d+)/;
            const twitterMatch = url.match(twitterRegex);
            if (twitterMatch && twitterMatch[1]) {
                return {
                    type: 'twitter',
                    src: url,
                    metadata: {
                        tweetId: twitterMatch[1],
                        embedUrl: `https://platform.twitter.com/embed/Tweet.html?id=${twitterMatch[1]}`
                    }
                };
            }

            // 4. GitHub repositories
            const githubRegex = /(?:https?:\/\/)?(?:www\.)?github\.com\/([^\/]+)\/([^\/]+)/;
            const githubMatch = url.match(githubRegex);
            if (githubMatch && githubMatch[1] && githubMatch[2]) {
                return {
                    type: 'github',
                    src: url,
                    metadata: {
                        owner: githubMatch[1],
                        repo: githubMatch[2],
                        apiUrl: `https://api.github.com/repos/${githubMatch[1]}/${githubMatch[2]}`
                    }
                };
            }

            // 5. Google Images redirect URLs
            const googleMatch = url.match(/[?&]imgurl=([^&]+)/);
            if (googleMatch && googleMatch[1]) {
                try {
                    const decodedUrl = decodeURIComponent(googleMatch[1]);
                    return {
                        type: 'image',
                        src: decodedUrl,
                        metadata: { source: 'google-images', originalUrl: url }
                    };
                } catch (e) {
                    console.error("Could not decode Google Image URL", e);
                }
            }

            // 6. Unsplash photo pages
            const unsplashMatch = url.match(/unsplash\.com\/photos\/([^/]+)/);
            if (unsplashMatch && unsplashMatch[1]) {
                return {
                    type: 'image',
                    src: `https://source.unsplash.com/${unsplashMatch[1]}`,
                    metadata: { source: 'unsplash', photoId: unsplashMatch[1], originalUrl: url }
                };
            }

            // 7. Direct image URLs
            if (url.startsWith('data:image') || /\.(jpg|jpeg|png|gif|svg|webp)$/i.test(url)) {
                return {
                    type: 'image',
                    src: url,
                    metadata: { source: 'direct' }
                };
            }

            // 8. PDF documents
            if (/\.pdf$/i.test(url)) {
                return {
                    type: 'pdf',
                    src: url,
                    metadata: { fileType: 'pdf' }
                };
            }

            // 9. Extract domain for better link preview
            let domain = '';
            try {
                const urlObj = new URL(url.startsWith('http') ? url : `https://${url}`);
                domain = urlObj.hostname.replace('www.', '');
            } catch (e) {
                domain = url.split('/')[0];
            }

            // 10. Default: generic link with domain info
            return {
                type: 'link',
                src: url,
                metadata: {
                    domain: domain,
                    isSecure: url.startsWith('https://'),
                    favicon: `https://www.google.com/s2/favicons?domain=${domain}&sz=32`
                }
            };
        }

        // Refactored forceLinkRepel to use d3.quadtree for node-to-link repulsion
        function forceLinkRepel() {
            const repulsionStrength = 1.2;
            const repulsionDistance = 45;
            const textRepulsionStrength = 0.8;
            const linkRepulsionStrength = 0.6;
            return function(alpha) {
                // Build quadtree for node positions
                const nodeQuadtree = d3.quadtree()
                    .x(d => d.x)
                    .y(d => d.y)
                    .addAll(nodes);
                // Node-to-link repulsion (quadtree for nodes)
                links.forEach(link => {
                    const x1 = link.source.x;
                    const y1 = link.source.y;
                    const x2 = link.target.x;
                    const y2 = link.target.y;
                    nodeQuadtree.visit((quad, x0, y0, x1q, y1q) => {
                        if (!quad.data) return false;
                        const node = quad.data;
                        if (node.depth === 1) return false;
                        if (link.source === node || link.target === node) return false;
                        const x0n = node.x;
                        const y0n = node.y;
                        const l2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
                        if (l2 === 0) return false;
                        let t = ((x0n - x1) * (x2 - x1) + (y0n - y1) * (y2 - y1)) / l2;
                        t = Math.max(0, Math.min(1, t));
                        const closestX = x1 + t * (x2 - x1);
                        const closestY = y1 + t * (y2 - y1);
                        const dx = x0n - closestX;
                        const dy = y0n - closestY;
                        const d = Math.sqrt(dx * dx + dy * dy);
                        if (d < repulsionDistance && d > 0) {
                            const force = repulsionStrength * (1 - d / repulsionDistance) * alpha;
                            const forceX = (dx / d) * force;
                            const forceY = (dy / d) * force;
                            node.vx += forceX;
                            node.vy += forceY;
                            const tInv = 1 - t;
                            link.source.vx -= forceX * tInv * 0.3;
                            link.source.vy -= forceY * tInv * 0.3;
                            link.target.vx -= forceX * t * 0.3;
                            link.target.vy -= forceY * t * 0.3;
                        }
                        return x0 > node.x + repulsionDistance || x1q < node.x - repulsionDistance || y0 > node.y + repulsionDistance || y1q < node.y - repulsionDistance;
                    });
                });
                // Link-to-link repulsion (keep original logic for now)
                for (let i = 0; i < links.length; i++) {
                    for (let j = i + 1; j < links.length; j++) {
                        const link1 = links[i];
                        const link2 = links[j];
                        if (link1.source === link2.source || link1.source === link2.target || link1.target === link2.source || link1.target === link2.target) continue;
                        const mid1X = (link1.source.x + link1.target.x) / 2;
                        const mid1Y = (link1.source.y + link1.target.y) / 2;
                        const mid2X = (link2.source.x + link2.target.x) / 2;
                        const mid2Y = (link2.source.y + link2.target.y) / 2;
                        const dx = mid1X - mid2X;
                        const dy = mid1Y - mid2Y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < 30 && distance > 0) {
                            const force = linkRepulsionStrength * (1 - distance / 30) * alpha;
                            const forceX = (dx / distance) * force;
                            const forceY = (dy / distance) * force;
                            link1.source.vx += forceX * 0.25;
                            link1.source.vy += forceY * 0.25;
                            link1.target.vx += forceX * 0.25;
                            link1.target.vy += forceY * 0.25;
                            link2.source.vx -= forceX * 0.25;
                            link2.source.vy -= forceY * 0.25;
                            link2.target.vx -= forceX * 0.25;
                            link2.target.vy -= forceY * 0.25;
                        }
                    }
                }
                // Text-to-link repulsion (keep original logic for now)
                nodes.forEach(node => {
                    if (node.isExpanded || node.isListNode || node.isMediaNode) return;
                    if (node.depth === 1) return;
                    const textX = node.x;
                    let textY, textRadius;
                    if (node.depth === 0) {
                        textY = node.y + 60;
                        textRadius = 45;
                    } else if (node.depth === 1) {
                        textY = node.y;
                        textRadius = 60;
                    } else {
                        textY = node.y + node.radius + 12;
                        textRadius = 25;
                    }
                    links.forEach(link => {
                        if (link.source === node || link.target === node) return;
                        const x1 = link.source.x;
                        const y1 = link.source.y;
                        const x2 = link.target.x;
                        const y2 = link.target.y;
                        const l2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
                        if (l2 === 0) return;
                        let t = ((textX - x1) * (x2 - x1) + (textY - y1) * (y2 - y1)) / l2;
                        t = Math.max(0, Math.min(1, t));
                        const closestX = x1 + t * (x2 - x1);
                        const closestY = y1 + t * (y2 - y1);
                        const dx = textX - closestX;
                        const dy = textY - closestY;
                        const d = Math.sqrt(dx * dx + dy * dy);
                        if (d < textRadius && d > 0) {
                            const force = textRepulsionStrength * (1 - d / textRadius) * alpha;
                            const forceX = (dx / d) * force;
                            const forceY = (dy / d) * force;
                            node.vx += forceX;
                            node.vy += forceY;
                            const tInv = 1 - t;
                            link.source.vx -= forceX * tInv * 0.1;
                            link.source.vy -= forceY * tInv * 0.1;
                            link.target.vx -= forceX * t * 0.1;
                            link.target.vy -= forceY * t * 0.1;
                        }
                    });
                });
            };
        }

        // Force to keep nodes within viewport bounds
        function forceViewportBounds() {
            let nodes;
            let width;
            let height;
            let strength = 0.1;

            function force() {
                if (!nodes) return;
                
                for (let i = 0; i < nodes.length; i++) {
                    const node = nodes[i];
                    if (node.fx !== undefined || node.fy !== undefined) continue;
                    
                    const radius = node.radius || 20;
                    const margin = 50;
                    
                    // X bounds
                    if (node.x < radius + margin) {
                        node.vx += (radius + margin - node.x) * strength;
                    } else if (node.x > width - radius - margin) {
                        node.vx += (width - radius - margin - node.x) * strength;
                    }
                    
                    // Y bounds
                    if (node.y < radius + margin) {
                        node.vy += (radius + margin - node.y) * strength;
                    } else if (node.y > height - radius - margin) {
                        node.vy += (height - radius - margin - node.y) * strength;
                    }
                }
            }

            force.initialize = function(_) { 
                nodes = _; 
                width = container.clientWidth;
                height = container.clientHeight;
            };
            
            force.width = function(_) {
                return arguments.length ? (width = _, force) : width;
            };
            
            force.height = function(_) {
                return arguments.length ? (height = _, force) : height;
            };
            
            force.strength = function(_) {
                return arguments.length ? (strength = _, force) : strength;
            };

            return force;
        }

        // LLM endpoint check on startup
        const LLM_ENDPOINT = 'http://localhost:1234/v1';
        function checkLlmEndpoint() {
            fetch(LLM_ENDPOINT, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ test: true }) })
                .then(res => {
                    if (!res.ok) throw new Error('LLM endpoint not reachable');
                })
                .catch(() => {
                    // Show prominent message in UI
                    let llmWarning = document.getElementById('llm-warning');
                    if (!llmWarning) {
                        llmWarning = document.createElement('div');
                        llmWarning.id = 'llm-warning';
                        llmWarning.style.position = 'fixed';
                        llmWarning.style.top = '0';
                        llmWarning.style.left = '0';
                        llmWarning.style.width = '100vw';
                        llmWarning.style.background = '#b71c1c';
                        llmWarning.style.color = 'white';
                        llmWarning.style.fontWeight = 'bold';
                        llmWarning.style.fontSize = '1.1rem';
                        llmWarning.style.padding = '1rem 2rem';
                        llmWarning.style.zIndex = '2000';
                        llmWarning.style.textAlign = 'center';
                        llmWarning.innerHTML = `
                            <span>⚠️ Unable to connect to Local AI (LLM) at <code>${LLM_ENDPOINT}</code>.<br>
                            Please ensure LM Studio or your local LLM server is running.<br>
                            <a href='https://lmstudio.ai/' target='_blank' style='color:#fff;text-decoration:underline;'>Get LM Studio</a> or check your endpoint settings.</span>
                        `;
                        document.body.appendChild(llmWarning);
                    }
                });
        }
        window.addEventListener('DOMContentLoaded', checkLlmEndpoint);

        // Import JSON functionality
        window.addEventListener('DOMContentLoaded', () => {
            const importJsonTopBarBtn = document.getElementById('import-json');
            const importJsonFileInput = document.getElementById('import-json-file');
            if (importJsonTopBarBtn && importJsonFileInput) {
                importJsonTopBarBtn.addEventListener('click', () => importJsonFileInput.click());
                importJsonFileInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = JSON.parse(e.target.result);
                            if (Array.isArray(data.nodes) && data.nodes.length > 0 && Array.isArray(data.links)) {
                                nodes = data.nodes;
                                links = data.links;
                                // Redraw or re-initialize the mindmap as needed
                                location.reload(); // Or call your redraw/init function
                            } else {
                                alert('Invalid or empty mindmap JSON. The current mindmap will not be changed.');
                            }
                        } catch (err) {
                            alert('Failed to import JSON: ' + err.message + '\nThe current mindmap will not be changed.');
                        }
                    };
                    reader.readAsText(file);
                    event.target.value = '';
                });
            }
        });
    </script>
</body>
</html>